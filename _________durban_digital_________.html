<!DOCTYPE HTML>
<html>

<!-- HEADER -->
<head>

<meta charset="UTF-8">

<title>"""
     Durban Digital
        SPACE CONCEPTS
"""</title>

<script type="text/bitsyGameData" id="exportedGameData">
"""
     Durban Digital
        SPACE CONCEPTS
"""

# BITSY VERSION 8.3

! VER_MAJ 8
! VER_MIN 3
! ROOM_FORMAT 1
! DLG_COMPAT 0
! TXT_MODE 0

PAL 0
0,82,204
128,159,255
255,255,255
NAME blueprint

PAL 1
199,204,254
53,38,0
0,0,0

PAL 2
199,204,254
53,38,0
0,0,0

PAL 3
199,204,254
53,38,0
0,0,0

PAL 4
122,74,0
53,38,0
0,0,0

PAL 5
255,251,185
20,47,77
0,0,0

PAL 6
233,172,2
102,97,0
0,0,0

PAL 7
196,145,2
102,97,0
0,0,0

PAL 8
248,228,255
68,68,68
0,0,0

PAL 9
217,202,254
81,58,0
0,0,0

PAL a
217,202,254
81,58,0
0,0,0

PAL b
255,204,164
81,58,0
0,0,0

PAL c
255,242,213
81,58,0
0,0,0

PAL d
255,242,213
81,58,0
0,0,0

ROOM 0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,0,0,0,0,0,0,0,0,0,0,0,0,a,0
0,a,a,a,a,a,a,a,a,a,a,a,a,a,a,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME example room
PAL 0

ROOM 1
1,2,3,4,5,6,7,8,9,b,c,d,e,f,g,h
i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x
y,z,10,11,12,13,14,15,16,17,18,19,1a,1b,1c,1d
1e,1f,1g,1h,1i,1j,1k,1l,1m,1n,1o,1p,1q,1r,1s,1t
1u,1v,1w,1x,1y,1z,20,21,22,23,24,25,26,27,28,29
2a,2b,2c,2d,2e,2f,2g,2h,2i,2j,2k,2l,2m,2n,2o,2p
2q,2r,2s,2t,2u,2v,2w,2x,2y,2z,30,31,32,33,34,35
36,37,38,39,3a,3b,3c,3d,3e,3f,3g,3h,3i,3j,3k,3l
3m,3n,3o,3p,3q,3r,3s,3t,3u,3v,3w,3x,3y,3z,40,41
42,43,44,45,46,47,48,49,4a,4b,4c,4d,4e,4f,4g,4h
4i,4j,4k,4l,4m,4n,4o,4p,4q,4r,4s,4t,4u,4v,4w,4x
4y,4z,50,51,52,53,54,55,56,57,58,59,5a,5b,5c,5d
5e,5f,5g,5h,5i,5j,5k,5l,5m,5n,5o,5p,5q,5r,5s,5t
5u,5v,5w,5x,5y,5z,60,61,62,63,64,65,66,67,68,69
6a,6b,6c,6d,6e,6f,6g,6h,6i,6j,6k,6l,6m,6n,6o,6p
6q,6r,6s,6t,6u,6v,6w,6x,6y,6z,70,71,72,73,74,75
NAME Hallway Corner 1st
EXT 11,8 2 11,15
EXT 12,8 2 11,15
EXT 1,11 6 14,14
EXT 2,11 6 14,14
EXT 9,9 9 14,14
PAL 1

ROOM 2
76,77,78,79,7a,7b,7c,7d,7e,7f,7g,7h,7i,7j,7k,7l
7m,7n,7o,7p,7q,7r,7s,7t,7u,7v,7w,7x,7y,7z,80,81
82,83,84,85,86,87,88,89,8a,8b,8c,8d,8e,8f,8g,8h
8i,8j,8k,8l,8m,8n,8o,8p,8q,29,29,29,8r,8s,8t,8u
8v,8w,8x,8y,8z,90,91,92,93,94,95,96,97,98,99,9a
9b,9c,9d,9e,9f,9g,9h,9i,9j,9k,9l,9m,9n,9o,9p,9q
9r,9s,9t,9u,9v,9w,9x,9y,9z,a0,a1,a2,a3,a4,a5,a6
a7,a8,a9,aa,ab,ac,ad,ae,af,ag,ah,ai,aj,ak,al,am
an,ao,ap,aq,ar,as,at,au,av,aw,29,ax,ay,az,b0,b1
b2,b3,b4,b5,b6,b7,b8,b9,ba,bb,bc,bd,be,bf,bg,bh
bi,bj,bk,bl,bm,bn,bo,bp,bq,br,bs,bt,bu,bv,bw,bx
by,0,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,ca,cb,cc,cd
ce,cf,cg,ch,ci,cj,ck,cl,cm,cn,co,cp,cq,cr,cs,ct
cu,cv,cw,cx,cy,cz,d0,d1,d2,d3,d4,d5,d6,d7,d8,d9
da,db,dc,dc,dd,de,df,dg,dh,di,dj,dk,dl,dm,dn,do
dp,dq,dr,ds,dt,du,dv,dw,dx,dy,dz,e0,e1,e2,e3,e4
NAME Hallway Corner 2nd 
EXT 14,14 c 11,15
EXT 10,8 4 8,13
EXT 11,8 4 8,13
EXT 5,9 7 14,14
EXT 4,9 7 14,14
EXT 3,14 3 12,15
EXT 14,13 c 11,15
EXT 0,9 3 13,13
EXT 0,10 3 13,15
PAL 2

ROOM 3
bz,e5,e6,e7,e8,e9,ea,eb,ec,ed,ee,ef,eg,eh,ei,ej
ek,el,em,en,29,eo,ep,eq,er,es,et,eu,ev,ew,ex,ey
ez,f0,f1,f2,f3,29,f4,f5,f6,f7,f8,f9,fa,fb,fc,fd
fe,ff,fg,fh,fi,fj,fk,fl,fm,fn,fo,fp,fq,fr,fs,ft
fu,fv,fw,fx,fy,fz,g0,g1,g2,g3,g4,g5,g6,g7,g8,g9
ga,gb,gc,gd,ge,gf,gg,gh,gi,gj,gk,gl,gm,gn,go,gp
gq,gr,gs,gt,29,29,gu,gv,gw,gx,gy,29,gz,h0,h1,h2
h3,h4,h5,h6,29,29,h7,h8,h9,ha,hb,hc,hd,he,hf,hg
29,hh,hi,hj,hk,hl,hm,hn,ho,hp,hq,hr,hs,ht,hu,hv
hw,hx,hy,hz,i0,i1,i2,i3,i4,i5,i6,i7,i8,i9,ia,ib
ic,id,ie,if,ig,ih,ii,ij,ik,il,im,in,io,ip,iq,ir
is,it,iu,iv,iw,ix,iy,iz,j0,j1,j2,j3,j4,j5,j6,j7
j8,j9,ja,jb,jc,jd,je,jf,jg,jh,ji,jj,jk,jl,jm,jn
jo,jp,jq,jr,js,jt,ju,jv,jw,jx,jy,jz,k0,k1,k2,k3
k4,k5,k6,k7,k8,k9,ka,kb,kc,kd,ke,kf,kg,kh,ki,kj
kk,kl,km,kn,ko,kp,kq,kr,ks,kt,ku,ku,ku,kv,kw,kx
NAME bigger hallway room 2 story
EXT 13,15 2 0,9
EXT 4,7 5 14,1
EXT 5,7 5 14,1
EXT 3,7 5 14,2
EXT 0,8 b 14,14
EXT 10,6 d 13,13
EXT 11,7 d 13,13
EXT 12,7 d 13,13
EXT 14,8 8 14,14
EXT 8,6 a 13,13
PAL 3

ROOM 4
29,ky,kz,l0,l1,l2,l3,l4,l5,l6,l7,l8,l9,la,29,29
29,lb,lc,ld,le,lf,lg,lh,li,lj,lk,ll,lm,ln,lo,29
lp,lq,lr,ls,lt,lu,lv,lw,lx,ly,lz,m0,m1,m2,m3,m4
29,m5,m6,m7,m8,m9,ma,mb,mc,md,me,mf,mg,mh,mi,mj
mk,ml,mm,mn,mo,mp,mq,mr,ms,mt,mu,mv,mw,mx,my,mz
n0,n1,n2,n3,n4,n5,n6,n7,n8,n9,na,nb,nc,nd,ne,nf
29,ng,nh,ni,nj,nk,nl,nm,nn,no,np,nq,nr,ns,nt,29
nu,nv,nw,nx,ny,29,nz,o0,o1,o2,o3,o4,o5,o6,29,o7
o8,o9,oa,29,29,ob,oc,od,oe,29,29,29,of,og,29,oh
oi,oj,1t,ok,ol,29,29,om,on,o9,29,29,29,29,29,oo
ny,29,op,29,29,oq,or,os,ot,ou,ov,29,ow,ox,oy,oz
p0,29,29,29,29,29,p1,p2,p3,p4,p5,29,p6,p7,29,29
p8,p9,pa,pb,pc,pd,pe,pf,pg,ph,pi,29,pj,pk,pl,pm
pn,po,pp,pq,pr,ps,pt,pu,pv,pw,29,px,py,29,pz,q0
29,29,29,29,29,29,q1,q2,q3,q4,29,29,29,29,29,29
29,29,29,29,29,29,q5,q6,q7,q8,29,29,29,29,29,29
NAME stair room with people
EXT 8,13 2 10,8
PAL 4

ROOM 5
q9,qa,qb,qc,qd,qe,qf,qg,qh,qi,qj,qb,qc,qd,qe,qf
qk,ql,qm,qn,qo,qp,qq,qr,qs,qt,qu,qv,qw,qo,qp,qq
qx,qy,qz,r0,r1,r2,r3,r4,r5,r6,r7,r8,r9,ra,r2,rb
rc,rd,re,rf,rg,rh,ri,rj,rk,rl,rm,rn,ro,rp,rq,rr
qk,rs,rt,ru,rv,rw,rx,ry,rz,s0,s1,s2,s3,s4,s5,s6
s7,s8,s9,sa,sb,sc,sd,se,sf,sg,sh,si,sj,sk,sl,sm
sn,so,sp,sq,sr,ss,st,su,sv,sw,sx,sy,sz,t0,t1,t2
t3,t4,t5,t6,t7,t8,t9,ta,tb,tc,td,te,tf,tg,th,ti
tj,tk,tl,tm,tn,to,tp,tq,tr,ts,tt,tu,tv,tw,tx,ty
tz,u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,ua,ub,uc,ud,ue
uf,ug,uh,ui,uj,uk,ul,um,un,uo,up,uq,ur,us,ut,uu
uv,uw,ux,uy,uz,v0,v1,v2,v3,v4,v5,v6,v7,v8,v9,va
vb,vc,vd,ve,vf,vg,vh,vi,vj,vk,vl,vm,vn,vo,vp,vq
vr,vs,vt,vu,vv,vw,vx,vy,vz,29,29,w0,w1,w2,w3,w4
w5,w6,w7,w8,w9,wa,wb,wc,wd,29,29,29,29,we,wf,wg
wh,wi,wj,wk,wl,wm,wn,wo,wp,29,29,29,29,wq,wr,ws
NAME stair room with people
EXT 14,0 3 6,8
EXT 15,1 3 6,8
EXT 13,1 3 6,8
EXT 14,2 3 2,12
PAL 5

ROOM 6
of,wt,29,29,wu,wv,29,29,29,29,ww,wx,29,wy,wz,x0
29,x1,29,29,29,x2,29,29,29,29,x3,1t,29,x4,x5,x6
29,29,29,29,x7,x8,29,29,29,29,x9,xa,29,xb,xc,xd
29,29,29,29,xe,xf,29,29,29,29,xg,1t,29,xh,xi,xj
29,29,29,29,xk,29,29,29,29,29,xl,xm,xn,0,xp,xq
29,29,29,xr,xs,29,29,29,29,29,xt,xu,xv,0,lt,xw
29,29,xx,xy,29,29,29,29,29,29,29,29,xz,0,0,y0
29,y1,y2,1t,29,29,29,29,29,rz,y3,29,y4,0,0,y5
29,y6,y7,29,29,29,y8,y9,ya,29,yb,29,xz,0,0,0
yc,29,29,29,29,yd,ye,yf,29,yg,yh,29,yi,0,0,yj
yk,yl,ym,yn,yo,yp,yq,29,yr,ys,yt,29,29,yu,yv,yw
29,29,yx,yy,yz,z0,z1,z2,z3,z4,z5,z6,z7,z8,z9,za
zb,lo,29,29,zc,zd,ze,zf,zg,zh,zi,zj,zk,zl,zm,zn
zo,zp,zq,29,29,29,29,29,29,29,29,29,29,zr,zs,zt
zu,zv,zw,29,29,29,29,29,29,29,29,zx,zy,zz,0,0
100,101,102,103,104,105,106,107,108,109,10a,0,10b,0,0,0
NAME Hand Radio
EXT 14,13 1 2,12
EXT 15,14 1 1,12
EXT 14,15 1 2,12
EXT 13,14 1 1,12
PAL 6

ROOM 7
xo,10c,10d,10e,10f,10g,10h,10i,10j,10k,10k,10l,10m,10n,10o,10p
10q,10r,10s,10t,10u,10v,10w,10x,10y,10z,110,111,112,0,0,0
114,115,116,117,118,119,11a,11b,11c,11d,11e,11f,11g,0,0,0
11h,11i,11j,11k,11l,11m,11n,11o,11p,11q,11r,11s,11t,0,0,0
11u,11v,11w,11x,11y,11z,120,121,122,123,124,125,126,0,0,0
127,128,129,12a,12b,12c,12d,12e,12f,12g,12h,12i,12j,0,0,0
12k,12l,12m,12n,12o,12p,12q,12r,12s,12t,12u,12v,12w,12x,12y,12z
0,0,0,130,131,132,133,134,135,136,137,0,0,138,139,13a
0,0,0,13b,13c,13d,13e,0,13f,13g,13h,13i,13j,13k,13l,13m
0,0,0,13n,13o,13p,13q,0,13r,13s,13t,13u,13v,13w,13x,13y
0,0,0,0,0,13z,140,141,142,143,144,145,146,147,148,149
0,0,0,0,0,14a,14b,14c,14d,14e,14f,14g,14h,14i,14j,14k
0,0,0,0,0,0,14l,14m,14n,14o,14p,14q,14r,14s,14t,14u
0,14v,0,0,0,0,0,0,14w,14x,14y,14z,150,151,152,153
0,0,0,0,0,0,0,0,0,0,0,154,155,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,lt
NAME Cactus Field
EXT 14,13 2 5,10
EXT 14,15 2 4,10
EXT 15,14 2 5,10
EXT 13,14 2 4,10
PAL 7

ROOM 8
113,156,157,158,159,15a,15b,15c,15d,15e,15f,15g,15h,15i,15j,15k
15l,15m,15n,15o,15p,15q,15r,15s,15t,15u,15v,15w,15x,15y,15z,160
161,162,163,164,165,166,167,168,169,16a,16b,16c,16d,16e,16f,16g
16h,16i,16j,16k,16l,16m,rz,16n,16o,16p,16q,16r,16s,16t,16u,16v
16w,16x,16y,16z,170,171,172,173,174,175,176,177,178,py,179,17a
17b,17c,17d,17e,17f,17g,17h,17i,17j,17k,17l,17m,17n,17o,17p,17q
17r,17s,17t,17u,17v,17w,17x,17y,17z,180,181,182,183,184,185,186
187,188,189,18a,18b,18c,18d,18e,18f,18g,18h,18i,18j,18k,18l,18m
18n,0,0,18p,18q,18r,18s,18t,18u,18v,18w,18x,18y,18z,190,191
192,193,0,194,195,196,197,198,199,19a,19b,19c,19d,19e,19f,19g
19h,19i,19j,19k,19l,19m,19n,19o,19p,19q,19r,19s,19t,19u,19v,19w
19x,19y,19z,1a0,1a1,1a2,1a3,1a4,1a5,1a6,1a7,1a8,1a9,1aa,1ab,1ac
1ad,1ae,1af,1ag,1ah,1ai,1aj,1ak,1al,1am,1an,1ao,1ap,1aq,1ar,1as
1at,1au,1av,1aw,1ax,1ay,1az,1b0,1b1,1b2,1b3,1b4,1b5,1b6,1b7,1b8
1b9,29,1ba,1bb,1bc,29,1bd,1be,1bf,1bg,1bh,1bi,1bj,1bk,1bl,1bm
1bn,95,29,1bo,1bp,1bq,1br,1bs,1bt,1bu,1bv,1bw,1bx,1by,1bz,1c0
NAME Data Pal In His Field
EXT 14,13 3 13,10
EXT 14,15 3 13,10
EXT 15,14 3 13,10
EXT 13,14 3 13,10
PAL 8

ROOM 9
18o,1c1,1c2,1c3,1c4,1c5,1c6,1c7,1c8,1c9,1ca,1cb,1cc,1cd,1ce,1cf
1cg,1ch,1ci,1cj,1ck,1cl,1cm,1cn,1co,1cp,1cq,1cr,1cs,1ct,zq,29
1cu,1cv,1cw,1cx,1cy,1cz,1d0,1d1,1d2,1d3,1d4,1d5,1d6,1k,29,29
1d7,1d8,1d9,1da,1db,1dc,1dd,1de,1df,1dg,1dh,1di,1dj,1dk,1dl,1dm
29,1dn,1do,1dp,1dq,1dr,1ds,1dt,1du,1dv,1dw,29,1dx,1dy,1dz,1e0
29,1e1,1e2,1e3,1e4,1e5,1e6,1e7,1e8,1e9,1ea,29,1eb,1ec,1ed,1ee
1ef,1eg,1eh,1ei,1ej,1ek,1el,1em,1en,1eo,1ep,1eq,1er,1es,1et,1eu
1ev,1ew,1ex,1ey,1ez,1f0,1f1,1f2,1f3,1f4,1f5,1f6,1f7,1f8,29,29
1f9,1fa,1fb,1fc,1fd,1fe,1ff,1fg,1fh,1fi,1fj,1fk,1fl,1fm,29,29
1fn,1fo,1fp,1fq,1fr,1fs,1ft,1fu,1fv,1fw,1fx,1fy,29,29,29,29
1fz,1g0,1g1,1g2,1g3,1g4,1g5,1g6,1g7,1g8,1g9,1ga,29,29,29,29
1gb,1gc,1gd,1ge,1gf,1gg,1gh,1gi,1gj,29,1gk,1gl,29,29,29,29
1gm,1gn,1go,1gp,1gq,1gr,1gs,1gt,1gu,1gv,29,1gw,29,29,29,29
1gx,1gy,1gz,1h0,1h1,1h2,1h3,1h4,1h5,1h6,1h7,1h8,29,29,29,29
1h9,1ha,1hb,1hc,1hd,1he,1hf,1hg,1hh,1hi,1hj,1hk,29,29,29,29
1hl,1hm,1hn,1ho,1hp,1hq,1hr,1hs,1ht,1hu,1hv,1hw,29,29,29,29
NAME Canvas Thing
EXT 14,13 1 9,10
EXT 14,15 1 9,10
EXT 15,14 1 9,10
EXT 13,14 1 9,10
PAL 9

ROOM a
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,1hy,1hz,0,0,0,0,0,0,0
0,0,0,0,0,0,1i0,1i1,1i2,1i3,0,0,0,0,0,0
0,0,0,0,0,1i4,1i5,1i6,1i7,1i8,1i9,0,0,0,0,0
0,0,0,0,0,1ia,1ib,1ic,1id,1ie,1if,0,0,0,0,0
0,0,0,0,0,1ig,1ih,1ii,1ij,1ik,1il,0,0,0,0,0
0,0,0,0,1im,1in,1io,1ip,1iq,1ir,1is,1it,0,0,0,0
0,0,0,0,1iu,1iv,1iw,1ix,1iy,1iz,1j0,1j1,0,0,0,0
0,0,0,0,1j2,1j3,1j4,1j5,1j6,1j7,1j8,1j9,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NAME houseu
EXT 13,12 3 2,4
EXT 14,13 3 2,4
EXT 12,13 3 2,4
EXT 13,14 3 2,4
PAL a

ROOM b
1hx,1ja,1jb,1jc,1jd,1je,1jf,1jg,1jh,1ji,1jj,1jk,1jl,1jm,0,1jo
1jp,1jq,1jr,1js,1jt,1ju,1jv,1jw,1jx,1jy,1jz,1k0,1k1,1k2,1k3,1k4
1k5,1k6,1k7,1k8,1k9,1ka,1kb,1kc,1kd,1ke,1kf,1kg,1kh,1ki,1kj,1kk
1kl,1km,1kn,1ko,1kp,1kq,1kr,1ks,1kt,1ku,1kv,1kw,1kx,1ky,1kz,1l0
1l1,1l2,1l3,29,1l4,1l5,1l6,1l7,1l8,1l9,1la,1lb,1lc,1ld,1le,1lf
29,29,29,rz,1lg,29,29,1lh,1li,1lj,1lk,1ll,1lm,1ln,1lo,1lp
1lq,29,29,1lr,1ls,1lt,1lu,1lv,1lw,1lx,1ly,1lz,1m0,1m1,1m2,1m3
1m4,29,1m5,1m6,1m7,29,rz,1m8,1m9,1ma,1mb,1mc,1md,1me,1mf,1mg
94,1mh,1mi,zq,29,1bp,1mj,1mk,1ml,1mm,1mn,1mo,1mp,1mq,1mr,1ms
1t,1mt,1mu,1mv,1mw,29,1mx,1my,1mz,1n0,1n1,1n2,1n3,1n4,1n5,1n6
1n7,1n8,29,29,29,1n9,1na,1nb,1nc,1nd,1ne,1nf,1ng,1nh,1ni,1nj
1nk,1nl,1nm,29,29,1nn,1no,1np,1nq,1nr,1ns,1nt,1nu,1nv,1nw,1nx
1ny,1nz,1o0,29,1o1,1o2,1o3,1o4,ny,1o5,1o6,1o7,1o8,1o9,1oa,1ob
1oc,1od,29,29,1oe,1of,1og,29,1oh,1oi,1oj,1ok,1ol,1om,1on,1oo
1op,1oq,29,of,1or,1os,29,1ot,1ou,1ov,1ow,1ox,1oy,1oz,1p0,1p1
29,29,29,1k,1p2,1p3,1p4,1p5,1p6,1p7,oy,29,1p8,1p9,1pa,1pb
NAME Grid Walk
EXT 14,13 3 2,10
EXT 14,15 3 2,10
EXT 15,14 3 2,10
EXT 13,14 3 2,10
PAL b
TUNE 2

ROOM c
29,1jn,29,29,29,29,29,29,1pc,1pd,1pe,1pf,1pg,1ph,1pi,1pj
1p8,1pk,1pl,1pm,1pn,29,29,29,1po,1pp,1pq,1pr,1ps,1pt,1pu,1pv
1pw,29,29,29,1px,1py,1pz,1q0,1q1,1q2,1q3,1q4,1q5,1q6,1q7,1q8
1q9,1qa,1qb,1qc,1qd,1qe,1qf,1qg,1qh,1qi,1qj,1qk,1ql,1qm,1qn,1qo
1qp,1qq,1qr,1qs,1qt,1qu,1qv,1qw,1qx,1qy,1qz,1r0,1r1,1r2,1r3,1r4
1r5,1r6,1r7,1r8,1r9,1ra,1rb,1rc,1rd,1re,1rf,1rg,1rh,1ri,1rj,1rk
1rl,1rm,1rn,1ro,1rp,1rq,1rr,1rs,1rt,1ru,1rv,1rw,1rx,1ry,1rz,1s0
1s1,lo,29,29,1s2,1s3,1s4,1s5,1s6,1s7,1s8,1s9,1sa,29,1sb,1sc
1sd,1se,29,29,rz,1sf,1sg,1sh,1si,1sj,1sk,1sl,1sm,1sn,1so,1sp
1sq,1sr,1ss,29,29,1st,1su,1sv,1sw,1sx,1sy,1sz,1t0,1t1,1t2,1t3
1t4,1t5,1t6,1t7,1t8,29,29,1t9,1ta,1tb,1tc,1td,1te,1tf,1tg,1th
1mu,tv,1ti,1tj,1tk,1tl,1tm,1tn,1to,1tp,1tq,13e,1tr,1ts,1tt,1tu
29,29,1tv,1tw,1tx,1ty,1tz,1u0,1u1,1u2,1u3,1u4,1u5,1u6,1u7,1u8
29,1u9,1ua,1ub,1uc,1ud,1ue,1uf,1ug,1uh,1ui,1uj,1uk,1ul,1um,1un
1uo,1up,1uq,1ur,1us,29,29,29,1ut,1uu,1uv,1uw,1ux,1uy,29,1uz
1v0,1v1,1v2,1v3,29,29,29,29,1v4,1v5,1v6,1v7,1v8,1v9,1va,29
NAME earthbound
EXT 11,14 2 12,13
EXT 12,15 2 12,13
EXT 10,15 2 12,13
PAL c
TUNE 3

ROOM d
1vb,1vc,1vd,1ve,1vf,1vg,1vh,1vi,1vj,1vk,1vl,1vm,1vn,1vo,1vp,1vq
1vr,1vs,1vt,1vu,1vv,1vw,1vx,1vy,1vz,1w0,1w1,1w2,1w3,1w4,1w5,1w6
1w7,1w8,1w9,1wa,1wb,1wc,1wd,1we,1wf,1wg,1wh,1wi,1wj,1wk,1wl,1wm
1wn,1wo,1wp,1wq,1wr,1ws,1wt,1wu,1wv,1ww,1wx,1wy,1wz,1x0,1x1,1x2
1x3,1x4,1x5,1x6,1x7,1x8,1x9,1xa,1xb,1xc,1xd,1xe,1xf,1xg,1xh,1xi
1xj,1xk,1xl,1xm,1xn,1xo,1xp,1xq,1xr,1xs,1xt,1xu,1xv,1xw,1xx,1xy
1xz,1y0,1y1,1y2,1y3,1y4,1y5,1y6,1y7,1y8,1y9,1ya,1yb,1yc,1yd,1ye
1yf,1yg,1yh,1yi,1yj,1yk,1yl,1ym,1yn,1yo,1yp,1yq,1yr,1ys,1yt,1yu
1yv,1yw,1yx,1yy,1yz,1z0,1z1,1z2,1z3,1z4,1z5,1z6,1z7,1z8,1z9,1za
1zb,1zc,1zd,1ze,1zf,1zg,1zh,1zi,1zj,1zk,1zl,1zm,1zn,1zo,1zp,1zq
1zr,1zs,1zt,1zu,1zv,1zw,1zx,1zy,1zz,200,201,202,203,204,205,206
207,208,209,20a,20b,20c,20d,20e,20f,20g,20h,20i,20j,20k,20l,20m
20n,20o,20p,20q,20r,20s,20t,20u,20v,20w,20x,20y,20z,210,211,212
213,214,215,216,217,218,219,21a,21b,21c,21d,21e,21f,21g,21h,21i
21j,21k,21l,21m,21n,21o,21p,21q,21r,21s,21t,21u,21v,21w,21x,21y
21z,220,221,222,223,224,225,226,227,228,229,22a,22b,22c,22d,22e
NAME line
EXT 13,12 3 10,8
EXT 12,13 3 10,8
EXT 14,13 3 10,8
EXT 13,14 3 10,8
PAL d
TUNE 4

TIL 1
11111111
11111111
00000100
10110010
01001010
01010100
01000010
10101000
NAME Hallway Corner 1st (0,0)

TIL 2
11111111
11111111
01001000
10101010
10010000
01000101
10010010
00100000
NAME Hallway Corner 1st (1,0)

TIL 3
11111111
11111111
00000000
10100000
00000100
01010000
00000001
10101000
NAME Hallway Corner 1st (2,0)

TIL 4
11111111
11111111
00000000
00000101
00000000
00000000
00000000
00000000
NAME Hallway Corner 1st (3,0)

TIL 5
11111111
11111111
10001001
01010100
00010010
10001001
00100010
00001000
NAME Hallway Corner 1st (4,0)

TIL 6
11111111
11111111
00010010
10101001
10100101
00010101
01010010
10001001
NAME Hallway Corner 1st (5,0)

TIL 7
11111111
11111111
01001001
00100100
01010101
01010101
00100010
01001001
NAME Hallway Corner 1st (6,0)

TIL 8
11111111
11111111
00010001
10101010
01010101
01001001
00100100
01010010
NAME Hallway Corner 1st (7,0)

TIL 9
11111111
11111111
00010001
10101010
01010101
00100100
10010010
10101010
NAME Hallway Corner 1st (8,0)

TIL 10
10010000
01001001
10100100
00010010
10101000
01000101
00100010
10010101
NAME Hallway Corner 1st (2,2)

TIL 11
00000000
01010101
00000000
10100101
01001000
00100010
10011000
01000101
NAME Hallway Corner 1st (3,2)

TIL 12
00010000
01000100
00100001
00010100
01000001
00010100
01000001
00010100
NAME Hallway Corner 1st (4,2)

TIL 13
01101011
01011101
01101011
01110101
01011110
11110101
01101111
01110101
NAME Hallway Corner 1st (5,2)

TIL 14
11110101
11111010
11111101
11111111
11111111
11111111
11111111
11111111
NAME Hallway Corner 1st (6,2)

TIL 15
01010101
10101010
01010010
01010101
10101010
11010101
11101010
11110101
NAME Hallway Corner 1st (7,2)

TIL 16
01001010
10101000
01010101
01001010
10100101
00101001
10101010
01010100
NAME Hallway Corner 1st (8,2)

TIL 17
10100010
10010101
01001001
01010100
00100101
01010010
10010101
10100100
NAME Hallway Corner 1st (9,2)

TIL 18
01001001
00100100
01010101
10010010
01001001
00101010
01010010
10001001
NAME Hallway Corner 1st (10,2)

TIL 19
01001010
10100101
00101001
10010100
01010010
01001010
10101001
00100101
NAME Hallway Corner 1st (11,2)

TIL 20
01111111
01011111
10101110
11010111
11101001
01111101
10101010
11110111
NAME Hallway Corner 1st (6,4)

TIL 21
11111111
11011111
11111111
11111111
11111111
01111111
10101111
10101111
NAME Hallway Corner 1st (7,4)

TIL 22
11111010
11111101
01111110
11111111
11111111
11011111
01111101
11111111
NAME Hallway Corner 1st (8,4)

TIL 23
10101010
00101010
10101010
10101001
11010101
11101010
11110101
11111010
NAME Hallway Corner 1st (9,4)

TIL 24
10100101
10010100
01010010
01010101
01001010
10101001
01010101
10100100
NAME Hallway Corner 1st (10,4)

TIL 25
01001001
10101010
10010100
01010010
01001010
01010001
00101010
10100101
NAME Hallway Corner 1st (11,4)

TIL 26
00101010
10010101
10100100
10101010
01010101
01001010
10101010
00100101
NAME Hallway Corner 1st (12,4)

TIL 27
10101011
01010111
10010111
10101011
01010101
10101111
10101001
01010111
NAME Hallway Corner 1st (13,4)

TIL 28
11111111
11111111
11111111
11111111
11111111
01111111
11111111
11111111
NAME Hallway Corner 1st (14,4)

TIL 29
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hallway Corner 1st (15,4)

TIL 30
11011101
11101010
01011101
01101010
10110110
10101011
01010101
10101111
NAME Hallway Corner 1st (10,6)

TIL 31
00010010
10100100
00010001
10000100
01101001
01110101
01011111
01111111
NAME Hallway Corner 1st (11,6)

TIL 32
01010001
00000100
01010000
00000101
01010010
01001011
11111110
11111111
NAME Hallway Corner 1st (12,6)

TIL 33
00010101
01001011
00100101
01001011
00101010
10101011
11010101
11101011
NAME Hallway Corner 1st (13,6)

TIL 34
11010101
11010110
11101010
10101010
11101101
11101010
11010101
11111110
NAME Hallway Corner 1st (14,6)

TIL 35
01010100
10101011
11010100
10101011
01010101
10101010
10101011
11111101
NAME Hallway Corner 1st (15,6)

TIL 36
10010000
01001010
00100000
01010101
00100010
10010000
01001010
00100001
NAME Hallway Corner 1st (0,7)

TIL 37
00111111
10110111
00101101
00101010
10101010
00111111
10101011
00111110
NAME Hallway Corner 1st (1,7)

TIL 38
11111101
11101110
01011010
11101110
10111011
11111110
01101111
11111101
NAME Hallway Corner 1st (2,7)

TIL 39
10101001
10100100
10101001
10100100
01010010
10101001
01001010
10100100
NAME Hallway Corner 1st (3,7)

TIL 40
01111111
11111101
11111111
01111111
11111111
11111111
11110111
10111111
NAME Hallway Corner 1st (14,8)

TIL 41
11111111
11111111
11111111
11111111
11111111
11111111
01110111
11111111
NAME Hallway Corner 1st (15,8)

TIL 42
10010010
01001001
00100100
10010010
01001000
00100101
10010010
01001000
NAME Hallway Corner 1st (0,9)

TIL 43
00111111
01011010
00110111
10111101
00101011
00111110
10101011
00101010
NAME Hallway Corner 1st (1,9)

TIL 44
11111111
11101101
11111111
01101010
11111111
11010101
01111110
11101010
NAME Hallway Corner 1st (2,9)

TIL 45
01010010
01001001
10101010
10100100
01010010
01001001
10100100
10101010
NAME Hallway Corner 1st (3,9)

TIL 46
01010100
00001010
10100101
01010001
10010101
01001001
00100100
10101010
NAME Hallway Corner 1st (4,9)

TIL 47
10101010
01001010
00101010
01010101
00101010
01001010
10100101
01010101
NAME Hallway Corner 1st (5,9)

TIL 48
10101010
01001001
10100101
01010100
10010010
01001010
01010101
01001000
NAME Hallway Corner 1st (6,9)

TIL 49
01001001
01010101
00101010
10100100
10101010
01010100
01001010
10101001
NAME Hallway Corner 1st (7,9)

TIL 50
11111110
11111111
11111111
11111111
11111111
01010111
11111101
01010110
NAME Hallway Corner 1st (2,11)

TIL 51
10100001
10101100
01010010
10101001
01010100
01010010
10101001
11101100
NAME Hallway Corner 1st (3,11)

TIL 52
00101001
10010100
10100010
00010100
10101010
10010010
01001001
10100101
NAME Hallway Corner 1st (4,11)

TIL 53
00010100
10101010
10100101
10010101
01010100
10010101
01001010
00101001
NAME Hallway Corner 1st (5,11)

TIL 54
10010010
01010101
01001001
00100101
10101010
01010101
01010111
01011101
NAME Hallway Corner 1st (6,11)

TIL 55
01010101
01010110
01011011
01011101
11110101
11010100
01010100
01010001
NAME Hallway Corner 1st (7,11)

TIL 56
11011010
10100001
01010000
01000100
00000001
01010000
00000100
00100000
NAME Hallway Corner 1st (8,11)

TIL 57
00100100
00000010
10010000
01001010
00000001
00101000
10000101
00100010
NAME Hallway Corner 1st (9,11)

TIL 58
00010100
10000010
01010001
00001000
01000101
00100100
00010001
01001000
NAME Hallway Corner 1st (10,11)

TIL 59
10100101
00010010
01001001
00100100
01001001
10010010
00100001
01001010
NAME Hallway Corner 1st (11,11)

TIL 60
00010010
00000000
00100100
10000000
01010010
10000000
01010100
10000000
NAME Hallway Corner 1st (6,13)

TIL 61
00000001
00100100
10000000
00001001
01000000
00010010
10000000
00100100
NAME Hallway Corner 1st (7,13)

TIL 62
00010100
00000010
01001000
00000100
00100000
00001010
10100000
00001001
NAME Hallway Corner 1st (8,13)

TIL 63
01000101
10010000
00100100
10001010
00100000
10000101
00100000
00010100
NAME Hallway Corner 1st (9,13)

TIL 64
00010100
10000010
01010001
10001010
01010100
00000010
10101000
00000010
NAME Hallway Corner 1st (10,13)

TIL 65
01000010
00101001
01000100
00010001
10000100
01010001
10001010
00100001
NAME Hallway Corner 1st (11,13)

TIL 66
00001010
01010001
00000100
01010001
00001000
01000100
00100010
01001001
NAME Hallway Corner 1st (12,13)

TIL 67
01010010
00100100
01001010
00100001
10010100
01001010
00100001
01010100
NAME Hallway Corner 1st (13,13)

TIL 68
01001000
10100101
01010010
00101001
10001010
10100100
00101010
10010001
NAME Hallway Corner 1st (14,13)

TIL 69
10101011
01001000
00100101
01010101
10010010
10101001
01001010
00100101
NAME Hallway Corner 1st (15,13)

TIL 70
00000000
01010101
00000000
01010101
00000000
01010101
10001000
11111111
NAME Hallway Corner 1st (10,15)

TIL 71
00010000
01001010
00000001
01010100
00000010
01010001
10001010
11111111
NAME Hallway Corner 1st (11,15)

TIL 72
00000010
10101000
00000010
01010100
00100010
00010000
10101011
11111111
NAME Hallway Corner 1st (12,15)

TIL 73
00100100
10010010
01001001
00100100
10101001
00100100
01010101
11111111
NAME Hallway Corner 1st (13,15)

TIL 74
10010010
01001001
00100100
10010010
00101001
10000100
01101010
11111111
NAME Hallway Corner 1st (14,15)

TIL 75
10010010
00100101
10010010
01001001
00100100
10010010
10101010
11111111
NAME Hallway Corner 1st (15,15)

TIL 76
11111111
11111011
11010110
11111011
11111101
11111110
11111111
11111111
NAME Hallway Corner 2nd  (0,0)

TIL 77
11111111
10111101
11010110
01101011
10110101
11011110
01101010
11010110
NAME Hallway Corner 2nd  (1,0)

TIL 78
11111111
11101111
10110101
01011010
10101111
11110101
10101010
11011101
NAME Hallway Corner 2nd  (2,0)

TIL 79
11111111
11111111
11111111
11111111
01111111
10101111
10111111
11010111
NAME Hallway Corner 2nd  (3,0)

TIL 80
10101010
10110101
10101011
11010101
01011010
01010101
01010110
01011010
NAME Hallway Corner 2nd  (14,1)

TIL 81
10101011
01010101
01101101
01010101
10101010
10110110
10101011
10101100
NAME Hallway Corner 2nd  (15,1)

TIL 82
11010110
11111011
11101101
11111111
11111111
11111111
11111111
11111111
NAME Hallway Corner 2nd  (0,2)

TIL 83
11101111
01011011
11101110
01011011
10111101
11111111
11111111
11111111
NAME Hallway Corner 2nd  (1,2)

TIL 84
11111111
11111111
11111111
11111111
01011111
11111111
01010111
11111101
NAME Hallway Corner 2nd  (2,2)

TIL 85
10110101
01101111
11110101
11111110
11111011
11111111
11111111
11111111
NAME Hallway Corner 2nd  (3,2)

TIL 86
01011011
10110110
01111011
11011110
11101011
01111111
11011101
11111111
NAME Hallway Corner 2nd  (4,2)

TIL 87
11111110
11111111
11111111
10111111
11111111
01111111
11111111
11010111
NAME Hallway Corner 2nd  (5,2)

TIL 88
11101111
11111011
10111111
11110111
11111110
11111011
11111110
11101011
NAME Hallway Corner 2nd  (6,2)

TIL 89
11101011
01111111
11111111
10110110
11111101
10101111
11110101
10101110
NAME Hallway Corner 2nd  (7,2)

TIL 90
01101101
10110111
11111111
11111111
11111111
11111111
01101010
11011101
NAME Hallway Corner 2nd  (5,4)

TIL 91
10111111
11110101
11111011
11111101
11110110
10111011
11010101
01101101
NAME Hallway Corner 2nd  (6,4)

TIL 92
01011010
01101111
10110010
01011101
11010101
01101011
01011101
10101010
NAME Hallway Corner 2nd  (7,4)

TIL 93
10111111
11111111
10101111
11111111
01011111
11101111
01011110
11110111
NAME Hallway Corner 2nd  (8,4)

TIL 94
11111111
11111111
11111111
11111111
11111111
11111111
10111111
11111111
NAME Hallway Corner 2nd  (9,4)

TIL 95
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111101
NAME Hallway Corner 2nd  (10,4)

TIL 96
11111111
11111111
11111111
11111111
11111111
11111111
01111110
11111111
NAME Hallway Corner 2nd  (11,4)

TIL 97
11101101
11111010
11101110
10110101
01111011
11010101
11111110
10101010
NAME Hallway Corner 2nd  (12,4)

TIL 98
10101010
10101101
11010101
01010101
01101101
10101010
10101010
11010101
NAME Hallway Corner 2nd  (13,4)

TIL 99
11011010
01010101
01010110
10101010
01010101
10110110
10101010
01010101
NAME Hallway Corner 2nd  (14,4)

TIL 100
01111111
10111111
01111111
00101111
00001111
11000111
00000011
00010000
NAME Hand Radio (0,15)

TIL 101
11111100
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (1,15)

TIL 102
10111011
11101111
11110111
11111011
11111111
11111111
11111111
11111111
NAME Hand Radio (2,15)

TIL 103
10111111
11111111
11111111
11111111
11101111
01111001
10111111
11010110
NAME Hand Radio (3,15)

TIL 104
11111111
11111111
11111111
11111111
11111111
11111111
11111110
10111101
NAME Hand Radio (4,15)

TIL 105
11111111
11111111
11111111
11111111
11111111
00111101
00111110
01000110
NAME Hand Radio (5,15)

TIL 106
11111111
11111111
11111111
11111111
10001100
10100010
00000000
10001000
NAME Hand Radio (6,15)

TIL 107
11111111
11111111
11111111
11101100
10011000
00000000
00000000
10100000
NAME Hand Radio (7,15)

TIL 108
11111111
11111111
11011111
11011000
00000000
00000000
00000000
00000010
NAME Hand Radio (8,15)

TIL 109
11111111
11111111
10111000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (9,15)

TIL 110
11111111
11111111
11111111
11111111
10110110
11111111
11111111
11111111
NAME Hand Radio (10,1)

TIL 111
11111111
11111111
11111111
11111111
11011011
11111111
11111111
11111111
NAME Hand Radio (11,1)

TIL 112
11111110
11111110
11111100
11111110
01101110
11111100
11111110
11111110
NAME Hand Radio (12,1)

TIL 113
11111111
11111111
11101101
10111111
11110110
11011111
11111011
10111111
NAME Hand Radio (0,0)

TIL 114
10001001
10000100
10001000
10000010
10001001
10000100
10001000
10100000
NAME Hand Radio (0,2)

TIL 115
01001000
00100010
10001000
00001000
00101010
00100000
10000000
10010101
NAME Hand Radio (1,2)

TIL 116
01111101
01111111
11111111
01110111
01111111
11111111
01111011
01111111
NAME Hand Radio (2,2)

TIL 117
11111111
11011011
11111111
01111111
11111111
11110111
11111111
10111111
NAME Hand Radio (3,2)

TIL 118
11110111
01111111
11111110
11111011
11011111
01111111
11111111
11111111
NAME Hand Radio (4,2)

TIL 119
11000010
11000100
11001000
11000011
11000001
11001000
11000010
10010100
NAME Hand Radio (5,2)

TIL 120
00001000
00010010
10100001
00010100
00000001
10100001
00010100
00000101
NAME Hand Radio (6,4)

TIL 121
10000000
00000000
01000000
01000000
00000000
00000000
01000000
00000000
NAME Hand Radio (7,4)

TIL 122
00110111
01111111
00111111
01111110
00111011
00111111
00111111
00011111
NAME Hand Radio (8,4)

TIL 123
11111111
11110111
10111111
11111111
11111111
11111110
11111111
11111111
NAME Hand Radio (9,4)

TIL 124
11111111
10111110
11111011
11111111
11101111
11111111
11111111
11111111
NAME Hand Radio (10,4)

TIL 125
10111111
11111111
11111111
11111111
11111111
11111011
11101111
01111111
NAME Hand Radio (11,4)

TIL 126
11011110
11111110
11111110
01111110
11111110
11110110
11111110
11011110
NAME Hand Radio (12,4)

TIL 127
10000100
10001000
10100010
10001000
10000010
10001000
10000000
10001011
NAME Hand Radio (0,5)

TIL 128
00101001
10000100
10100000
10001010
00100001
00100100
00000010
00100000
NAME Hand Radio (1,5)

TIL 129
00000001
00010100
00100000
01010101
00000000
00010100
10010001
01000100
NAME Hand Radio (2,5)

TIL 130
00000000
00111111
00111111
00111111
00111101
00111111
00111111
00111111
NAME Hand Radio (3,7)

TIL 131
00000000
11111111
11111111
01111011
11111111
11111111
11101111
10111110
NAME Hand Radio (4,7)

TIL 132
00011011
11111111
11111111
11111111
10111011
11111111
11111111
11101111
NAME Hand Radio (5,7)

TIL 133
00100010
10000000
10000100
00010101
10000000
10010010
10000100
10010010
NAME Hand Radio (6,7)

TIL 134
10001000
01010010
01000001
00001000
00010010
10001001
10000000
00101101
NAME Hand Radio (7,7)

TIL 135
01000101
00101000
01000000
00001001
01100000
00001010
00010110
01001000
NAME Hand Radio (8,7)

TIL 136
00000010
10100100
00010000
00000010
10100000
10101010
01001010
01001001
NAME Hand Radio (9,7)

TIL 137
10100000
10000000
00010000
10000000
10100000
10100000
00100000
01000000
NAME Hand Radio (10,7)

TIL 138
00001111
00001111
00001111
00000111
00001111
00001111
00001101
00001111
NAME Hand Radio (13,7)

TIL 139
11101110
11111111
01111111
11111111
11111011
10111111
11111111
11111111
NAME Hand Radio (14,7)

TIL 140
00010000
01000000
00000010
00010000
01000101
00000000
10000010
00010100
NAME Hand Radio (6,10)

TIL 141
00000101
01000000
00000000
01001001
01000000
00001001
00100101
10010100
NAME Hand Radio (7,10)

TIL 142
01000100
00010010
00000000
01010001
01000101
00010000
00000010
01011010
NAME Hand Radio (8,10)

TIL 143
10100000
00000100
10010100
01010001
00000010
01001010
00100000
00000100
NAME Hand Radio (9,10)

TIL 144
00010000
01000100
00100100
00010000
10010001
01000010
00001010
00000000
NAME Hand Radio (10,10)

TIL 145
10100000
00010001
10000100
01010010
00010000
10000100
00010011
01001011
NAME Hand Radio (11,10)

TIL 146
01010010
00000010
00001001
10101001
10000000
10010010
11111010
11110001
NAME Hand Radio (12,10)

TIL 147
01111111
00011101
00011111
00001111
01011111
00111111
01011111
00001101
NAME Hand Radio (13,10)

TIL 148
11111111
11011110
11111111
11111111
01110111
11111111
11111111
11011111
NAME Hand Radio (14,10)

TIL 149
11111110
11111010
11111110
11111110
11111110
11011110
11111110
11111110
NAME Hand Radio (15,10)

TIL 150
11110100
11110000
11111000
11110010
10110000
11100000
11100000
11100000
NAME Hand Radio (12,13)

TIL 151
10000000
10010100
01010010
00001000
01000000
00000000
00000000
00000000
NAME Hand Radio (13,13)

TIL 152
10010000
00000010
10001000
10010001
00000000
00000000
00000000
00000000
NAME Hand Radio (14,13)

TIL 153
10000100
00100100
10000010
00101000
00000000
00000000
00000000
00000000
NAME Hand Radio (15,13)

TIL 154
00000011
00000011
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (11,14)

TIL 155
11100000
11100000
00100000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (12,14)

TIL 156
11111111
11111111
11011101
01110111
11111111
11011011
01111110
11101111
NAME Hand Radio (1,0)

TIL 157
11111111
11111111
11011101
01111111
11110111
10111101
11110111
11011110
NAME Hand Radio (2,0)

TIL 158
11111111
11111111
11011101
01110111
11111111
10110101
11111111
11011101
NAME Hand Radio (3,0)

TIL 159
11111111
11111111
11011101
01110111
11111111
10110101
11011111
11111011
NAME Hand Radio (4,0)

TIL 160
01111101
11101111
11111111
11011011
11111110
10111011
11101111
10111110
NAME Hand Radio (15,1)

TIL 161
10101011
11111110
10110111
11111010
10101111
11111101
10110111
11101101
NAME Hand Radio (0,2)

TIL 162
11101101
11111111
10101101
11111111
11011011
10111110
01110111
11111101
NAME Hand Radio (1,2)

TIL 163
11111111
01101011
11111110
10110111
11111101
10110111
11111110
10101011
NAME Hand Radio (2,2)

TIL 164
11011111
01110110
11111111
11010101
10111111
11110110
11011111
11110101
NAME Hand Radio (3,2)

TIL 165
11111111
10101101
11111011
01101110
11111011
10101110
11111011
01011110
NAME Hand Radio (4,2)

TIL 166
11111101
10110111
11011111
11110101
10111111
11101011
10111111
11110100
NAME Hand Radio (5,2)

TIL 167
11111101
01011011
11111111
01101011
11011110
01110101
10101011
10111111
NAME Hand Radio (6,2)

TIL 168
01111011
11101110
01111011
11011110
11101010
00101111
11111111
11111111
NAME Hand Radio (7,2)

TIL 169
10101010
11111111
10101010
11110111
10011001
11111111
11111111
11111111
NAME Hand Radio (8,2)

TIL 170
11111111
11111111
11111111
11111111
11111111
11111111
01111111
01011111
NAME Hand Radio (4,4)

TIL 171
11111111
11110101
11111111
11101101
11111111
11101101
11010111
11111111
NAME Hand Radio (5,4)

TIL 172
11101011
10110101
01101101
10110110
11011010
01101011
11101101
10111010
NAME Hand Radio (6,4)

TIL 173
01010110
10101010
01101010
10101010
10101010
01010101
10110101
11011011
NAME Hand Radio (7,4)

TIL 174
10101010
10100100
01001001
10000000
01010101
01010100
01010101
01101010
NAME Hand Radio (8,4)

TIL 175
10101001
01000100
00010001
01000100
00010001
10100100
01010101
10101010
NAME Hand Radio (9,4)

TIL 176
00101010
10010010
00101001
01000101
00010101
10101010
01010101
10110110
NAME Hand Radio (10,4)

TIL 177
10101011
10101010
01010110
01010101
01101110
10101011
10110101
11011111
NAME Hand Radio (11,4)

TIL 178
11111110
10101111
11111101
10101111
11111111
01011101
11111010
01111111
NAME Hand Radio (12,4)

TIL 179
11111111
11111111
11111110
11111110
11111101
11111111
11110101
11101110
NAME Hand Radio (14,4)

TIL 180
11111110
01111101
11111111
11111101
01111110
11111110
11111110
11111110
NAME Hand Radio (9,6)

TIL 181
01010101
01011011
01101101
10110110
11010101
10110110
11011011
10101010
NAME Hand Radio (10,6)

TIL 182
01110101
10101110
01110101
10101110
11011011
10101101
01101010
10110110
NAME Hand Radio (11,6)

TIL 183
10101101
11110110
10101011
10111101
01100110
10111010
11010110
10101011
NAME Hand Radio (12,6)

TIL 184
01101011
11010101
01101110
10110101
10101101
11010110
10110101
01010110
NAME Hand Radio (13,6)

TIL 185
01011011
11101101
10110110
01011011
10101010
11011101
01101011
10101010
NAME Hand Radio (14,6)

TIL 186
01110110
10101011
11011101
01101010
10110111
01011001
10101101
10110110
NAME Hand Radio (15,6)

TIL 187
10101010
01010101
10101010
10101010
01010100
10101000
01010010
10100100
NAME Hand Radio (0,7)

TIL 188
01010000
01010100
10000000
01000000
10000000
00000000
00000000
00000000
NAME Hand Radio (1,7)

TIL 189
00101010
00000001
00000100
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (2,7)

TIL 190
01010101
10110110
11010101
00101010
01010101
01010101
01010101
01010101
NAME Hand Radio (14,8)

TIL 191
01010101
10101010
01101011
10101010
01010101
01010101
01010101
01010101
NAME Hand Radio (15,8)

TIL 192
10001000
01010000
10101010
01001000
10100100
01010001
10010100
01000010
NAME Hand Radio (0,9)

TIL 193
00000000
00000000
00000000
00000000
00000000
00000000
10100000
00000000
NAME Hand Radio (1,9)

TIL 194
00000000
00000000
00000000
00000000
00000000
00000000
00000010
00000101
NAME Hand Radio (3,9)

TIL 195
00010010
00001010
00001010
00101001
00110101
10110101
10101010
01010100
NAME Hand Radio (4,9)

TIL 196
10101010
10010101
01010101
01010101
01010100
00101010
10100101
10010100
NAME Hand Radio (5,9)

TIL 197
10101010
01010101
01010101
00101010
10100101
10101010
01010100
10101010
NAME Hand Radio (6,9)

TIL 198
10101010
01001010
01010101
10101010
01010100
10101010
10010101
10101001
NAME Hand Radio (7,9)

TIL 199
10101010
10101101
01010101
10101010
10101101
10101010
01010101
01010101
NAME Hand Radio (8,9)

TIL 200
10101111
01110110
10101111
11101111
11110110
11011111
11101111
11110111
NAME line (9,10)

TIL 201
11011010
11010101
01101110
10110101
11011011
01010111
11011111
01101111
NAME line (10,10)

TIL 202
11101111
11101011
01110110
11101010
11110111
11101010
01101111
01111111
NAME line (11,10)

TIL 203
10101111
11011111
10111111
11111101
01011011
10101101
11111101
11111111
NAME line (12,10)

TIL 204
11010111
10111011
11010111
10101111
10110111
11011011
01101111
11111111
NAME line (13,10)

TIL 205
11011110
11111101
10111111
11011101
11011110
11111101
10111111
11011101
NAME line (14,10)

TIL 206
11011111
01111111
01011111
10111111
10111111
01111111
10111111
01011111
NAME line (15,10)

TIL 207
11110110
11010101
11111011
11101101
11101010
11110111
11011011
11111101
NAME line (0,11)

TIL 208
11011011
01101111
01010110
10110111
11011011
01101111
10101011
01101110
NAME line (1,11)

TIL 209
01111111
10101111
11011111
01111111
11111110
01111111
11011111
11011111
NAME line (2,11)

TIL 210
11010111
10101011
10110111
11011011
10101111
10101011
11011111
10101011
NAME line (13,12)

TIL 211
11111101
10101110
11011101
11101111
10111100
11011111
11111101
10111110
NAME line (14,12)

TIL 212
10111111
11011111
01111111
10111111
10111111
01011111
10111111
11011111
NAME line (15,12)

TIL 213
11110110
11101101
11110110
11101101
11110111
11011010
11101111
11110101
NAME line (0,13)

TIL 214
11011011
10110111
11101101
11010111
01111010
10101101
11010111
01111011
NAME line (1,13)

TIL 215
11010101
11111110
10101011
11101101
11011011
11101110
11011011
10110110
NAME line (2,13)

TIL 216
10111101
11011110
01111011
10111101
11110110
10111011
10111101
11010111
NAME line (3,13)

TIL 217
01101111
11101011
11101111
10110101
11101111
11101011
01110111
11101101
NAME line (4,13)

TIL 218
11101111
11111111
11101111
11111111
11101111
11111111
11110111
11111111
NAME line (5,13)

TIL 219
01111011
01011101
11111011
01111101
10110110
01111101
10111011
01111110
NAME line (6,13)

TIL 220
11110111
10101111
01111111
10101011
11111111
01010111
11101111
10111011
NAME line (1,15)

TIL 221
11110111
11011110
11101011
10111111
11101111
11011111
10110101
11011111
NAME line (2,15)

TIL 222
11111110
10111111
11110110
10111101
01111011
10111101
11011110
01111111
NAME line (3,15)

TIL 223
11110101
01011011
11101101
10110110
01101101
10110110
11111011
01101111
NAME line (4,15)

TIL 224
11011101
01101110
10110101
11011110
10110101
11011110
01101101
11111111
NAME line (5,15)

TIL 225
11011101
10110110
11110111
10111010
11101101
11110111
11011010
11111111
NAME line (6,15)

TIL 226
11011111
10110101
01101110
11011011
10110101
01101110
11111111
11111111
NAME line (7,15)

TIL 227
01101101
10110110
11011011
01101101
10110110
11011011
11111111
11111111
NAME line (8,15)

TIL 228
11011011
10101101
11110110
01011011
11010101
01111110
11111011
11111111
NAME line (9,15)

TIL 229
01101010
10110111
11111111
01011101
11110110
10101101
11111111
11111111
NAME line (10,15)

TIL a
11111111
10000001
10000001
10011001
10011001
10000001
10000001
11111111
NAME block

TIL b
11111111
11111111
00010001
10101010
01010100
10010000
01001000
10100101
NAME Hallway Corner 1st (9,0)

TIL c
11111111
11111111
00010010
10101001
10101010
00010101
01001001
00100100
NAME Hallway Corner 1st (10,0)

TIL d
11111111
11111111
01001001
01010101
10101010
01010101
00001000
10100101
NAME Hallway Corner 1st (11,0)

TIL e
11111111
11111111
00101010
01010101
10101010
01010101
10010101
01010101
NAME Hallway Corner 1st (12,0)

TIL f
11111111
11111111
10010010
01010101
10101010
01010010
00101001
01000101
NAME Hallway Corner 1st (13,0)

TIL g
11111111
11111111
11011101
01010110
10101011
11011101
01010101
10111010
NAME Hallway Corner 1st (14,0)

TIL h
11111111
11111111
01010111
11011011
01101011
01010111
01011111
10100111
NAME Hallway Corner 1st (15,0)

TIL i
01010101
10100100
01010010
10101010
01010010
10101001
01001010
10101001
NAME Hallway Corner 1st (0,1)

TIL j
00001010
10100001
00010100
11000010
00101000
01001010
10100000
00010101
NAME Hallway Corner 1st (1,1)

TIL k
00000100
01010010
00001000
10100010
00001000
10100010
00001000
01000010
NAME Hallway Corner 1st (2,1)

TIL l
10000000
00100000
10001000
00000010
10100000
00010100
10000000
00101010
NAME Hallway Corner 1st (3,1)

TIL m
00000101
00000000
00000010
00000000
00000000
10000000
00100000
10000001
NAME Hallway Corner 1st (4,1)

TIL n
00100100
10010010
01001001
00101010
10010010
01010111
01111110
01010111
NAME Hallway Corner 1st (5,1)

TIL o
10101010
01000101
00101000
10100101
10010101
10101010
11101001
11101101
NAME Hallway Corner 1st (6,1)

TIL p
01001010
00101001
10010100
01001010
00100100
10101010
01010010
00101001
NAME Hallway Corner 1st (7,1)

TIL q
01001001
00100100
10101010
10010010
10101001
01000100
10101010
00101001
NAME Hallway Corner 1st (8,1)

TIL r
00101000
10010101
01001001
10100100
00101010
10010010
10101001
00010101
NAME Hallway Corner 1st (9,1)

TIL s
10010101
01010010
00101001
10001010
10101001
01010100
00100010
01010101
NAME Hallway Corner 1st (10,1)

TIL t
01010101
01001000
00101010
10100101
00101000
10010101
10100101
00101001
NAME Hallway Corner 1st (11,1)

TIL u
00101010
10010100
10101010
00100101
10010101
01010100
00101010
01001010
NAME Hallway Corner 1st (12,1)

TIL v
10101010
10010010
01010101
01001001
00100101
10101010
10010001
01001010
NAME Hallway Corner 1st (13,1)

TIL w
10010101
11011011
01010101
01110101
01011010
10101010
01101010
10110101
NAME Hallway Corner 1st (14,1)

TIL x
01011101
01011111
01010110
01011111
10111101
10111111
11011011
01111111
NAME Hallway Corner 1st (15,1)

TIL y
01010100
10100101
01010100
10100101
01010100
10101010
01010010
10101001
NAME Hallway Corner 1st (0,2)

TIL z
10101010
01000100
10010010
00101001
10100100
01010010
10001001
01010100
NAME Hallway Corner 1st (1,2)

TIL 1a
01010101
00101010
01001001
10101010
10010101
01010100
01001010
01010101
NAME Hallway Corner 1st (12,2)

TIL 1b
01010101
01001010
00100010
10101011
01001010
10100101
01010101
00100101
NAME Hallway Corner 1st (13,2)

TIL 1c
01010101
11010101
01101010
01010101
11011010
01101011
10101010
01010111
NAME Hallway Corner 1st (14,2)

TIL 1d
01101111
01111111
11101111
11111111
10111111
11111111
11011111
11111111
NAME Hallway Corner 1st (15,2)

TIL 1e
01010101
10101010
01001001
01010100
01000101
00010010
00000000
00000001
NAME Hallway Corner 1st (0,3)

TIL 1f
00100010
10010101
01010100
10100010
00101010
10010101
01001010
00100111
NAME Hallway Corner 1st (1,3)

TIL 1g
01001010
00101001
10100101
10010010
10101010
01010111
10111101
11101111
NAME Hallway Corner 1st (2,3)

TIL 1h
01010000
01010101
00100010
10011101
11101111
01111010
11011111
01110101
NAME Hallway Corner 1st (3,3)

TIL 1i
01000001
00101010
11101000
10111110
11010110
11111011
01011110
11101011
NAME Hallway Corner 1st (4,3)

TIL 1j
01011110
11110101
01011111
11110101
10111111
11010101
11111111
10101010
NAME Hallway Corner 1st (5,3)

TIL 1k
11111110
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hallway Corner 1st (6,3)

TIL 1l
11111010
11111101
11111110
11111111
11111111
11111111
11111011
11111111
NAME Hallway Corner 1st (7,3)

TIL 1m
10100101
01010100
10101010
01010101
10101010
11010100
11101010
11110101
NAME Hallway Corner 1st (8,3)

TIL 1n
01010010
10001001
01010101
01001000
10100101
10010101
01010010
01001001
NAME Hallway Corner 1st (9,3)

TIL 1o
01010100
01001010
00100100
10101010
01001001
00101010
10100100
00101010
NAME Hallway Corner 1st (10,3)

TIL 1p
10010101
10101001
01010100
00001010
01010010
10101010
10010010
01010101
NAME Hallway Corner 1st (11,3)

TIL 1q
00101010
01001010
10100100
01010101
10010101
01010100
10100101
01010101
NAME Hallway Corner 1st (12,3)

TIL 1r
10010101
10101010
10010101
01001011
00101010
10101011
01001010
00101011
NAME Hallway Corner 1st (13,3)

TIL 1s
10101011
11010111
01011010
01010111
11011110
01010111
11111111
11111111
NAME Hallway Corner 1st (14,3)

TIL 1t
01111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hallway Corner 1st (15,3)

TIL 1u
01001000
00000000
01000100
10100001
11011010
10110111
11011010
01101111
NAME Hallway Corner 1st (0,4)

TIL 1v
00111010
10101011
00010101
01011011
10101101
11010110
10111010
01001011
NAME Hallway Corner 1st (1,4)

TIL 1w
10111011
11101101
01110111
10101101
01010110
11101010
10101011
01011101
NAME Hallway Corner 1st (2,4)

TIL 1x
10111111
11101011
01111101
11010101
10101010
11010101
01101010
10101010
NAME Hallway Corner 1st (3,4)

TIL 1y
01111110
10101010
01010101
01010101
10101010
01010101
10101011
10101101
NAME Hallway Corner 1st (4,4)

TIL 1z
11110101
10010101
01011110
01010101
10101110
01010111
01101011
01010110
NAME Hallway Corner 1st (5,4)

TIL 2a
11110100
01010101
10101010
01101010
10101010
01010101
10101010
01010100
NAME Hallway Corner 1st (0,5)

TIL 2b
10110101
01010101
10101010
10101010
10100001
00010100
10100001
01001000
NAME Hallway Corner 1st (1,5)

TIL 2c
10101010
01010101
10101010
10101010
01010101
10000101
00101000
10000101
NAME Hallway Corner 1st (2,5)

TIL 2d
11010101
11010100
10101010
11010101
01101000
10101010
10100100
11010000
NAME Hallway Corner 1st (3,5)

TIL 2e
01010101
10101010
01010101
00101010
10101010
00101010
10010101
01001010
NAME Hallway Corner 1st (4,5)

TIL 2f
01010111
10101011
01010110
10101011
10101101
10101011
01010110
10101011
NAME Hallway Corner 1st (5,5)

TIL 2g
01011010
11101101
10110111
11011010
01101101
10110101
11011010
01101010
NAME Hallway Corner 1st (6,5)

TIL 2h
11101010
01110101
10111110
11010101
01111011
11011011
11101101
10110101
NAME Hallway Corner 1st (7,5)

TIL 2i
11111111
11111110
01101111
10111111
01010101
11101011
01101101
10110111
NAME Hallway Corner 1st (8,5)

TIL 2j
10111101
11110110
11111111
11111111
10110110
11111111
01111011
01011111
NAME Hallway Corner 1st (9,5)

TIL 2k
00101010
10101010
10101001
10101010
11010101
11110100
01011010
11111010
NAME Hallway Corner 1st (10,5)

TIL 2l
10010100
10101010
01010001
10001100
01010010
10010101
01001001
10100100
NAME Hallway Corner 1st (11,5)

TIL 2m
10101010
10101001
01001010
10101010
01001001
00100101
01010100
10001010
NAME Hallway Corner 1st (12,5)

TIL 2n
10101001
01010111
10010101
01010111
01001010
00101011
10101101
01001011
NAME Hallway Corner 1st (13,5)

TIL 2o
11111111
11111111
11010101
11101101
11010101
11101010
11011010
11101010
NAME Hallway Corner 1st (14,5)

TIL 2p
11111111
11101101
01010110
01011001
01010101
10101010
10101010
10101011
NAME Hallway Corner 1st (15,5)

TIL 2q
01010001
10101010
01010000
01001010
01010000
01001010
01010000
00100101
NAME Hallway Corner 1st (0,6)

TIL 2r
00000100
01010001
10001001
01010010
00100100
10010010
01001001
00101110
NAME Hallway Corner 1st (1,6)

TIL 2s
01010000
00100101
01001001
00100100
10010010
01001001
00101010
11111111
NAME Hallway Corner 1st (2,6)

TIL 2t
10101010
01010001
10101010
11010000
10101010
01001000
10100100
01010010
NAME Hallway Corner 1st (3,6)

TIL 2u
00101010
01001001
00100101
10010101
00101010
10000101
01010100
00100101
NAME Hallway Corner 1st (4,6)

TIL 2v
10101101
01010110
01000101
00110110
10001010
01101010
10010101
01001010
NAME Hallway Corner 1st (5,6)

TIL 2w
11110101
10101001
11010101
10110100
11010010
10101001
01010101
11010101
NAME Hallway Corner 1st (6,6)

TIL 2x
11011010
01101001
01110101
10101001
11110100
01010010
01101001
01010101
NAME Hallway Corner 1st (7,6)

TIL 2y
11011010
01101111
10101010
11010111
10101010
11001101
01100110
10101010
NAME Hallway Corner 1st (8,6)

TIL 2z
11010110
01101011
10111101
11010101
01101101
10101010
10101011
11001010
NAME Hallway Corner 1st (9,6)

TIL 3a
01001010
00100100
01010010
10001010
01010101
00100010
01001001
10010101
NAME Hallway Corner 1st (4,7)

TIL 3b
10100101
10010101
10101010
01001010
01010101
01001010
01010101
00100101
NAME Hallway Corner 1st (5,7)

TIL 3c
01101001
10101010
10101010
11010101
01101010
10101001
01010101
10101010
NAME Hallway Corner 1st (6,7)

TIL 3d
01101000
10110101
11010010
01010101
10101001
01010101
01010010
10101001
NAME Hallway Corner 1st (7,7)

TIL 3e
10100101
01010110
11001010
01010101
01010101
01001010
10101010
01010101
NAME Hallway Corner 1st (8,7)

TIL 3f
01010101
10101010
10101010
01011110
01011110
01010110
10101110
01011110
NAME Hallway Corner 1st (9,7)

TIL 3g
01010101
10101010
10101010
10100100
10010010
10101001
10010100
10100010
NAME Hallway Corner 1st (10,7)

TIL 3h
10101111
11011111
10111111
10111111
10101111
00110110
10011111
10101010
NAME Hallway Corner 1st (11,7)

TIL 3i
01111111
11111011
11101111
10111111
11110111
10111011
11011101
11101011
NAME Hallway Corner 1st (12,7)

TIL 3j
10101101
11010011
11010101
11001010
01100101
11001010
01010101
11000101
NAME Hallway Corner 1st (13,7)

TIL 3k
11110111
01111111
11111111
11111111
10111111
11111111
11111111
11111111
NAME Hallway Corner 1st (14,7)

TIL 3l
11111111
11111111
11111111
11111111
11111111
11111111
11110111
10111111
NAME Hallway Corner 1st (15,7)

TIL 3m
10010100
01000010
00101001
01000100
00101010
10010000
01000101
00101000
NAME Hallway Corner 1st (0,8)

TIL 3n
10101111
00111011
01011110
00110111
10111011
10101110
00111111
10110101
NAME Hallway Corner 1st (1,8)

TIL 3o
11110111
11111110
11011111
01110101
11111110
11101111
11111101
01101110
NAME Hallway Corner 1st (2,8)

TIL 3p
01010010
11001001
01010100
10100010
11010101
01001000
10100101
11010100
NAME Hallway Corner 1st (3,8)

TIL 3q
01001010
00100100
10010010
01010101
00100010
10010100
01001010
10100010
NAME Hallway Corner 1st (4,8)

TIL 3r
10010101
10101010
01001010
00101010
10100101
10010101
01010101
10010101
NAME Hallway Corner 1st (5,8)

TIL 3s
01010101
10101001
10101010
10100101
01010100
00101010
01010001
01001010
NAME Hallway Corner 1st (6,8)

TIL 3t
01010100
01010010
10101010
01010001
10010101
01010101
01010010
10101010
NAME Hallway Corner 1st (7,8)

TIL 3u
10101010
10010001
01001010
01010101
01010010
00100101
10010010
01010101
NAME Hallway Corner 1st (8,8)

TIL 3v
00101110
01011110
10101111
11011110
11011110
01011110
11011110
01011101
NAME Hallway Corner 1st (9,8)

TIL 3w
10010100
01001001
01010010
01001000
10100101
01010000
10001010
01010010
NAME Hallway Corner 1st (10,8)

TIL 3x
10111111
00010110
10111111
10011010
01011111
01011010
10111111
01010101
NAME Hallway Corner 1st (11,8)

TIL 3y
10111111
11101011
10111110
11101011
11111110
10101011
11111110
01101111
NAME Hallway Corner 1st (12,8)

TIL 3z
01010101
11000101
10101011
10100101
11001011
10100101
11001010
10100101
NAME Hallway Corner 1st (13,8)

TIL 4a
01001010
01010010
10010101
10100101
10010010
10101010
10010010
01001001
NAME Hallway Corner 1st (8,9)

TIL 4b
11011110
11011101
01011110
11010110
10101110
10111110
10011111
01001101
NAME Hallway Corner 1st (9,9)

TIL 4c
00100101
10010101
01000000
10101010
10110100
10101000
11010010
01000000
NAME Hallway Corner 1st (10,9)

TIL 4d
01010101
01001010
00100001
10010100
00000010
10101001
00001010
10100001
NAME Hallway Corner 1st (11,9)

TIL 4e
10110101
01001000
00100101
10000000
00101010
01000100
00101010
01010001
NAME Hallway Corner 1st (12,9)

TIL 4f
11001011
00100101
01001011
01010001
10010101
01010101
10101011
00101001
NAME Hallway Corner 1st (13,9)

TIL 4g
11111111
01111111
11111111
01111111
11111111
01111111
11111111
01111011
NAME Hallway Corner 1st (14,9)

TIL 4h
11111111
11111111
11111111
11110111
10111111
11111111
11111111
11111111
NAME Hallway Corner 1st (15,9)

TIL 4i
00100101
10101001
00100100
01010010
00100100
10101001
00100100
10010010
NAME Hallway Corner 1st (0,10)

TIL 4j
00111011
00101101
10110110
00111011
10101111
00111010
10111111
10111010
NAME Hallway Corner 1st (1,10)

TIL 4k
01110101
11010110
11011010
01101010
11111101
10100110
11011011
11101101
NAME Hallway Corner 1st (2,10)

TIL 4l
01010001
10010100
10100101
10101000
01010101
10100010
01010100
10101010
NAME Hallway Corner 1st (3,10)

TIL 4m
01001001
10100101
00010100
10100101
00101001
10010100
01000010
10101010
NAME Hallway Corner 1st (4,10)

TIL 4n
00101010
01001010
10101010
00100101
01010100
10001010
01010101
10100101
NAME Hallway Corner 1st (5,10)

TIL 4o
10100101
01010101
10010010
01001001
10101010
01001001
00100100
01010101
NAME Hallway Corner 1st (6,10)

TIL 4p
00100101
01010100
01001010
00100100
10101010
01010001
10010101
01001010
NAME Hallway Corner 1st (7,10)

TIL 4q
00101010
10100101
10010010
10101011
01010101
01011110
01101010
10110101
NAME Hallway Corner 1st (8,10)

TIL 4r
00110110
10111010
01010101
11101000
00100101
10101000
10000010
01010000
NAME Hallway Corner 1st (9,10)

TIL 4s
10101010
10000000
00010010
01000001
00001010
00100000
00001010
10100001
NAME Hallway Corner 1st (10,10)

TIL 4t
00010101
10100100
00010010
01001001
00100101
10010100
00100010
00010100
NAME Hallway Corner 1st (11,10)

TIL 4u
00100101
10010100
01001010
01010001
00101010
10010010
10101001
10001010
NAME Hallway Corner 1st (12,10)

TIL 4v
00101101
10101010
10011101
01010101
01010110
10011011
01001110
01010111
NAME Hallway Corner 1st (13,10)

TIL 4w
10111111
11111111
01111111
11111110
10111111
11111111
10111111
11111111
NAME Hallway Corner 1st (14,10)

TIL 4x
11111111
11111111
10111111
11111011
11111111
11111111
11111011
11111111
NAME Hallway Corner 1st (15,10)

TIL 4y
01010100
10100101
11111010
10101111
10110101
01010110
00101010
10000001
NAME Hallway Corner 1st (0,11)

TIL 4z
01011111
01111111
10111111
01011111
10111111
11111011
10101101
01011011
NAME Hallway Corner 1st (1,11)

TIL 5a
01010010
00101001
01000100
00101010
01000001
00010100
01001010
00100001
NAME Hallway Corner 1st (12,11)

TIL 5b
10011011
01001010
10100001
01001101
00100010
10010101
01010010
01001001
NAME Hallway Corner 1st (13,11)

TIL 5c
11111111
01011111
01010101
01010101
01001010
01010101
10101010
01010101
NAME Hallway Corner 1st (14,11)

TIL 5d
11111011
11111111
01111111
10101010
01010101
01010110
10101010
01010101
NAME Hallway Corner 1st (15,11)

TIL 5e
01010100
00100010
10001000
01010010
01001000
00100101
10010000
01001010
NAME Hallway Corner 1st (0,12)

TIL 5f
01001011
10010100
00100010
10010100
01000010
00101000
10000101
01010000
NAME Hallway Corner 1st (1,12)

TIL 5g
11011011
01101101
10010110
01001001
10100010
00010100
01000000
00010101
NAME Hallway Corner 1st (2,12)

TIL 5h
11110111
01011111
11101010
00101101
01001010
10010001
00100100
00000001
NAME Hallway Corner 1st (3,12)

TIL 5i
01010100
11101010
10111101
11011111
01100101
01011010
00001010
01000101
NAME Hallway Corner 1st (4,12)

TIL 5j
10100101
10010101
01010101
11110111
11011101
10111111
11001001
00110110
NAME Hallway Corner 1st (5,12)

TIL 5k
01010110
11111011
01010101
11101010
01010100
01010000
10100010
10000000
NAME Hallway Corner 1st (6,12)

TIL 5l
10100000
01001001
00000000
00100100
00000000
10100010
00010000
01000100
NAME Hallway Corner 1st (7,12)

TIL 5m
00000101
00100000
00001001
10000000
00100101
00000000
10010100
01000001
NAME Hallway Corner 1st (8,12)

TIL 5n
00001000
01000100
00010001
01001010
00000000
01010100
10000010
00010000
NAME Hallway Corner 1st (9,12)

TIL 5o
10000101
00100000
00010101
01000000
10010101
00100000
10001010
00100001
NAME Hallway Corner 1st (10,12)

TIL 5p
00010000
10001010
00100001
01001010
00010000
10000100
01010010
00001000
NAME Hallway Corner 1st (11,12)

TIL 5q
10010100
01000010
00010000
01001010
10000100
00101001
10000010
01010000
NAME Hallway Corner 1st (12,12)

TIL 5r
00100101
10010100
01001010
10100001
01010100
00001010
01010010
10001001
NAME Hallway Corner 1st (13,12)

TIL 5s
00100101
10101010
10010101
01010010
10101010
01001001
10100101
00101010
NAME Hallway Corner 1st (14,12)

TIL 5t
01010101
10101010
01010101
01001010
10101010
01010101
00100101
10010100
NAME Hallway Corner 1st (15,12)

TIL 5u
01010001
01001000
01000101
01010000
00001010
10100001
01001010
00100000
NAME Hallway Corner 1st (0,13)

TIL 5v
00001010
10100000
00010101
10000000
01010101
00001000
01000010
00101000
NAME Hallway Corner 1st (1,13)

TIL 5w
10000000
01010100
00000010
10101000
00000010
01010000
10001010
00100000
NAME Hallway Corner 1st (2,13)

TIL 5x
01001000
00000010
10100000
00001000
01000010
00010100
10000000
01010010
NAME Hallway Corner 1st (3,13)

TIL 5y
00100000
00010100
10000001
01010000
00000010
10001000
00100001
10000100
NAME Hallway Corner 1st (4,13)

TIL 5z
10001010
00100001
00001000
01000010
00001000
01000010
00001000
00100010
NAME Hallway Corner 1st (5,13)

TIL 6a
10010101
01000000
00101010
10000001
01010100
00001001
10100010
01001000
NAME Hallway Corner 1st (0,14)

TIL 6b
01000101
00010000
10100101
00001000
01000010
00101001
01000101
10010100
NAME Hallway Corner 1st (1,14)

TIL 6c
01001010
00000010
01010100
00101001
10100000
01001010
00010001
01000100
NAME Hallway Corner 1st (2,14)

TIL 6d
10001000
01000001
10010100
00000010
01010000
00001010
01000000
00101010
NAME Hallway Corner 1st (3,14)

TIL 6e
00010000
00000010
01010000
00000100
10100000
00010101
10000000
00101010
NAME Hallway Corner 1st (4,14)

TIL 6f
00000000
10010010
00000000
10101010
00000000
00100100
10000001
00101000
NAME Hallway Corner 1st (5,14)

TIL 6g
00101001
00000000
10100100
00000001
01001000
00000010
01010000
00000100
NAME Hallway Corner 1st (6,14)

TIL 6h
00001001
01000000
00010010
00000000
01001010
00100001
10001000
00100101
NAME Hallway Corner 1st (7,14)

TIL 6i
01000010
00101000
10000010
00101000
00000010
01001000
00100010
00001000
NAME Hallway Corner 1st (8,14)

TIL 6j
01000001
00010100
10000001
01010100
00000001
10101000
00000100
10010001
NAME Hallway Corner 1st (9,14)

TIL 6k
01010001
00001000
01000100
00100010
00010000
10001010
01000000
00101010
NAME Hallway Corner 1st (10,14)

TIL 6l
00001000
10100101
00001000
10100010
00001000
10100010
00001000
10100010
NAME Hallway Corner 1st (11,14)

TIL 6m
00100100
00010010
10001001
01010000
00000100
10101001
00000010
10101000
NAME Hallway Corner 1st (12,14)

TIL 6n
00100010
10101001
00101010
10001010
01010000
00100101
00100100
10010010
NAME Hallway Corner 1st (13,14)

TIL 6o
01001010
00100100
10010010
10101001
01010101
00010010
10100100
01001001
NAME Hallway Corner 1st (14,14)

TIL 6p
10101001
10010100
01000010
00101010
01010101
10101000
01000110
00101001
NAME Hallway Corner 1st (15,14)

TIL 6q
00100100
10010010
01001001
01010101
01001010
01010101
10101001
11111111
NAME Hallway Corner 1st (0,15)

TIL 6r
01010010
10100100
00010010
01001000
00100101
01010010
01010100
11111111
NAME Hallway Corner 1st (1,15)

TIL 6s
10010001
01001010
10010000
01000101
00101000
10010010
10101010
11111111
NAME Hallway Corner 1st (2,15)

TIL 6t
00000000
01010100
10000001
00101000
01000100
10010010
01001001
11111111
NAME Hallway Corner 1st (3,15)

TIL 6u
10000000
00101010
00000000
10101010
00000000
10101010
00100001
11111111
NAME Hallway Corner 1st (4,15)

TIL 6v
10000100
00100010
10010000
00000100
10010001
00000100
01010010
11111111
NAME Hallway Corner 1st (5,15)

TIL 6w
10010001
00000100
10100000
00010101
01000000
00010101
10100100
11111111
NAME Hallway Corner 1st (6,15)

TIL 6x
00010000
01000010
00100100
00000000
10101010
00000000
10110101
11111111
NAME Hallway Corner 1st (7,15)

TIL 6y
01000000
00010101
10000000
00101001
10000010
00101000
01000101
11111111
NAME Hallway Corner 1st (8,15)

TIL 6z
00100100
00000001
01010100
00000001
01010100
00000001
01010100
11111111
NAME Hallway Corner 1st (9,15)

TIL 7a
11111111
11111111
11101001
11110110
11111111
11111010
11111111
11111110
NAME Hallway Corner 2nd  (4,0)

TIL 7b
11111111
11111111
00100100
11111011
01010110
11011011
01101101
11011011
NAME Hallway Corner 2nd  (5,0)

TIL 7c
11111111
11111111
10100101
01011101
11110110
10101011
01111101
10101011
NAME Hallway Corner 2nd  (6,0)

TIL 7d
11111111
11111111
01011111
10110111
11101111
01111011
10101111
11011011
NAME Hallway Corner 2nd  (7,0)

TIL 7e
11111111
11111111
11111101
11111111
11111011
11111111
11111111
11111111
NAME Hallway Corner 2nd  (8,0)

TIL 7f
11111111
11111111
11111111
11111111
11111111
11111111
10000000
00000000
NAME Hallway Corner 2nd  (9,0)

TIL 7g
11111111
11111111
10101010
11111111
10101010
11111111
10101010
01111111
NAME Hallway Corner 2nd  (10,0)

TIL 7h
11111111
11111111
10110110
11101111
10111010
11101111
10111101
11110111
NAME Hallway Corner 2nd  (11,0)

TIL 7i
11111111
11111111
11111111
10111111
11111111
11111111
11111111
10111111
NAME Hallway Corner 2nd  (12,0)

TIL 7j
11111111
11111011
11010101
11101101
10110101
11011011
01101101
10110101
NAME Hallway Corner 2nd  (13,0)

TIL 7k
11111111
01101101
10101010
01010101
01011011
01101010
01010101
01010110
NAME Hallway Corner 2nd  (14,0)

TIL 7l
11111111
10110110
10101011
01010101
01101010
10101101
01010101
11011010
NAME Hallway Corner 2nd  (15,0)

TIL 7m
11111111
11111111
10111111
11011111
01101011
10110110
11011011
01101101
NAME Hallway Corner 2nd  (0,1)

TIL 7n
11111011
11111101
11111110
11111111
11111111
11111111
11111111
01011111
NAME Hallway Corner 2nd  (1,1)

TIL 7o
01101011
10110101
11011110
01101010
10101011
11111101
11110110
11111011
NAME Hallway Corner 2nd  (2,1)

TIL 7p
01101011
10111101
10101010
11011111
01101010
10110101
11011110
01101011
NAME Hallway Corner 2nd  (3,1)

TIL 7q
11111111
11111111
11111111
01111111
10111111
11011111
10101111
11110111
NAME Hallway Corner 2nd  (4,1)

TIL 7r
10110110
11011011
11101101
11111011
11110110
11111111
11111010
11111111
NAME Hallway Corner 2nd  (5,1)

TIL 7s
11011101
01101011
10111101
01101011
11110110
10111101
11010111
10111010
NAME Hallway Corner 2nd  (6,1)

TIL 7t
01110111
10111101
11010110
01111011
11011110
10110111
11101101
10111111
NAME Hallway Corner 2nd  (7,1)

TIL 7u
11111100
11111100
11111100
11111100
11111111
11111111
01111111
11111111
NAME Hallway Corner 2nd  (8,1)

TIL 7v
00000000
00000000
00000001
00000111
11111101
11010111
11111101
10110111
NAME Hallway Corner 2nd  (9,1)

TIL 7w
01101011
11111111
01010101
11111111
01101011
11111111
10101010
11111111
NAME Hallway Corner 2nd  (10,1)

TIL 7x
01011111
11111011
01101110
11111111
01011011
11111111
11011101
11110111
NAME Hallway Corner 2nd  (11,1)

TIL 7y
11111111
11111110
11111111
11111110
11111111
11111110
11111101
11111110
NAME Hallway Corner 2nd  (12,1)

TIL 7z
11010101
10110110
11011010
10101010
11011011
10101101
11010101
10110101
NAME Hallway Corner 2nd  (13,1)

TIL 8a
01111111
11111111
11111111
11111111
11101111
01111111
11111111
11111111
NAME Hallway Corner 2nd  (8,2)

TIL 8b
11111110
11011011
11111111
11101101
11111111
11111101
11111111
11111111
NAME Hallway Corner 2nd  (9,2)

TIL 8c
10110110
11111011
01101111
11111101
10101111
11111111
11111101
11111111
NAME Hallway Corner 2nd  (10,2)

TIL 8d
11011111
11111111
01110111
11111111
11011111
01111111
11111111
11111111
NAME Hallway Corner 2nd  (11,2)

TIL 8e
11111111
11111010
11111111
11111010
11111101
11110111
11111101
11110110
NAME Hallway Corner 2nd  (12,2)

TIL 8f
01010110
11101010
01011010
11010101
01101011
10101101
01010101
11101010
NAME Hallway Corner 2nd  (13,2)

TIL 8g
10101010
11010101
10101010
01011011
01101010
01010101
01010110
10101010
NAME Hallway Corner 2nd  (14,2)

TIL 8h
11010101
01010110
10110101
01010101
10101101
01101010
10101011
11011010
NAME Hallway Corner 2nd  (15,2)

TIL 8i
10111111
11110111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hallway Corner 2nd  (0,3)

TIL 8j
11111111
11111111
11111111
11101011
11000000
11110000
11111111
11110110
NAME Hallway Corner 2nd  (1,3)

TIL 8k
01101111
11111111
11111110
11111011
11111110
11110111
10111010
11101111
NAME Hallway Corner 2nd  (2,3)

TIL 8l
11111111
11111111
11011111
11110111
10111101
11010110
11111011
01010110
NAME Hallway Corner 2nd  (3,3)

TIL 8m
11110110
11101101
11110111
11011101
10110110
11101011
10111101
11010110
NAME Hallway Corner 2nd  (4,3)

TIL 8n
11111101
10101011
01111101
10101011
11101101
01011011
10110110
11011011
NAME Hallway Corner 2nd  (5,3)

TIL 8o
11111101
10101010
11111111
01010101
10110110
01101011
11011101
01101010
NAME Hallway Corner 2nd  (6,3)

TIL 8p
11110101
10101110
01110101
10101110
11011011
01101101
10110110
11010101
NAME Hallway Corner 2nd  (7,3)

TIL 8q
11011111
11111111
10111111
11111111
01101111
11111111
10111111
11101111
NAME Hallway Corner 2nd  (8,3)

TIL 8r
11111011
11111101
11110110
11111011
11110110
11111011
11101101
11111011
NAME Hallway Corner 2nd  (12,3)

TIL 8s
01010110
10101010
10110101
01011011
11010101
01010101
01101010
01011011
NAME Hallway Corner 2nd  (13,3)

TIL 8t
11011010
10101011
01010101
01101010
01010101
01011011
10101010
01010101
NAME Hallway Corner 2nd  (14,3)

TIL 8u
10101011
01010101
01101101
10101010
01010101
01101101
10101010
01010101
NAME Hallway Corner 2nd  (15,3)

TIL 8v
11010101
11111111
11011011
11101110
10111011
11101101
10111111
11101011
NAME Hallway Corner 2nd  (0,4)

TIL 8w
11011111
01110101
10111110
11010101
01111110
11010101
01111111
11011111
NAME Hallway Corner 2nd  (1,4)

TIL 8x
01110101
10101110
11110101
10101110
11110111
10111011
11111111
11111111
NAME Hallway Corner 2nd  (2,4)

TIL 8y
10111011
11010110
10111011
11011101
01101111
11111111
11111111
11111111
NAME Hallway Corner 2nd  (3,4)

TIL 8z
01101011
10111101
11010111
01111111
11111111
11111111
11111111
11011010
NAME Hallway Corner 2nd  (4,4)

TIL 9a
11011010
01010101
10101011
11011101
01010111
10111111
10101101
01110111
NAME Hallway Corner 2nd  (15,4)

TIL 9b
10111111
11111111
11111111
11111111
11011010
11101111
10110101
11011010
NAME Hallway Corner 2nd  (0,5)

TIL 9c
11111111
11111111
11111101
10101110
11110101
01011011
10110110
11011011
NAME Hallway Corner 2nd  (1,5)

TIL 9d
11111111
11111011
10101101
11011010
10110111
01101010
10110110
01011011
NAME Hallway Corner 2nd  (2,5)

TIL 9e
11110101
01011110
10101011
11101100
01010111
10110101
11010101
01011010
NAME Hallway Corner 2nd  (3,5)

TIL 9f
01101101
10110110
11010101
10101101
01101010
01010101
01011011
11010101
NAME Hallway Corner 2nd  (4,5)

TIL 9g
10110111
11010100
01011011
10101101
10110101
01010101
01101010
01010110
NAME Hallway Corner 2nd  (5,5)

TIL 9h
10110110
11010101
01011011
01101010
10101101
01010101
10101010
11011011
NAME Hallway Corner 2nd  (6,5)

TIL 9i
11010110
01101011
01011010
10101010
01101101
10110110
10101010
01010101
NAME Hallway Corner 2nd  (7,5)

TIL 9j
10111101
11011110
10110111
11101101
10111110
11010111
11111010
01011111
NAME Hallway Corner 2nd  (8,5)

TIL 9k
10111111
11101111
10111111
11101111
10111111
11101111
10111111
11111111
NAME Hallway Corner 2nd  (9,5)

TIL 9l
11111111
11111111
11000111
11111111
11111111
11111111
11111111
11111111
NAME Hallway Corner 2nd  (10,5)

TIL 9m
11111110
11111111
01111101
11111111
11111101
11111111
11111110
11111111
NAME Hallway Corner 2nd  (11,5)

TIL 9n
11110110
01011011
11101101
01010101
11111010
01010111
11101101
10110101
NAME Hallway Corner 2nd  (12,5)

TIL 9o
10101101
01010101
01101010
10101101
10101010
01010101
01101111
10101101
NAME Hallway Corner 2nd  (13,5)

TIL 9p
10101101
01010101
10111010
10101101
11110101
01011101
11110101
10111101
NAME Hallway Corner 2nd  (14,5)

TIL 9q
10101101
01011111
10110101
01101110
10110101
01011111
01101010
10111011
NAME Hallway Corner 2nd  (15,5)

TIL 9r
01001010
01010001
00000100
01010001
00001000
01000101
00100001
01001001
NAME Hallway Corner 2nd  (0,6)

TIL 9s
10101101
01110110
10101010
01011011
11101101
01010101
01101101
01010101
NAME Hallway Corner 2nd  (1,6)

TIL 9t
10101010
11011010
10101011
01101010
01010100
01010010
01010101
01001000
NAME Hallway Corner 2nd  (2,6)

TIL 9u
10101011
11010100
00101010
10100001
10010100
01000010
00101001
10000100
NAME Hallway Corner 2nd  (3,6)

TIL 9v
01010101
10101010
01000100
00010010
10100100
00010001
01000100
00110101
NAME Hallway Corner 2nd  (4,6)

TIL 9w
01010101
10101010
10010101
01001001
10100100
00010010
01001001
10101100
NAME Hallway Corner 2nd  (5,6)

TIL 9x
01010101
10101101
01010101
01010101
10010101
01001010
00100100
10010010
NAME Hallway Corner 2nd  (6,6)

TIL 9y
01101101
10101010
01010110
01011011
01010101
10101010
10101010
01010101
NAME Hallway Corner 2nd  (7,6)

TIL 9z
11101011
10111101
11010111
01111101
11010111
10111011
11101110
01110111
NAME Hallway Corner 2nd  (8,6)

TIL a0
01011111
11111111
01011111
11111111
01010101
11111111
10110111
11011111
NAME Hallway Corner 2nd  (9,6)

TIL a1
11111111
11111111
11111111
11011011
01111110
10101011
01111111
11111111
NAME Hallway Corner 2nd  (10,6)

TIL a2
11111110
11111111
11111101
01010111
11111101
10110111
11011101
01110111
NAME Hallway Corner 2nd  (11,6)

TIL a3
11011010
01101101
11010110
01111011
10101101
01110101
11011010
01101101
NAME Hallway Corner 2nd  (12,6)

TIL a4
10101110
01010111
11011010
01011111
01010101
10101110
10110101
01011011
NAME Hallway Corner 2nd  (13,6)

TIL a5
11101010
11111101
10101010
11111101
01110101
11011101
11111010
01111011
NAME Hallway Corner 2nd  (14,6)

TIL a6
10101101
01101111
10110101
01011011
10110110
01101101
10110111
01011101
NAME Hallway Corner 2nd  (15,6)

TIL a7
00000101
01010001
00000010
10101001
00000010
01010010
00000101
01010010
NAME Hallway Corner 2nd  (0,7)

TIL a8
01101010
10101010
10101010
01010100
10101010
10100101
01010100
10101010
NAME Hallway Corner 2nd  (1,7)

TIL a9
10100101
01010010
10001001
10100100
01010010
00100100
10010001
01001010
NAME Hallway Corner 2nd  (2,7)

TIL aa
00101001
01000000
00010101
01000000
10010101
00100000
00001010
01000001
NAME Hallway Corner 2nd  (3,7)

TIL ab
00101110
01010101
00111110
01010101
00111111
01011111
00111111
01011111
NAME Hallway Corner 2nd  (4,7)

TIL ac
11110100
10111010
11010100
11101010
10111001
11101100
11011010
11111001
NAME Hallway Corner 2nd  (5,7)

TIL ad
01001010
10100100
00010010
10101001
00000100
10101010
00100001
01001010
NAME Hallway Corner 2nd  (6,7)

TIL ae
10010010
10101010
01001010
00101001
10100101
01010100
00010010
10101010
NAME Hallway Corner 2nd  (7,7)

TIL af
11011010
11101111
10110101
01111110
10101011
11110110
10101111
11111010
NAME Hallway Corner 2nd  (8,7)

TIL ag
11111111
10101011
11111101
11010111
11111111
10101111
11111111
11010111
NAME Hallway Corner 2nd  (9,7)

TIL ah
01111101
11010111
01111101
11101111
11111010
11111111
11111111
11111111
NAME Hallway Corner 2nd  (10,7)

TIL ai
11011101
01110111
11011101
01110111
00111010
01010111
11111101
11111011
NAME Hallway Corner 2nd  (11,7)

TIL aj
10110110
01101011
10110101
11011010
10101101
11110110
01011010
11101010
NAME Hallway Corner 2nd  (12,7)

TIL ak
11010111
01011101
01010111
10101010
10111111
10101010
10101101
10101011
NAME Hallway Corner 2nd  (13,7)

TIL al
11011101
01110101
11111010
10111101
11101010
10111101
11110101
01111010
NAME Hallway Corner 2nd  (14,7)

TIL am
01101011
01111101
10101011
10110110
10111011
01010110
10111011
10101110
NAME Hallway Corner 2nd  (15,7)

TIL an
00100101
10000101
00100101
01001010
00100101
10001010
00101010
01001010
NAME Hallway Corner 2nd  (0,8)

TIL ao
01001001
01010100
01001010
10101001
01010100
10100101
10101001
10100101
NAME Hallway Corner 2nd  (1,8)

TIL ap
00100001
10010100
10100010
00010100
10100010
00101000
01000101
00101000
NAME Hallway Corner 2nd  (2,8)

TIL aq
00101000
10000101
00100000
10010101
01000000
10010101
00000000
01010101
NAME Hallway Corner 2nd  (3,8)

TIL ar
00111111
01011111
00111111
01011111
00111111
01011111
00111111
00111110
NAME Hallway Corner 2nd  (4,8)

TIL as
11101100
11111101
11110100
11111101
11011100
01101010
10110100
11010101
NAME Hallway Corner 2nd  (5,8)

TIL at
00100100
01001010
10010001
00100100
10010010
01001001
10010100
00100010
NAME Hallway Corner 2nd  (6,8)

TIL au
10010010
01001001
00101010
10100101
10010100
01001010
01010010
10010101
NAME Hallway Corner 2nd  (7,8)

TIL av
10101111
01110101
11011111
01101010
10111101
11101011
10111110
01101011
NAME Hallway Corner 2nd  (8,8)

TIL aw
11111111
01011111
11101111
11111111
10101111
11111111
11010111
11111111
NAME Hallway Corner 2nd  (9,8)

TIL ax
11110110
11111111
11110101
11111111
11110101
11111111
11110101
11111111
NAME Hallway Corner 2nd  (11,8)

TIL ay
10110110
11011010
01101010
10110101
01010101
11011010
01101010
10101010
NAME Hallway Corner 2nd  (12,8)

TIL az
10101110
10110101
10101111
01010101
01011011
10101101
10010110
01011011
NAME Hallway Corner 2nd  (13,8)

TIL b0
11011010
11111010
01101101
11110101
01011010
11111011
11011010
11110101
NAME Hallway Corner 2nd  (14,8)

TIL b1
11110101
10101111
01011010
01110111
10101101
01110111
10101101
01110110
NAME Hallway Corner 2nd  (15,8)

TIL b2
00010101
10010101
01001010
00101010
01010101
10101101
01111111
10101111
NAME Hallway Corner 2nd  (0,9)

TIL b3
01010100
01010101
10101001
10101010
01010100
01010101
11010101
11111110
NAME Hallway Corner 2nd  (1,9)

TIL b4
10010010
01001000
00100101
10010010
10101000
01000101
00101000
10100101
NAME Hallway Corner 2nd  (2,9)

TIL b5
10000000
00101010
01000001
00010100
10100001
00001010
10100000
00010101
NAME Hallway Corner 2nd  (3,9)

TIL b6
01011111
00111111
01011110
00110111
00111110
01011011
10111111
00101010
NAME Hallway Corner 2nd  (4,9)

TIL b7
01011000
11010101
10101000
10110101
11010100
11010101
01101010
10010001
NAME Hallway Corner 2nd  (5,9)

TIL b8
10001001
00101010
10010001
01001010
10010010
00101001
01000100
00101010
NAME Hallway Corner 2nd  (6,9)

TIL b9
01001001
00100100
01010101
10010101
01001001
00101010
10100101
10010101
NAME Hallway Corner 2nd  (7,9)

TIL ba
10111101
11010111
01111101
10101110
01110111
11011101
01110111
10111111
NAME Hallway Corner 2nd  (8,9)

TIL bb
10111110
11101111
10111111
11111111
11111110
11111111
11111111
11111110
NAME Hallway Corner 2nd  (9,9)

TIL bc
11011011
11111111
11111111
10110111
11111111
11111101
11110111
11111111
NAME Hallway Corner 2nd  (10,9)

TIL bd
11111010
01111111
11111101
01111111
11101110
11111111
10111111
11111111
NAME Hallway Corner 2nd  (11,9)

TIL be
11010101
01101010
10101010
10101010
11010101
10101010
01101010
10101010
NAME Hallway Corner 2nd  (12,9)

TIL bf
01010110
10101101
01010110
10101011
01011101
01001011
10101101
10101110
NAME Hallway Corner 2nd  (13,9)

TIL bg
10110101
11011010
11110101
01010101
11011010
01101010
11010101
11010100
NAME Hallway Corner 2nd  (14,9)

TIL bh
01011011
10101110
01110101
01011111
10110101
11011011
01010110
10111011
NAME Hallway Corner 2nd  (15,9)

TIL bi
11110010
11111101
11101010
11111001
10101100
11110100
10101100
10110000
NAME Hallway Corner 2nd  (0,10)

TIL bj
01011011
01010100
10100101
00010010
10001000
00100000
00000000
10000000
NAME Hallway Corner 2nd  (1,10)

TIL bk
11111010
10101111
01010001
00001001
10000100
00100000
00000000
00000000
NAME Hallway Corner 2nd  (2,10)

TIL bl
11001000
01110110
01011111
00100001
00001000
10000010
00100000
00000100
NAME Hallway Corner 2nd  (3,10)

TIL bm
10111010
00101101
11110101
01010101
10001010
00100000
10001010
00100000
NAME Hallway Corner 2nd  (4,10)

TIL bn
10100100
00000010
01101001
01010101
10010111
01010101
10010010
01001010
NAME Hallway Corner 2nd  (5,10)

TIL bo
10010010
01001001
01010101
00100100
11011010
01111111
10101010
10101011
NAME Hallway Corner 2nd  (6,10)

TIL bp
01010100
01001010
00101010
10101010
10101010
11010101
11111111
01010111
NAME Hallway Corner 2nd  (7,10)

TIL bq
11011111
11111111
10111111
11111111
11111111
11111111
11111111
11110101
NAME Hallway Corner 2nd  (8,10)

TIL br
11111111
11110111
11111111
11111101
11011111
01111111
11110110
10111011
NAME Hallway Corner 2nd  (9,10)

TIL bs
11011111
11111011
01111111
11111111
11011011
11111111
11011011
01110110
NAME Hallway Corner 2nd  (10,10)

TIL bt
11110111
01111111
11111111
10110111
11111111
01111101
11010111
11111101
NAME Hallway Corner 2nd  (11,10)

TIL bu
10101010
11010101
10101010
11010101
11010100
11010101
11101010
01101010
NAME Hallway Corner 2nd  (12,10)

TIL bv
01010101
01011011
10101101
00101011
10101101
01010110
10101101
10101011
NAME Hallway Corner 2nd  (13,10)

TIL bw
10110101
11010101
01101010
10110101
11010100
10101010
11101010
01010101
NAME Hallway Corner 2nd  (14,10)

TIL bx
01010110
01111011
10101101
01010110
10111011
11010110
01101101
01011011
NAME Hallway Corner 2nd  (15,10)

TIL by
10101000
01001000
10100000
01010000
10000000
01100000
10000000
01000000
NAME Hallway Corner 2nd  (0,11)

TIL c0
00000000
00000000
00000000
00000000
00000000
00000000
00000001
00001000
NAME Hallway Corner 2nd  (2,11)

TIL c1
00000000
00000001
00010000
00000000
00000001
01000100
00000000
00001000
NAME Hallway Corner 2nd  (3,11)

TIL c2
00000101
00100000
00001010
01000000
00001000
00000010
01010000
00000101
NAME Hallway Corner 2nd  (4,11)

TIL c3
00100001
10010100
00001010
10100001
00010100
10001010
01010001
00001010
NAME Hallway Corner 2nd  (5,11)

TIL c4
00101010
10010101
01010010
01001010
10101010
10010101
01010101
01010010
NAME Hallway Corner 2nd  (6,11)

TIL c5
10101010
01010101
10101101
10110101
01010101
01010101
01010101
10101010
NAME Hallway Corner 2nd  (7,11)

TIL c6
10101110
01110101
10101110
01010111
10111010
01010101
10101101
10110110
NAME Hallway Corner 2nd  (8,11)

TIL c7
11011101
10101011
11111101
01010111
11101101
01010110
11111011
10101101
NAME Hallway Corner 2nd  (9,11)

TIL c8
11011011
01111110
11010111
01111011
10101101
11110111
01011011
11101101
NAME Hallway Corner 2nd  (10,11)

TIL c9
10101111
11111010
01011111
11110101
01011111
11110111
01011101
11101111
NAME Hallway Corner 2nd  (11,11)

TIL ca
11101010
11110101
01110101
11011010
01111010
11011010
01111101
11011101
NAME Hallway Corner 2nd  (12,11)

TIL cb
10011101
01010111
01011010
10101101
01010110
10101011
01011101
01010110
NAME Hallway Corner 2nd  (13,11)

TIL cc
11010101
01101010
11010100
10101010
11101010
10110101
10101001
11010101
NAME Hallway Corner 2nd  (14,11)

TIL cd
01101110
10110101
10101111
11011010
01101101
01010111
01111010
01001111
NAME Hallway Corner 2nd  (15,11)

TIL ce
01000000
00000100
10000000
00010001
01000000
00001001
01000000
00101010
NAME Hallway Corner 2nd  (0,12)

TIL cf
00000000
01001000
00000000
00000100
00100000
00000101
01010000
00000101
NAME Hallway Corner 2nd  (1,12)

TIL cg
10000000
00000000
00100100
10000001
00010100
00100001
00001000
01000101
NAME Hallway Corner 2nd  (2,12)

TIL ch
00000001
10100100
00000001
00101000
01000010
00010100
01000010
00101001
NAME Hallway Corner 2nd  (3,12)

TIL ci
01010000
00000101
01010000
00001010
10100101
01001000
10010101
00100101
NAME Hallway Corner 2nd  (4,12)

TIL cj
10100101
00101001
10010100
01000101
01010101
10101010
00101001
01010101
NAME Hallway Corner 2nd  (5,12)

TIL ck
01001010
00101010
10101010
01010101
01010101
10101010
01010101
01010101
NAME Hallway Corner 2nd  (6,12)

TIL cl
10010101
01010101
10101010
01010101
01010101
10101010
01010101
01010110
NAME Hallway Corner 2nd  (7,12)

TIL cm
01010101
01011011
10101101
01010101
10110101
11010110
01011010
10101011
NAME Hallway Corner 2nd  (8,12)

TIL cn
01010110
10111011
01010101
01111010
10101101
11010110
10110101
01011010
NAME Hallway Corner 2nd  (9,12)

TIL co
10110111
11011010
01101111
10110101
11011010
10101111
11110101
10101110
NAME Hallway Corner 2nd  (10,12)

TIL cp
01011010
11101111
01110101
10101110
11110111
01011011
10101101
11110110
NAME Hallway Corner 2nd  (11,12)

TIL cq
11110110
10111101
11011110
11101111
01111011
10101111
11111011
10101111
NAME Hallway Corner 2nd  (12,12)

TIL cr
10011011
01010101
10101110
01010101
01011110
01010101
10101110
10110101
NAME Hallway Corner 2nd  (13,12)

TIL cs
10101010
10110100
11010010
10101010
11101010
10110101
11010010
10101010
NAME Hallway Corner 2nd  (14,12)

TIL ct
10110101
11011011
10101101
10110111
11011010
01010111
10111010
10101111
NAME Hallway Corner 2nd  (15,12)

TIL cu
10000001
01010100
00001001
10100100
01010010
01001001
01010101
01010100
NAME Hallway Corner 2nd  (0,13)

TIL cv
01010000
00001010
01010001
01001010
10010001
01001101
00100100
10101010
NAME Hallway Corner 2nd  (1,13)

TIL cw
00101000
10010010
01001001
00100101
01010100
00101010
10100101
10010101
NAME Hallway Corner 2nd  (2,13)

TIL cx
10010100
01000010
00101010
01010101
10101010
10101010
01010101
01001010
NAME Hallway Corner 2nd  (3,13)

TIL cy
10010100
01010010
10101010
01010101
10101010
10010101
01010100
10101010
NAME Hallway Corner 2nd  (4,13)

TIL cz
10100101
10101010
10101010
01010101
10101010
01010101
10101010
10101010
NAME Hallway Corner 2nd  (5,13)

TIL d0
01010101
10101010
10101010
01010101
10101010
01010101
10101010
10101011
NAME Hallway Corner 2nd  (6,13)

TIL d1
01010101
10101011
10101101
01010101
10101110
01010101
10101010
01110111
NAME Hallway Corner 2nd  (7,13)

TIL d2
01010101
10111010
01010110
01011011
10101101
01110101
10101010
01101111
NAME Hallway Corner 2nd  (8,13)

TIL d3
11101101
10101010
11010111
01111010
10101101
01010110
11101011
01010101
NAME Hallway Corner 2nd  (9,13)

TIL d4
11010111
10111010
11010111
10111011
10101101
11010110
01101011
10111101
NAME Hallway Corner 2nd  (10,13)

TIL d5
01011011
11010110
01111011
01010101
11011111
10101010
11111101
01010111
NAME Hallway Corner 2nd  (11,13)

TIL d6
11110110
10111011
11010111
01111101
10101011
11111101
01010111
11111011
NAME Hallway Corner 2nd  (12,13)

TIL d7
11010110
11011011
11010111
01111010
11101101
11110111
01111011
11011101
NAME Hallway Corner 2nd  (13,13)

TIL d8
11101001
01010101
11010101
10101010
11101001
01010101
10101010
11101001
NAME Hallway Corner 2nd  (14,13)

TIL d9
01101010
01011011
01101101
10110111
01011010
01101101
10110111
01011010
NAME Hallway Corner 2nd  (15,13)

TIL da
10100101
01010101
10101010
01010101
10101010
01010101
10101010
01010101
NAME Hallway Corner 2nd  (0,14)

TIL db
01010101
01010010
10101010
00101010
10101010
01010101
10101010
01010101
NAME Hallway Corner 2nd  (1,14)

TIL dc
01010101
10101010
10101010
10101010
10101010
01010101
10101010
01010101
NAME Hallway Corner 2nd  (2,14)

TIL dd
01010101
10101010
10101011
10101010
10101010
01010101
10101010
01010101
NAME Hallway Corner 2nd  (4,14)

TIL de
01010101
10101010
01010101
10101011
10101101
01010101
10101010
01011101
NAME Hallway Corner 2nd  (5,14)

TIL df
01010101
10101010
01110110
10011011
01101010
01010101
10101011
01011101
NAME Hallway Corner 2nd  (6,14)

TIL dg
01011010
10101010
11011101
01101010
10101011
01011101
10101010
01101011
NAME Hallway Corner 2nd  (7,14)

TIL dh
10110101
11010101
01101101
10110111
11010101
01011010
10101111
01110101
NAME Hallway Corner 2nd  (8,14)

TIL di
01101110
10110101
01011111
10101010
01110101
10101111
01110101
10101110
NAME Hallway Corner 2nd  (9,14)

TIL dj
11010111
01011010
10101111
11010101
01101110
10110111
01011010
11101111
NAME Hallway Corner 2nd  (10,14)

TIL dk
10101010
11111111
01010101
10101111
11110101
01011111
10101010
11011101
NAME Hallway Corner 2nd  (11,14)

TIL dl
10101101
11110110
01011011
10101101
01110111
10111010
11011111
01101010
NAME Hallway Corner 2nd  (12,14)

TIL dm
11110111
10111111
11101011
01111101
10101111
11111010
01011111
11110101
NAME Hallway Corner 2nd  (13,14)

TIL dn
01010101
11101010
01010101
11101001
11010101
11101010
01101010
11101010
NAME Hallway Corner 2nd  (14,14)

TIL do
01101101
10110111
01011010
01101101
01010111
11101010
10111111
10101010
NAME Hallway Corner 2nd  (15,14)

TIL dp
10101010
01010101
10101010
01010101
10101010
10110110
01011011
11111111
NAME Hallway Corner 2nd  (0,15)

TIL dq
10101010
01010101
10101010
01010101
10110101
11010101
01010110
11111111
NAME Hallway Corner 2nd  (1,15)

TIL dr
10101010
01010101
10101010
01010101
01101010
10101101
10110110
11111111
NAME Hallway Corner 2nd  (2,15)

TIL ds
10101010
01010101
10101010
01010111
10101010
01011011
11101101
11111111
NAME Hallway Corner 2nd  (3,15)

TIL dt
10101010
01110101
10101011
01010101
10101010
01101111
10101010
11111111
NAME Hallway Corner 2nd  (4,15)

TIL du
11101011
01010101
01101010
10110111
11011010
01010101
10101010
11111111
NAME Hallway Corner 2nd  (5,15)

TIL dv
10101010
01101101
10110110
01011010
11101011
01010101
11011011
11111111
NAME Hallway Corner 2nd  (6,15)

TIL dw
10110101
11011010
10101111
11010101
01101010
01011101
10101011
11111111
NAME Hallway Corner 2nd  (7,15)

TIL dx
10101101
11010110
01101011
10111010
11010111
01011010
10101101
11111111
NAME Hallway Corner 2nd  (8,15)

TIL dy
01010101
11101110
01010111
10111010
01010111
11111010
01010111
11111111
NAME Hallway Corner 2nd  (9,15)

TIL dz
01010101
11101111
01010101
11101111
01010101
10111111
01010101
11111111
NAME Hallway Corner 2nd  (10,15)

TIL e0
01101011
10101101
01110110
10101011
01111101
10101011
11011101
11111111
NAME Hallway Corner 2nd  (11,15)

TIL e1
10111111
11010101
11111110
01010111
11111010
01010111
11111010
11111111
NAME Hallway Corner 2nd  (12,15)

TIL e2
01011111
11110101
10111111
11010110
10111101
11010111
10111101
11111111
NAME Hallway Corner 2nd  (13,15)

TIL e3
01101001
10110101
11101010
10101010
11101010
10101010
11101010
11111111
NAME Hallway Corner 2nd  (14,15)

TIL e4
01010111
01111010
10101011
11011101
10101011
10110110
11011011
11111111
NAME Hallway Corner 2nd  (15,15)

TIL bz
11111110
10101011
11110101
01011110
10100101
10111011
01010101
10101010
NAME bigger hallway room 2 story (0,0)

TIL e5
11011111
01101010
10110110
11011011
01101101
01010110
10111011
11010101
NAME bigger hallway room 2 story (1,0)

TIL e6
01101010
10101010
11010001
01011010
10101010
11011111
01101010
10110111
NAME bigger hallway room 2 story (2,0)

TIL e7
10110111
10101010
01010101
10111010
10101111
00111111
11011111
01110111
NAME bigger hallway room 2 story (3,0)

TIL e8
11101101
01011011
01010101
10101010
11010101
11111111
11111111
11111111
NAME bigger hallway room 2 story (4,0)

TIL e9
11111111
01010101
10110111
01011010
01001010
10110101
11111101
11111111
NAME bigger hallway room 2 story (5,0)

TIL ea
11011011
01111101
10101110
11010101
01101110
01010010
01010101
01010101
NAME bigger hallway room 2 story (6,0)

TIL eb
01010101
10110101
11101101
10111110
11101011
10110110
01011011
01010101
NAME bigger hallway room 2 story (7,0)

TIL ec
01010101
01101010
10010101
11101010
10111101
11101111
01110101
10101110
NAME bigger hallway room 2 story (8,0)

TIL ed
01010101
10101001
01010101
10101010
01010101
11101011
10111110
11101011
NAME bigger hallway room 2 story (9,0)

TIL ee
01001010
00101010
01010100
10101010
01010101
10111110
11101011
10111101
NAME bigger hallway room 2 story (10,0)

TIL ef
10101101
10101010
10101011
10101101
11110110
10101011
11011010
01101101
NAME bigger hallway room 2 story (11,0)

TIL eg
10111111
11010101
01101111
10110101
11011011
01010101
10101010
01010101
NAME bigger hallway room 2 story (12,0)

TIL eh
11111111
01010101
11101101
01010110
01010100
01010010
01001010
00100100
NAME bigger hallway room 2 story (13,0)

TIL ei
10110101
01101110
10110101
10101010
10010101
10100100
01010010
10001010
NAME bigger hallway room 2 story (14,0)

TIL ej
01010101
11111111
01010101
11111010
00100101
10101010
10101011
10111110
NAME bigger hallway room 2 story (15,0)

TIL ek
01010101
10101010
10110101
01010110
10101010
10101011
10110101
10101010
NAME bigger hallway room 2 story (0,1)

TIL el
01011010
10101111
10110101
11010101
10101101
01010110
01101011
10110101
NAME bigger hallway room 2 story (1,1)

TIL em
10101001
01010101
11101101
01010111
01111011
10101111
01101011
10111101
NAME bigger hallway room 2 story (2,1)

TIL en
01011111
01101111
01010111
11111111
01001111
10110111
11011111
10101111
NAME bigger hallway room 2 story (3,1)

TIL eo
11111111
11101011
11111111
11111111
11111111
11111111
11111111
11111111
NAME bigger hallway room 2 story (5,1)

TIL ep
01001001
01010010
01001001
01010010
01001001
01010010
01001001
10100010
NAME bigger hallway room 2 story (6,1)

TIL eq
01010101
10101010
00010101
01001010
00101111
01001100
00101100
01001100
NAME bigger hallway room 2 story (7,1)

TIL er
01110111
10010101
01011010
10101010
11110101
10011111
00000101
00000110
NAME bigger hallway room 2 story (8,1)

TIL es
01011101
11110111
10011010
11101011
01011101
11101110
01110111
10111011
NAME bigger hallway room 2 story (9,1)

TIL et
01101111
10110000
11011000
01010000
10111111
11101010
01111101
10101011
NAME bigger hallway room 2 story (10,1)

TIL eu
10110110
00000001
00000001
00000010
11111101
10100101
01011010
10101101
NAME bigger hallway room 2 story (11,1)

TIL ev
10101000
01010101
01001000
10100101
01010100
01010010
10101001
01010101
NAME bigger hallway room 2 story (12,1)

TIL ew
10010001
00100100
10000001
00101000
10000010
01010000
01001101
01110100
NAME bigger hallway room 2 story (13,1)

TIL ex
01111111
01101101
01110011
01101111
10111101
11111111
01101101
10111111
NAME bigger hallway room 2 story (14,1)

TIL ey
11111111
11110111
10111110
11111111
11101101
10111111
11110101
11011111
NAME bigger hallway room 2 story (15,1)

TIL ez
00010101
00001010
10010110
11101011
11011010
11111111
10101010
10101011
NAME bigger hallway room 2 story (0,2)

TIL f0
10101101
11010110
10110101
01011011
11010101
01111110
11010101
01101010
NAME bigger hallway room 2 story (1,2)

TIL f1
01010111
11101011
01011101
01101011
10110111
11011101
01101011
10101101
NAME bigger hallway room 2 story (2,2)

TIL f2
11010111
01101111
11010111
11011111
10110111
11101111
11111111
11010111
NAME bigger hallway room 2 story (3,2)

TIL f3
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11011011
NAME bigger hallway room 2 story (4,2)

TIL f4
01010001
10101000
01000101
10101000
01010010
10100001
11011110
10110101
NAME bigger hallway room 2 story (6,2)

TIL f5
00100111
10010111
01010111
01001111
10101111
00010111
11101111
01010111
NAME bigger hallway room 2 story (7,2)

TIL f6
10111011
11101101
11110101
11110110
11100000
11110000
11110001
11111111
NAME bigger hallway room 2 story (8,2)

TIL f7
11011101
01101111
01010101
11111011
10101101
10110111
01011011
11101111
NAME bigger hallway room 2 story (9,2)

TIL f8
01110101
10101101
01101010
10110101
11011010
11101011
11011101
11110110
NAME bigger hallway room 2 story (10,2)

TIL f9
01010101
10101010
10101111
01010000
10101000
01010000
10111100
11010111
NAME bigger hallway room 2 story (11,2)

TIL fa
01010010
10101010
01010101
00101010
00101001
00101010
10101101
11010110
NAME bigger hallway room 2 story (12,2)

TIL fb
11011010
11110101
01011010
11101001
00100101
10010001
01101101
10101010
NAME bigger hallway room 2 story (13,2)

TIL fc
11111110
01111011
11111111
01111110
11110111
01111111
11111111
11011011
NAME bigger hallway room 2 story (14,2)

TIL fd
11110111
11111111
10110111
11111101
11101111
11110111
01111111
10101111
NAME bigger hallway room 2 story (15,2)

TIL fe
11101101
00000000
10001000
00000000
10100100
00000000
10000000
00010000
NAME bigger hallway room 2 story (0,3)

TIL ff
10110101
00000010
10010000
00000000
00000001
10000000
00001000
00000000
NAME bigger hallway room 2 story (1,3)

TIL fg
01010101
00100010
00000000
00000000
00010000
00000000
00000000
00000010
NAME bigger hallway room 2 story (2,3)

TIL fh
11101111
00000000
00000000
00010000
01000010
00000000
00000000
00000000
NAME bigger hallway room 2 story (3,3)

TIL fi
11101110
00010000
00000000
00000010
01000000
00000000
00000000
00000000
NAME bigger hallway room 2 story (4,3)

TIL fj
10101011
01000100
00000000
00000000
00000010
00000000
00000000
00000000
NAME bigger hallway room 2 story (5,3)

TIL fk
10101010
01000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME bigger hallway room 2 story (6,3)

TIL fl
10101010
10010010
00000000
00000000
00000000
00000000
00000000
00000000
NAME bigger hallway room 2 story (7,3)

TIL fm
10101010
01001010
00000000
00000000
00000000
00000000
00000000
00000000
NAME bigger hallway room 2 story (8,3)

TIL fn
10110101
10010010
00000000
00000001
00000000
00000000
00000000
00000000
NAME bigger hallway room 2 story (9,3)

TIL fo
11111011
01000100
00000000
00010000
00000000
00000000
00000000
00000000
NAME bigger hallway room 2 story (10,3)

TIL fp
01111101
10000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME bigger hallway room 2 story (11,3)

TIL fq
10101010
01010101
00000000
00000000
00000000
00000000
00000000
00000000
NAME bigger hallway room 2 story (12,3)

TIL fr
10101011
00100000
00000000
00000000
00000000
00000000
00000000
00000000
NAME bigger hallway room 2 story (13,3)

TIL fs
01111101
10100010
00000000
00000000
00000000
00000000
00000000
00000000
NAME bigger hallway room 2 story (14,3)

TIL ft
01110111
10010101
00000000
00000001
00000001
00000001
00000001
00000001
NAME bigger hallway room 2 story (15,3)

TIL fu
10000001
00000100
10010000
00000000
10000000
00100010
10000000
00000000
NAME bigger hallway room 2 story (0,4)

TIL fv
00000000
00010000
00000000
00000010
10000000
00000000
00010001
01000000
NAME bigger hallway room 2 story (1,4)

TIL fw
10001000
00000000
00000000
00000000
00000000
00100010
00000000
00000000
NAME bigger hallway room 2 story (2,4)

TIL fx
00000000
00000000
00000000
00010000
00000000
00000001
00000000
00000000
NAME bigger hallway room 2 story (3,4)

TIL fy
00000000
00000000
00000000
00000000
00100000
00000000
00000001
10111110
NAME bigger hallway room 2 story (4,4)

TIL fz
00000000
00000000
00000000
00000000
01000000
00000000
00101111
11110101
NAME bigger hallway room 2 story (5,4)

TIL g0
00000000
00000000
00000000
00000000
00000000
00101011
11111101
01010111
NAME bigger hallway room 2 story (6,4)

TIL g1
00000000
00000000
00000000
00000000
00000010
11111111
01010101
01111111
NAME bigger hallway room 2 story (7,4)

TIL g2
00000000
00000000
00000000
00000000
10101111
11110101
01011011
11111110
NAME bigger hallway room 2 story (8,4)

TIL g3
00000000
00000000
00000000
01001010
11111111
01101110
11011011
11101101
NAME bigger hallway room 2 story (9,4)

TIL g4
00000000
00000000
00000000
01000000
11111111
11010110
10111010
01010101
NAME bigger hallway room 2 story (10,4)

TIL g5
00000000
00000000
00000000
00000000
11101010
10111111
11010101
00101010
NAME bigger hallway room 2 story (11,4)

TIL g6
00000000
00000000
00000000
00000000
10010000
11111111
01010101
10101010
NAME bigger hallway room 2 story (12,4)

TIL g7
00000000
00000000
00000000
00000000
00000000
11101010
01111111
10010101
NAME bigger hallway room 2 story (13,4)

TIL g8
00000000
00000000
00000000
00000000
00000000
00000000
11111111
11011011
NAME bigger hallway room 2 story (14,4)

TIL g9
00000001
00000001
00000001
00000001
00000001
00000000
11010101
01111111
NAME bigger hallway room 2 story (15,4)

TIL ga
10010001
00000000
10000101
10111111
11111111
11111011
11011101
10101010
NAME bigger hallway room 2 story (0,5)

TIL gb
00000000
00000101
01111111
11111110
11101011
01011101
10110101
10101010
NAME bigger hallway room 2 story (1,5)

TIL gc
00001001
11111111
10110110
11111111
11010101
01010101
01010101
10101001
NAME bigger hallway room 2 story (2,5)

TIL gd
01111111
11010101
10111111
01101111
11011111
01101011
00101011
01010101
NAME bigger hallway room 2 story (3,5)

TIL ge
11010101
01101111
11111111
11111111
11111111
11111111
11111111
11111111
NAME bigger hallway room 2 story (4,5)

TIL gf
10101111
11111111
11111111
11111111
11110111
11111111
11111111
11111111
NAME bigger hallway room 2 story (5,5)

TIL gg
11101010
10110101
10101001
10101000
10101010
10010000
10101010
10101000
NAME bigger hallway room 2 story (6,5)

TIL gh
10001111
01101111
00011111
10101111
00001111
10101111
00001111
00001111
NAME bigger hallway room 2 story (7,5)

TIL gi
11111111
11111110
11111111
11111110
11111110
11111110
11110110
11111110
NAME bigger hallway room 2 story (8,5)

TIL gj
01010101
11001010
01010101
10100010
11001001
10100100
10010010
10100100
NAME bigger hallway room 2 story (9,5)

TIL gk
11111110
01111111
01111111
01111111
01111111
01111111
10111111
01111111
NAME bigger hallway room 2 story (10,5)

TIL gl
11010010
11111101
01111111
11111111
11111111
11111111
11111111
11111111
NAME bigger hallway room 2 story (11,5)

TIL gm
01001001
01010010
11111101
11011110
11001101
11111100
11111101
11111100
NAME bigger hallway room 2 story (12,5)

TIL gn
01000110
00100010
10010111
11111011
00101111
10000011
00101011
00000111
NAME bigger hallway room 2 story (13,5)

TIL go
10101010
10010100
01010010
11111101
11110111
11011111
11111111
11111111
NAME bigger hallway room 2 story (14,5)

TIL gp
10101011
10101010
01000101
00101001
11111111
11101101
01111111
11111111
NAME bigger hallway room 2 story (15,5)

TIL gq
10101010
10101001
10100100
01011011
11111111
11111111
11111111
11111111
NAME bigger hallway room 2 story (0,6)

TIL gr
10010001
01001010
10111100
11111101
11110110
11111100
11011110
11110110
NAME bigger hallway room 2 story (1,6)

TIL gs
00000100
01010010
10001001
00100000
00001010
10100001
00001000
10000000
NAME bigger hallway room 2 story (2,6)

TIL gt
10000101
00100011
00010001
01000001
00000100
00000001
01000000
01010001
NAME bigger hallway room 2 story (3,6)

TIL gu
10010000
11001000
10101000
10100100
10010100
11010000
10101010
10100100
NAME bigger hallway room 2 story (6,6)

TIL gv
00100111
00001111
00000111
00001111
00000111
10101111
00000111
01010111
NAME bigger hallway room 2 story (7,6)

TIL gw
11111110
11111110
11111110
11111110
11111110
11111101
11111110
11111101
NAME bigger hallway room 2 story (8,6)

TIL gx
10010001
11000100
01010010
10001000
10100010
01001000
10100101
01000000
NAME bigger hallway room 2 story (9,6)

TIL gy
01111111
01111111
10111111
01111111
10111111
01111111
01111111
11111111
NAME bigger hallway room 2 story (10,6)

TIL gz
11111010
11111100
11111010
11111000
11111101
11111000
11111010
11111000
NAME bigger hallway room 2 story (12,6)

TIL h0
01000011
00010111
01000011
00001011
00100111
00000111
01001011
00000111
NAME bigger hallway room 2 story (13,6)

TIL h1
11111111
11111111
11111111
01101101
11110111
11011111
01101111
11011111
NAME bigger hallway room 2 story (14,6)

TIL h2
11111111
11101111
01001011
11111011
11011101
11111111
11111111
11111110
NAME bigger hallway room 2 story (15,6)

TIL h3
11111111
11111110
11111111
11111101
11111110
11111111
11111111
11111110
NAME bigger hallway room 2 story (0,7)

TIL h4
11111110
11101010
11101111
11010110
11110110
01101011
11110110
10101011
NAME bigger hallway room 2 story (1,7)

TIL h5
00000000
00001000
00000000
00000010
10101000
00000010
10100000
00001010
NAME bigger hallway room 2 story (2,7)

TIL h6
01010100
00010001
10000000
00100000
10000101
00101111
10111111
00111111
NAME bigger hallway room 2 story (3,7)

TIL h7
11010000
10101010
11001000
10101000
11010101
11001000
10101001
11101010
NAME bigger hallway room 2 story (6,7)

TIL h8
10001111
00100111
10001111
00100111
00001111
01000111
00101011
01011101
NAME bigger hallway room 2 story (7,7)

TIL h9
11111110
11111110
11111101
11111111
11110101
01111110
10110111
11011010
NAME bigger hallway room 2 story (8,7)

TIL ha
10010101
10100000
01001010
10101010
11101111
10111010
11011101
11101011
NAME bigger hallway room 2 story (9,7)

TIL hb
01111111
01111111
11111111
10111111
01101111
11111011
10101101
11011111
NAME bigger hallway room 2 story (10,7)

TIL hc
11111111
11111111
11111111
11111111
11111111
01111111
11011111
01111011
NAME bigger hallway room 2 story (11,7)

TIL hd
11111010
11111000
11111010
11111000
11111010
11111010
11111011
11111010
NAME bigger hallway room 2 story (12,7)

TIL he
01001011
00000110
01010111
00001101
01000111
00010110
01001111
10001101
NAME bigger hallway room 2 story (13,7)

TIL hf
11001111
11101111
10011111
11011111
10111111
11011111
10111111
10111111
NAME bigger hallway room 2 story (14,7)

TIL hg
11111111
11111101
11111111
11111101
11111111
11111011
11111101
11111011
NAME bigger hallway room 2 story (15,7)

TIL hh
01110110
11110101
01011011
10110101
11110101
11110111
11111001
11101101
NAME bigger hallway room 2 story (1,8)

TIL hi
10100000
00001010
10100000
00001010
10100000
10001010
10100000
10001010
NAME bigger hallway room 2 story (2,8)

TIL hj
10111111
00111111
10111111
00111111
10011110
00101011
10011111
01011110
NAME bigger hallway room 2 story (3,8)

TIL hk
11111111
11111111
11111011
11101101
10111111
11111011
10101101
11111111
NAME bigger hallway room 2 story (4,8)

TIL hl
11111010
10111111
01101110
11110111
01011101
11111110
01100111
10111010
NAME bigger hallway room 2 story (5,8)

TIL hm
11111101
01011110
11101011
10111101
11101011
11111111
10101111
11110011
NAME bigger hallway room 2 story (6,8)

TIL hn
11101110
10110101
11011111
01101111
10111010
11011111
01111010
10111011
NAME bigger hallway room 2 story (7,8)

TIL ho
11111111
10101011
01111111
10111010
11101111
01010101
11110110
01111011
NAME bigger hallway room 2 story (8,8)

TIL hp
10111110
01110101
11011111
10110100
10111111
11010111
10111010
11010111
NAME bigger hallway room 2 story (9,8)

TIL hq
11101101
01011011
11101101
11111111
10110101
10111011
10111111
10101011
NAME bigger hallway room 2 story (10,8)

TIL hr
11010110
11111011
01001110
01110111
11011011
01111010
01011110
11010101
NAME bigger hallway room 2 story (11,8)

TIL hs
10101101
11101110
10110111
01101011
10111101
11101110
10111011
10111101
NAME bigger hallway room 2 story (12,8)

TIL ht
01010111
10101110
10101010
11011111
01101001
10111110
10101101
01110111
NAME bigger hallway room 2 story (13,8)

TIL hu
10111111
10101111
11110101
01011111
11111111
11111111
01111111
11011111
NAME bigger hallway room 2 story (14,8)

TIL hv
11111111
11111011
11110111
01111101
11010111
11111011
11010101
11101111
NAME bigger hallway room 2 story (15,8)

TIL hw
11111111
11111101
11010110
11111011
10101110
11111011
11011111
11111111
NAME bigger hallway room 2 story (0,9)

TIL hx
10111101
11101110
10110101
11011011
10101101
01110101
10101011
01011101
NAME bigger hallway room 2 story (1,9)

TIL hy
11000001
10101010
11001010
01010101
01010101
01101010
01010101
01010101
NAME bigger hallway room 2 story (2,9)

TIL hz
00100111
10101011
10101001
01010101
01010101
10101010
01010101
01010101
NAME bigger hallway room 2 story (3,9)

TIL i0
01011111
11101110
01111111
01111011
00001111
11101011
00101010
10101010
NAME bigger hallway room 2 story (4,9)

TIL i1
11101111
10110101
11111101
01010111
11111111
11111101
11110110
01011111
NAME bigger hallway room 2 story (5,9)

TIL i2
01011110
11101011
01111101
01011111
11011000
01110111
11110101
11111111
NAME bigger hallway room 2 story (6,9)

TIL i3
11010110
11111011
11011100
11000111
11111011
11111111
11101011
11111101
NAME bigger hallway room 2 story (7,9)

TIL i4
10101101
11010111
01011011
10101011
11101100
10110111
10111001
11011110
NAME bigger hallway room 2 story (8,9)

TIL i5
01110100
11011111
10101111
11011110
11110111
01111101
11010111
01111001
NAME bigger hallway room 2 story (9,9)

TIL i6
11110101
01101110
11101011
11110101
10111110
01111111
11001110
11110011
NAME bigger hallway room 2 story (10,9)

TIL i7
11111111
10111100
01101011
10111110
10101011
11010111
01110101
10111101
NAME bigger hallway room 2 story (11,9)

TIL i8
11010111
11111110
01111110
10111111
11011001
11101101
11101111
11010111
NAME bigger hallway room 2 story (12,9)

TIL i9
01011110
11111011
10011101
11101111
01111011
01111111
10011110
11101101
NAME bigger hallway room 2 story (13,9)

TIL ia
10110111
11011101
11110110
01101111
11111001
01011111
11101111
01111111
NAME bigger hallway room 2 story (14,9)

TIL ib
01110101
10111111
11011010
01101111
11011010
01110111
11010101
10111010
NAME bigger hallway room 2 story (15,9)

TIL ic
11111111
11111110
11110101
11101111
11011111
11111101
11101011
10111110
NAME bigger hallway room 2 story (0,10)

TIL id
11101010
10110110
11111011
11101101
10111101
11110110
11011111
11111011
NAME bigger hallway room 2 story (1,10)

TIL ie
11011010
10101010
01010101
01101010
10101010
10101010
10101010
11101010
NAME bigger hallway room 2 story (2,10)

TIL if
10101010
10101010
01010101
10101010
10101010
10101010
10101010
10101010
NAME bigger hallway room 2 story (3,10)

TIL ig
10101010
10101010
01010101
10101010
10101010
10101010
10100101
10010101
NAME bigger hallway room 2 story (4,10)

TIL ih
10101111
10101011
01010101
10101010
10101010
10101010
01010101
00101010
NAME bigger hallway room 2 story (5,10)

TIL ii
11100101
11011010
11110101
01110101
10111111
10001111
01010101
10101010
NAME bigger hallway room 2 story (6,10)

TIL ij
10101100
11101111
00111011
10101111
11010111
10110101
11010011
11101111
NAME bigger hallway room 2 story (7,10)

TIL ik
11111111
00111101
11010110
11111011
00011101
11010110
01111011
11111101
NAME bigger hallway room 2 story (8,10)

TIL il
11101110
01111011
11111100
01111111
01111110
10101100
10101110
11110111
NAME bigger hallway room 2 story (9,10)

TIL im
11111110
11111011
11110111
11011011
11101111
01110011
11111011
00110101
NAME bigger hallway room 2 story (10,10)

TIL in
11111111
10011101
11111111
11110100
11110111
11010111
00111011
10011011
NAME bigger hallway room 2 story (11,10)

TIL io
01110101
01011111
11100011
01111101
10011111
11101111
11111000
11111110
NAME bigger hallway room 2 story (12,10)

TIL ip
10111110
11001011
10101011
11110101
01111111
11010111
11111001
01111110
NAME bigger hallway room 2 story (13,10)

TIL iq
10111011
11011111
11110111
01111010
10011101
11100010
11011101
11101101
NAME bigger hallway room 2 story (14,10)

TIL ir
01111111
10011111
11101111
10101011
11101101
11110111
01111011
01011101
NAME bigger hallway room 2 story (15,10)

TIL is
11111011
11101111
11111010
10101111
11111101
11110111
11011110
11111111
NAME bigger hallway room 2 story (0,11)

TIL it
11101111
01011111
10111111
11111110
11111010
11010101
11111111
11101010
NAME bigger hallway room 2 story (1,11)

TIL iu
11010101
11110101
10111010
10111101
11111110
11111110
11111011
11111111
NAME bigger hallway room 2 story (2,11)

TIL iv
01010101
01010100
10101010
01010101
10101010
10101010
11010101
01010101
NAME bigger hallway room 2 story (3,11)

TIL iw
01010100
10101010
10101010
01010101
10101010
10010100
01010010
01010101
NAME bigger hallway room 2 story (4,11)

TIL ix
10101001
10101010
10101010
01010101
10010010
10101010
10101010
01001001
NAME bigger hallway room 2 story (5,11)

TIL iy
01010010
10101010
01010101
00101010
10100101
10010010
01010101
01010100
NAME bigger hallway room 2 story (6,11)

TIL iz
01111011
10011111
01001011
10101010
01010101
10101001
00100101
10010101
NAME bigger hallway room 2 story (7,11)

TIL j0
01111111
11111110
01111101
11111011
01110101
01011011
00101010
01010101
NAME bigger hallway room 2 story (8,11)

TIL j1
10111101
11111110
00111111
01011111
11111110
11111110
11111111
11100011
NAME bigger hallway room 2 story (9,11)

TIL j2
11101010
11111001
11111110
11000111
11111011
11111111
11111111
11011111
NAME bigger hallway room 2 story (10,11)

TIL j3
11100111
01011101
00101111
10101011
11010101
11110010
11111100
11110111
NAME bigger hallway room 2 story (11,11)

TIL j4
11101111
10010111
11010111
11101111
11101011
11110101
01111101
01110011
NAME bigger hallway room 2 story (12,11)

TIL j5
01011111
11011101
11111100
11111111
11101101
11010110
10101111
10100011
NAME bigger hallway room 2 story (13,11)

TIL j6
01010111
01110010
10111111
01001111
11101011
11111111
01111111
10111111
NAME bigger hallway room 2 story (14,11)

TIL j7
10111010
11101101
11111011
01111011
11111001
10011110
01010111
11101011
NAME bigger hallway room 2 story (15,11)

TIL j8
11111111
11110110
11111111
11101001
10101111
10101011
10111111
11110111
NAME bigger hallway room 2 story (0,12)

TIL j9
10101111
10111101
11111011
11111111
11111100
11110110
11111001
11101111
NAME bigger hallway room 2 story (1,12)

TIL ja
01111101
11111111
11100111
10111111
10011101
10110101
11101011
11111111
NAME bigger hallway room 2 story (2,12)

TIL jb
01101010
11110101
11110101
10110101
01110110
11101111
11111110
01011100
NAME bigger hallway room 2 story (3,12)

TIL jc
10101010
00101010
01010101
01010010
10101010
01010101
10101010
10101010
NAME bigger hallway room 2 story (4,12)

TIL jd
10101010
10101010
01010010
10010101
01010101
01010101
10101010
10100100
NAME bigger hallway room 2 story (5,12)

TIL je
10101010
10010010
01010101
01010100
01001010
01010101
10101010
10101010
NAME bigger hallway room 2 story (6,12)

TIL jf
10101010
10101010
01010010
10010101
10101001
01010101
10100100
10101010
NAME bigger hallway room 2 story (7,12)

TIL jg
10101010
10100101
10101010
00101010
01010101
00100100
10101010
10010101
NAME bigger hallway room 2 story (8,12)

TIL jh
11110101
01011101
10101111
10101111
00100011
10101101
10101000
01010110
NAME bigger hallway room 2 story (9,12)

TIL ji
11010000
11101010
01111101
11001110
01110011
11111010
10101110
10111111
NAME bigger hallway room 2 story (10,12)

TIL jj
11111011
01111111
00111101
10001111
11100010
11110101
11111101
10111110
NAME bigger hallway room 2 story (11,12)

TIL jk
10110101
11111000
11111101
11101110
11010111
11110111
01111111
11111111
NAME bigger hallway room 2 story (12,12)

TIL jl
11101011
01111101
00011111
11000111
10101001
11101010
11111001
11111110
NAME bigger hallway room 2 story (13,12)

TIL jm
11111111
10111101
11110110
11110001
01111110
11111111
00111111
10101111
NAME bigger hallway room 2 story (14,12)

TIL jn
00111110
10111111
10101111
10101111
01101111
01011011
10101111
11100111
NAME bigger hallway room 2 story (15,12)

TIL jo
11111111
10111101
11110101
11111111
11111110
11110101
11111111
11111111
NAME bigger hallway room 2 story (0,13)

TIL jp
01011101
01110101
11101011
10101111
10111110
11111010
11011101
01111011
NAME bigger hallway room 2 story (1,13)

TIL jq
11111110
11111010
11110101
11010111
10111111
10111011
01110111
11010111
NAME bigger hallway room 2 story (2,13)

TIL jr
11111111
11101111
11111111
10111111
11111111
01111110
11110101
01010100
NAME bigger hallway room 2 story (3,13)

TIL js
01010101
11010101
11111010
11110101
10110101
10111101
01111110
11111010
NAME bigger hallway room 2 story (4,13)

TIL jt
01010101
00101010
10101010
01010101
01010010
01010101
10101010
01010101
NAME bigger hallway room 2 story (5,13)

TIL ju
01010101
10010010
10101010
01010101
10101010
01010101
10101010
01010010
NAME bigger hallway room 2 story (6,13)

TIL jv
01010101
01001010
10101001
01010101
10101010
01010101
01001010
10101001
NAME bigger hallway room 2 story (7,13)

TIL jw
01010010
10101010
01001010
00101010
10101010
01010101
10101010
01010101
NAME bigger hallway room 2 story (8,13)

TIL jx
10101001
01010101
10100101
10010101
10101010
01010010
10101010
01001010
NAME bigger hallway room 2 story (9,13)

TIL jy
01001011
01010110
01010011
01010100
10101011
01010100
10101010
10010101
NAME bigger hallway room 2 story (10,13)

TIL jz
11111111
10111110
11101111
01111110
01011011
10101111
10100101
01010101
NAME bigger hallway room 2 story (11,13)

TIL k0
00111111
10101110
01010111
10010111
11111011
01111101
11111110
11101111
NAME bigger hallway room 2 story (12,13)

TIL k1
11111111
11111010
10111111
11011111
11011111
01010111
11101011
10111000
NAME bigger hallway room 2 story (13,13)

TIL k2
01011111
11101101
11110111
01111111
11111111
11111111
11111111
00101111
NAME bigger hallway room 2 story (14,13)

TIL k3
11110011
11111101
01111111
01011111
10101111
11010011
11010101
11110101
NAME bigger hallway room 2 story (15,13)

TIL k4
11111110
11111010
11101011
10101011
10101111
10111110
11111101
11110101
NAME bigger hallway room 2 story (0,14)

TIL k5
10111110
11110101
11111111
11111111
11111111
11111111
11111101
11111010
NAME bigger hallway room 2 story (1,14)

TIL k6
10101110
01011111
11111111
11111111
10111111
01111111
01111111
11111110
NAME bigger hallway room 2 story (2,14)

TIL k7
10101010
01001011
11111011
11110111
11101111
10101111
01010111
10101111
NAME bigger hallway room 2 story (3,14)

TIL k8
11110101
11010010
10101011
10010111
11011110
01111111
11111110
11111101
NAME bigger hallway room 2 story (4,14)

TIL k9
11101010
11110101
11111010
11111110
11111110
01111111
11111111
01111111
NAME bigger hallway room 2 story (5,14)

TIL ka
01001010
01010101
10101010
10101010
10101010
01010101
11010101
11101010
NAME bigger hallway room 2 story (6,14)

TIL kb
10101010
01010101
10100101
10010101
01010101
01010100
01010101
10101010
NAME bigger hallway room 2 story (7,14)

TIL kc
10101010
01010101
01010101
01010101
00101010
10101010
01010101
10101010
NAME bigger hallway room 2 story (8,14)

TIL kd
10101001
01010101
01010101
01010101
10101010
10101010
01010101
10101010
NAME bigger hallway room 2 story (9,14)

TIL ke
01010010
01001010
00101010
01010101
10101010
10101001
01010101
10101010
NAME bigger hallway room 2 story (10,14)

TIL kf
10101010
10101010
01010101
01001010
10101010
01010101
00101010
10101010
NAME bigger hallway room 2 story (11,14)

TIL kg
10111111
10111101
01001111
10101011
10101010
01010101
10101010
10101010
NAME bigger hallway room 2 story (12,14)

TIL kh
11011111
11101110
11110011
10111001
11101110
01111111
10111101
10101111
NAME bigger hallway room 2 story (13,14)

TIL ki
01011101
10100111
10101011
11101011
01111001
10111110
11011111
01110111
NAME bigger hallway room 2 story (14,14)

TIL kj
01011101
11101111
11110111
11111111
11111011
11111111
11111010
11111111
NAME bigger hallway room 2 story (15,14)

TIL kk
11101011
10101111
10101111
10111101
10110101
11110101
11010101
10101011
NAME bigger hallway room 2 story (0,15)

TIL kl
11101011
11010101
01010111
01010111
01011101
01110101
11111010
11110101
NAME bigger hallway room 2 story (1,15)

TIL km
11111010
11110101
11010101
10101010
01010101
01010101
10101011
01011111
NAME bigger hallway room 2 story (2,15)

TIL kn
10011111
01111111
00111111
11111111
01111111
01111111
11111111
11111111
NAME bigger hallway room 2 story (3,15)

TIL ko
11111110
11111110
11111110
11111101
11111111
11111010
11101111
11101110
NAME bigger hallway room 2 story (4,15)

TIL kp
11111111
11111111
10101010
01011111
11111111
11111111
01111111
10111111
NAME bigger hallway room 2 story (5,15)

TIL kq
11101010
01101010
11110101
11110101
11111110
11101111
11011111
10111111
NAME bigger hallway room 2 story (6,15)

TIL kr
10101010
10101010
01010101
01010101
10101010
10101010
11010101
11101010
NAME bigger hallway room 2 story (7,15)

TIL ks
10101010
10101010
01010101
01010101
10101010
10101010
01010101
10101010
NAME bigger hallway room 2 story (8,15)

TIL kt
10101010
10101010
01010101
01010101
10101010
10100101
01010101
10101010
NAME bigger hallway room 2 story (9,15)

TIL ku
10101010
10101010
01010101
01010101
10101010
01010101
01010101
10101010
NAME bigger hallway room 2 story (10,15)

TIL kv
10101011
10101111
01010001
01011101
10100100
01010110
01010101
10101010
NAME bigger hallway room 2 story (13,15)

TIL kw
11111111
11011111
01110101
10111111
10111110
10101011
01010111
10101010
NAME bigger hallway room 2 story (14,15)

TIL kx
11001111
11010011
10101101
11010011
11101101
11110101
10111111
11111111
NAME bigger hallway room 2 story (15,15)

TIL ky
11111111
11111111
11111111
11111111
11111111
11111111
11110111
11011111
NAME stair room with people (1,0)

TIL kz
11111110
11111111
11111111
11111111
11111110
11111111
11111110
11111111
NAME stair room with people (2,0)

TIL l0
11010111
01101111
01011111
01101111
10011111
01111111
11111111
01111011
NAME stair room with people (3,0)

TIL l1
11111011
11111000
11110000
01110001
11101000
11100001
01101101
11011111
NAME stair room with people (4,0)

TIL l2
11111111
01011111
01010111
01010100
11010101
01010110
10101001
10101101
NAME stair room with people (5,0)

TIL l3
11011111
11111111
10111111
01111111
11111111
11101111
10111111
11111101
NAME stair room with people (6,0)

TIL l4
11111101
11111111
11111111
11111110
11111100
11111100
11110000
11100000
NAME stair room with people (7,0)

TIL l5
11011111
11111111
01111111
00111111
00011111
00001111
00000111
00000011
NAME stair room with people (8,0)

TIL l6
11111111
11111101
11111111
11111111
11111110
11111111
11111110
11101111
NAME stair room with people (9,0)

TIL l7
11111111
11111111
11111010
01011111
11101111
00111111
10110101
00111010
NAME stair room with people (10,0)

TIL l8
11101011
00011111
00001111
00011111
10000111
10001111
01000011
10000011
NAME stair room with people (11,0)

TIL l9
11110010
11110111
11111010
11111011
11111101
11111111
11111110
11111111
NAME stair room with people (12,0)

TIL la
11111111
01111111
11111111
01111111
01111111
01111111
10111111
11111111
NAME stair room with people (13,0)

TIL lb
11011111
11111111
10111111
11111111
11110111
11111111
11111111
11111011
NAME stair room with people (1,1)

TIL lc
11111111
11111110
11111110
11111111
11111110
11111110
11111110
11111110
NAME stair room with people (2,1)

TIL ld
11101011
10110110
10010101
11110111
10101000
11110111
11111111
11110111
NAME stair room with people (3,1)

TIL le
01010111
10101101
10111011
00101101
10000001
10000000
10000000
00000000
NAME stair room with people (4,1)

TIL lf
01010011
11011011
01000111
11110111
01101111
00001111
00000001
00000000
NAME stair room with people (5,1)

TIL lg
11111110
11111010
11111100
11111001
11111011
11111011
10110111
01000111
NAME stair room with people (6,1)

TIL lh
11000000
00000000
11100000
11110000
11111000
11111100
11111110
11111101
NAME stair room with people (7,1)

TIL li
00000001
00000000
00000001
00000011
00000111
00011111
00010111
11011111
NAME stair room with people (8,1)

TIL lj
11010111
00011011
00000111
10010011
11000111
11101010
11110011
11101000
NAME stair room with people (9,1)

TIL lk
11011010
11001101
01101101
11110111
11110101
11010010
00000000
00000000
NAME stair room with people (10,1)

TIL ll
10000011
10000001
10000001
00000001
00100100
10000000
00000001
00000000
NAME stair room with people (11,1)

TIL lm
11110111
11101111
11110011
11011101
10101011
11010101
01111111
11111111
NAME stair room with people (12,1)

TIL ln
10111111
10111111
10111111
11111111
11111111
01111111
00101011
11111111
NAME stair room with people (13,1)

TIL lo
11111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME stair room with people (14,1)

TIL lp
11111111
11111111
11111111
11111111
11010110
01111111
11101111
10111111
NAME stair room with people (0,2)

TIL lq
11101011
11111111
11110111
10111111
11110011
11011011
01111111
11101011
NAME stair room with people (1,2)

TIL lr
11111110
11111110
11111110
11111110
11111111
11111111
11111111
11111111
NAME stair room with people (2,2)

TIL ls
11111111
11101011
01111111
11110101
11111110
11111011
11111111
01011010
NAME stair room with people (3,2)

TIL lt
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000010
NAME stair room with people (4,2)

TIL lu
00001101
00010010
00010101
00001000
00001010
00010101
00000000
01111100
NAME stair room with people (5,2)

TIL lv
01001011
10011110
00111111
11111111
01111111
11111111
00011101
00000001
NAME stair room with people (6,2)

TIL lw
11111011
11111111
10101111
11001111
10111011
01111110
11111110
01111100
NAME stair room with people (7,2)

TIL lx
11100111
11110011
11111111
11111000
11110111
11111111
00101111
00001111
NAME stair room with people (8,2)

TIL ly
11000000
10111100
01101110
01011111
00111111
11011110
11001101
11100000
NAME stair room with people (9,2)

TIL lz
00010000
00000000
00000000
00000000
00010000
10000000
10000000
00010101
NAME stair room with people (10,2)

TIL m0
00000001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME stair room with people (11,2)

TIL m1
11111111
01111111
01111111
01101111
00111111
00111111
00111111
00111111
NAME stair room with people (12,2)

TIL m2
10110101
10111111
10110101
10111011
11011101
11010111
11010101
11011111
NAME stair room with people (13,2)

TIL m3
01101011
01111110
01101101
01101110
01101111
01001101
11101110
01101111
NAME stair room with people (14,2)

TIL m4
11111111
01011111
01111011
11011001
01101011
11111010
11011011
01101011
NAME stair room with people (15,2)

TIL m5
11111001
11111001
11111101
11111100
11111110
11111110
11111110
11111100
NAME stair room with people (1,3)

TIL m6
11111111
11111111
11111110
11111010
11100100
01000010
10010101
00000010
NAME stair room with people (2,3)

TIL m7
10100100
01000010
00000000
01000010
00000000
01000010
01010010
10101010
NAME stair room with people (3,3)

TIL m8
00010101
11011101
10101001
11111101
11101010
11111101
01111101
10100010
NAME stair room with people (4,3)

TIL m9
10101011
01010010
11010101
01010010
10101010
01000000
01000000
11100000
NAME stair room with people (5,3)

TIL ma
01010110
10000110
01001110
10010111
10001010
00000000
00011001
00000011
NAME stair room with people (6,3)

TIL mb
00111000
10000000
00000000
00111000
01011100
10001000
01000001
01000100
NAME stair room with people (7,3)

TIL mc
00000111
00000000
00000000
00000100
00000111
10001110
11100000
01000100
NAME stair room with people (8,3)

TIL md
00000000
00001000
00000000
00010100
00000000
00000000
01110000
11010000
NAME stair room with people (9,3)

TIL me
00001101
00000110
00000011
00000010
10000010
00000001
00000000
00000001
NAME stair room with people (10,3)

TIL mf
10110000
10101100
01011011
10010111
00011111
10101111
00011111
11001110
NAME stair room with people (11,3)

TIL mg
00101011
00100101
10101000
00100010
11010001
10001000
10100101
10110111
NAME stair room with people (12,3)

TIL mh
01111101
10011111
11011010
00001011
00100100
00010010
10101001
10100100
NAME stair room with people (13,3)

TIL mi
10011011
10011110
10010111
10111111
10011111
01111111
00111011
10001111
NAME stair room with people (14,3)

TIL mj
11011110
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (15,3)

TIL mk
11111111
11111111
11111111
11111110
11111110
11111111
11110101
10101010
NAME stair room with people (0,4)

TIL ml
11110011
11101000
10000010
00000001
00000001
00100010
00000011
10001111
NAME stair room with people (1,4)

TIL mm
00001010
00101011
10010101
01010111
10011111
11011111
11111111
11111111
NAME stair room with people (2,4)

TIL mn
10001110
00001101
00000100
10001111
11010111
11011111
10011011
01101111
NAME stair room with people (3,4)

TIL mo
10011101
01101011
11011111
01101010
01011010
00011010
00010101
00001011
NAME stair room with people (4,4)

TIL mp
01000000
11000000
11000000
11000000
10000000
10101000
11011000
00101000
NAME stair room with people (5,4)

TIL mq
00010001
00000000
00000000
00000000
00000001
10000011
00000001
00000110
NAME stair room with people (6,4)

TIL mr
10101100
00000100
11110000
11111000
11110000
11111000
11100000
10110000
NAME stair room with people (7,4)

TIL ms
00001010
00000100
00000001
00000011
00000001
00000001
00000001
00000001
NAME stair room with people (8,4)

TIL mt
00101000
00000000
11000000
11000000
01110000
11010000
10100000
11011000
NAME stair room with people (9,4)

TIL mu
00000000
00000000
00000000
00000000
00000000
00000101
00000111
00000001
NAME stair room with people (10,4)

TIL mv
01110010
11110110
01110111
11011111
10110100
10011000
11011000
01110000
NAME stair room with people (11,4)

TIL mw
10011011
01011111
10011111
11100111
10010111
01011010
00111100
00111110
NAME stair room with people (12,4)

TIL mx
10101000
11100000
10111010
11110010
11111110
11111111
11111111
11111111
NAME stair room with people (13,4)

TIL my
01000101
00101011
00010101
10010010
01000000
10100010
10100000
11010001
NAME stair room with people (14,4)

TIL mz
11111111
11111111
01111111
10111111
00001111
10001011
00011101
00101011
NAME stair room with people (15,4)

TIL n0
00001001
00000100
00010011
00001010
10000111
00011111
00111111
01111110
NAME stair room with people (0,5)

TIL n1
00101010
11010001
01100001
11100001
11110000
10010000
00011000
00001000
NAME stair room with people (1,5)

TIL n2
01111110
11111101
11110010
11001101
11010011
00111111
01010111
10111101
NAME stair room with people (2,5)

TIL n3
10101111
10010111
11101111
11011111
11111111
10111111
10011111
11010111
NAME stair room with people (3,5)

TIL n4
10011011
10111110
10111011
11111111
11110101
11010001
11100001
11000111
NAME stair room with people (4,5)

TIL n5
10010000
10000000
00110010
01110100
10110000
11101110
10111111
01011111
NAME stair room with people (5,5)

TIL n6
00000011
00000101
00000011
00000101
00011011
01101010
10010111
10101111
NAME stair room with people (6,5)

TIL n7
11010100
01101000
11010000
01100000
11010100
11101000
10110000
11111000
NAME stair room with people (7,5)

TIL n8
00000000
00000001
00000001
00000000
00000010
00000000
00000001
01001000
NAME stair room with people (8,5)

TIL n9
11101010
01011101
01101011
10100111
10101101
01010110
01101111
01111111
NAME stair room with people (9,5)

TIL na
00000001
00000000
00000011
00000010
00000011
10101101
01111110
10111110
NAME stair room with people (10,5)

TIL nb
01011100
01000110
01001101
00000111
10000111
01101010
10101000
11010001
NAME stair room with people (11,5)

TIL nc
00010101
00001011
00000101
00000011
11000111
11110011
11110111
11111111
NAME stair room with people (12,5)

TIL nd
10111111
11011111
11110111
01101001
10110101
11011110
11111101
11110111
NAME stair room with people (13,5)

TIL ne
01101110
11011111
11101111
11011111
11010010
10100101
01111001
00111111
NAME stair room with people (14,5)

TIL nf
00101000
00110100
11010001
01100100
11010000
11100100
11111111
11111111
NAME stair room with people (15,5)

TIL ng
00001101
10000101
10001110
11010110
11011110
11111111
10110111
11011111
NAME stair room with people (1,6)

TIL nh
01001111
10110111
11001011
10111111
11010111
01011011
10101110
11111101
NAME stair room with people (2,6)

TIL ni
11101111
11111111
11111111
11111111
11111111
01111111
11111111
11111111
NAME stair room with people (3,6)

TIL nj
11101100
11111111
11111101
11111001
11110001
11110001
11111011
11111011
NAME stair room with people (4,6)

TIL nk
11011111
01111111
11011111
11101111
11111111
11111111
11111111
11111111
NAME stair room with people (5,6)

TIL nl
11011111
10101111
11011111
11011111
11111111
11111111
11111111
11111111
NAME stair room with people (6,6)

TIL nm
01111000
01111100
11111100
11111100
11111110
11111110
11111111
11111111
NAME stair room with people (7,6)

TIL nn
10000101
00101010
01000100
10010011
00101001
10000100
00010001
00000010
NAME stair room with people (8,6)

TIL no
01111111
10111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME stair room with people (9,6)

TIL np
10111111
11111111
11111110
11111110
11111110
11111111
01111111
11111111
NAME stair room with people (10,6)

TIL nq
01011000
01001100
11011110
11111111
11111111
11111111
11111111
11110111
NAME stair room with people (11,6)

TIL nr
01111011
01111111
00101111
00101111
00011111
00111111
10111111
11100111
NAME stair room with people (12,6)

TIL ns
11111101
11110110
11111111
11111101
11111111
11111111
10111111
11011111
NAME stair room with people (13,6)

TIL nt
11011111
01100111
01101111
11011011
11111101
11111110
11111111
11111111
NAME stair room with people (14,6)

TIL nu
11111111
11111111
11111110
11111111
11111110
11110101
11101111
01010111
NAME stair room with people (0,7)

TIL nv
11111111
11111111
11100111
11011111
10111111
11011111
01111111
10111111
NAME stair room with people (1,7)

TIL nw
11111011
11111011
11110111
11111111
11111111
11111111
11111101
11111111
NAME stair room with people (2,7)

TIL nx
11101111
11111111
11111111
11111111
11111111
10111111
11111111
11111111
NAME stair room with people (3,7)

TIL ny
11111111
11111101
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (4,7)

TIL nz
11111111
11111111
00101111
11111111
11111111
11111110
11111010
11001010
NAME stair room with people (6,7)

TIL o0
11111110
11111110
11111100
11111100
11111001
10100100
10101010
01010010
NAME stair room with people (7,7)

TIL o1
00000101
00000010
00010000
00000011
01001010
10101011
00010101
10100010
NAME stair room with people (8,7)

TIL o2
11111111
01111111
01011111
11111111
11111111
01111111
11111111
11101111
NAME stair room with people (9,7)

TIL o3
11111111
11111111
11011111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (10,7)

TIL o4
11110111
11111111
11111100
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (11,7)

TIL o5
11101111
11101111
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (12,7)

TIL o6
11111111
11111111
11111111
11111111
11111101
11111111
11111111
11110111
NAME stair room with people (13,7)

TIL o7
11111111
11111111
11111111
11111111
11111101
11110110
11111101
11110110
NAME stair room with people (15,7)

TIL o8
10111011
10101111
10101011
11101101
01101011
10110101
01010110
10101011
NAME stair room with people (0,8)

TIL o9
11111111
11111111
11111111
11111111
01111111
11111111
11111111
11111111
NAME stair room with people (1,8)

TIL oa
11111111
11111111
11111111
11111111
11101111
11011111
11111111
11111111
NAME stair room with people (2,8)

TIL ob
11111111
11111111
11111111
11111111
11111111
11111111
10110101
11111111
NAME stair room with people (5,8)

TIL oc
11111111
11111111
11111111
11111111
11111101
11101011
00101000
11111111
NAME stair room with people (6,8)

TIL od
11111001
11110110
11101010
01110111
11111101
01010111
10101010
11100000
NAME stair room with people (7,8)

TIL oe
00001011
11101111
10110111
01011111
11110111
11111011
10101011
00100101
NAME stair room with people (8,8)

TIL of
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111111
NAME stair room with people (12,8)

TIL og
10101111
10111111
01011111
11111111
10111111
11111111
11111111
11111111
NAME stair room with people (13,8)

TIL oh
11111011
11111111
11111110
11111111
11111110
11111101
11111110
11111100
NAME stair room with people (15,8)

TIL oi
01010101
11110110
11111101
11111101
11111110
11111111
11111110
11111111
NAME stair room with people (0,9)

TIL oj
01011111
10111111
01111111
01111111
11111111
11111111
11111111
11111111
NAME stair room with people (1,9)

TIL ok
11111111
11111111
11111111
11111111
11111100
11111110
11111101
11100011
NAME stair room with people (3,9)

TIL ol
11111111
11111111
11111111
11111111
11111101
11000000
11111001
11111111
NAME stair room with people (4,9)

TIL om
11111111
11111111
11111111
11110101
11001000
11111111
11111111
11111111
NAME stair room with people (7,9)

TIL on
11011110
11111111
11101101
01010101
00000010
11111111
11111111
11111111
NAME stair room with people (8,9)

TIL oo
11111100
11111000
11110000
11110000
11110000
10101000
11011100
11011110
NAME stair room with people (15,9)

TIL op
11111111
11111111
11101011
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (2,10)

TIL oq
11010101
00000000
00000000
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (5,10)

TIL or
01000000
00001001
00000000
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (6,10)

TIL os
01111111
00101010
10010101
01010101
10101010
11111111
11111111
11111111
NAME stair room with people (7,10)

TIL ot
11111111
10001001
01010101
00100100
10010101
11111111
11111111
11111111
NAME stair room with people (8,10)

TIL ou
01000000
00000000
01000000
10111111
01111111
11111111
11111111
11111111
NAME stair room with people (9,10)

TIL ov
00000111
00000011
00000011
11100011
11100011
11100111
11100111
11110111
NAME stair room with people (10,10)

TIL ow
11101101
11000000
11100000
11100011
11110011
11110001
11111011
11111011
NAME stair room with people (12,10)

TIL ox
01111111
00000101
00100010
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (13,10)

TIL oy
11111111
11111111
10111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (14,10)

TIL oz
11111011
11110111
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (15,10)

TIL p0
11111111
11111111
11111111
11111111
11111111
11111111
11011111
11111111
NAME stair room with people (0,11)

TIL p1
11111111
11111111
11111111
11111111
11111100
11111101
11111110
11111111
NAME stair room with people (6,11)

TIL p2
11111111
11111111
11111111
11011111
00100000
10101110
11111011
11111111
NAME stair room with people (7,11)

TIL p3
11111111
11111111
11111111
11111111
10010010
10101011
11111111
11111111
NAME stair room with people (8,11)

TIL p4
11111111
11111111
11111111
11111111
01111111
01111111
11111111
11111111
NAME stair room with people (9,11)

TIL p5
11100111
11100111
11100111
11100111
11101111
11100111
11100111
11100111
NAME stair room with people (10,11)

TIL p6
11111011
11111111
11111101
11111110
11111110
11111110
11111111
11111111
NAME stair room with people (12,11)

TIL p7
11111111
11111111
11111111
11111111
11111111
01111111
01111111
01111111
NAME stair room with people (13,11)

TIL p8
11111111
11111111
11111111
11111111
11111111
01010110
01010101
01001010
NAME stair room with people (0,12)

TIL p9
11111111
11111111
11111111
11111111
11111111
10010001
01001010
10100100
NAME stair room with people (1,12)

TIL pa
11111111
11111111
11111111
11111111
11111111
10101101
01010010
00101000
NAME stair room with people (2,12)

TIL pb
11111111
11111111
11111111
11111111
11111111
00010000
00001000
01000000
NAME stair room with people (3,12)

TIL pc
11111111
11111111
11111111
11110100
01001001
00100010
10001000
00000000
NAME stair room with people (4,12)

TIL pd
11111111
11111111
11101001
00010100
01010010
00001001
01000100
00010010
NAME stair room with people (5,12)

TIL pe
11111111
01011111
01011111
10111111
00111111
01011111
01100010
01101010
NAME stair room with people (6,12)

TIL pf
11111111
11111111
11111111
11111111
11111111
11111111
00010001
11001010
NAME stair room with people (7,12)

TIL pg
11111111
11111111
11111111
11111111
11111111
11111111
00001010
10101001
NAME stair room with people (8,12)

TIL ph
11111111
11111101
11111011
11110011
11110111
11000111
01010011
01000111
NAME stair room with people (9,12)

TIL pi
11000111
11000011
11000001
11100001
11110011
11111111
11111111
11111111
NAME stair room with people (10,12)

TIL pj
11111101
11111100
11111111
11111111
11111111
11111110
11111110
11111110
NAME stair room with people (12,12)

TIL pk
00111111
00001011
00011101
00011111
00011111
00111111
00111111
10111111
NAME stair room with people (13,12)

TIL pl
11111111
11111111
10111111
01101111
11010010
11101010
11100100
11110010
NAME stair room with people (14,12)

TIL pm
11111111
11111111
11111111
11111111
10100101
10101010
10110110
01011010
NAME stair room with people (15,12)

TIL pn
01010010
01010101
10101010
01011101
10101010
01110110
11111111
11111111
NAME stair room with people (0,13)

TIL po
01010010
01010100
10101010
01010101
10101010
10101010
11111111
11111111
NAME stair room with people (1,13)

TIL pp
10000101
10101000
01000101
00101010
10100100
10101001
11011010
11111111
NAME stair room with people (2,13)

TIL pq
00010000
01000101
00010000
10100101
01010010
00101001
10100101
11111111
NAME stair room with people (3,13)

TIL pr
01001000
00000010
10101000
00010010
01001000
00100101
01010101
11111111
NAME stair room with people (4,13)

TIL ps
00000001
10101010
00000000
10100101
01001010
00100101
01011011
11111111
NAME stair room with people (5,13)

TIL pt
01001001
11100100
10010101
11001010
10101010
10010101
10101010
01010101
NAME stair room with people (6,13)

TIL pu
00101010
10101001
01010101
10100100
10010101
01010101
10101001
01010101
NAME stair room with people (7,13)

TIL pv
10100101
00010101
01010101
10101010
01001010
00101001
01010101
01010101
NAME stair room with people (8,13)

TIL pw
01011011
00110111
01011011
10011111
10101011
00101111
01011111
01011111
NAME stair room with people (9,13)

TIL px
11111101
11111110
11111001
11111100
11111111
11111111
11111111
11111111
NAME stair room with people (11,13)

TIL py
11111111
01111111
11111111
01111111
11111111
11111111
11111111
11111111
NAME stair room with people (12,13)

TIL pz
11101010
11110101
11101010
11010101
10101010
11111111
11111111
11111111
NAME stair room with people (14,13)

TIL q0
10001011
01010100
10101011
01010101
10101101
11111111
11111111
11111111
NAME stair room with people (15,13)

TIL q1
10101010
10110101
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (6,14)

TIL q2
10101010
01010101
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (7,14)

TIL q3
10101010
01011011
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (8,14)

TIL q4
10101111
11011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (9,14)

TIL q5
11111111
11111111
11111111
11111111
11111111
10101010
10101010
11111111
NAME stair room with people (6,15)

TIL q6
11111111
11111111
11111111
11111111
11111111
10101010
11011011
11111111
NAME stair room with people (7,15)

TIL q7
11111111
11111111
11111111
11111111
11111111
10101010
01101111
11111111
NAME stair room with people (8,15)

TIL q8
11111111
11111111
11111111
11111111
11111111
11111111
01011011
11111111
NAME stair room with people (9,15)

TIL q9
01001001
00100100
10001000
00100101
10010000
00100101
10001000
00100100
NAME stair room with people (0,0)

TIL qa
00100100
10010010
01000100
00010010
10100100
00010001
10001010
01010001
NAME stair room with people (1,0)

TIL qb
10010010
01001001
00100010
10001001
01010010
00001000
01010010
00001001
NAME stair room with people (2,0)

TIL qc
01001001
00100100
00010001
01000100
00101001
10000100
01010010
00001000
NAME stair room with people (3,0)

TIL qd
00100100
10010010
00001000
10100010
00010100
01000010
10010100
01000010
NAME stair room with people (4,0)

TIL qe
10010010
01001001
10000100
01010001
10001010
00100001
10010100
01000010
NAME stair room with people (5,0)

TIL qf
01001001
00100100
01000010
00101000
01000101
00010000
10100101
00010000
NAME stair room with people (6,0)

TIL qg
00100100
10010010
00100001
10010100
00100010
10001000
00100101
10010000
NAME stair room with people (7,0)

TIL qh
10010010
01001001
00010000
01001010
10010001
01000100
00101001
10000100
NAME stair room with people (8,0)

TIL qi
01001001
00100100
10001000
00100101
01001000
00100010
01001001
00100100
NAME stair room with people (9,0)

TIL qj
00100100
10010010
01000100
00010010
10100100
00010001
01001010
00100001
NAME stair room with people (10,0)

TIL qk
10010010
00100100
10010001
00100100
10001001
00100100
10010010
00100001
NAME stair room with people (0,1)

TIL ql
10001000
01000101
00101000
10000100
00101010
10000000
01010101
00001000
NAME stair room with people (1,1)

TIL qm
10100100
00010010
10001000
01010010
10001001
01000100
00101001
10010101
NAME stair room with people (2,1)

TIL qn
10100101
00010000
10100101
00010000
01001010
00100001
01010100
00000010
NAME stair room with people (3,1)

TIL qo
00101001
10000100
00101001
10000100
01010010
00001001
10100100
00010010
NAME stair room with people (4,1)

TIL qp
00101001
10000100
00101001
10000100
01010010
00001000
01010010
10001000
NAME stair room with people (5,1)

TIL qq
01001010
00100001
01001010
00100001
10010100
01000010
10101001
00000100
NAME stair room with people (6,1)

TIL qr
01001010
00100001
01001010
00100001
10010100
01000010
00010100
10100010
NAME stair room with people (7,1)

TIL qs
01010010
00001000
01010010
00001000
10100101
00010000
10101010
00000001
NAME stair room with people (8,1)

TIL qt
10010010
01001000
10010010
01001000
00100101
10010000
01000101
00101000
NAME stair room with people (9,1)

TIL qu
10010100
01000010
10010100
01000010
00101001
10000100
00101010
10000000
NAME stair room with people (10,1)

TIL qv
10100100
00010010
10100100
00010010
01001001
00100100
10010001
01001010
NAME stair room with people (11,1)

TIL qw
10100101
00010000
10100101
00010000
01001010
00100001
01001010
00100000
NAME stair room with people (12,1)

TIL qx
10010100
00100010
10001001
00100100
10010010
00100100
10010001
00100100
NAME stair room with people (0,2)

TIL qy
10100101
00010000
01001010
00100001
10010100
01000010
00101001
10000100
NAME stair room with people (1,2)

TIL qz
11011111
10111111
11011101
11111111
11111111
11111110
10111101
11101110
NAME stair room with people (2,2)

TIL r0
10101001
10000100
11010010
10110100
10101101
10011110
01000011
10101001
NAME stair room with people (3,2)

TIL r1
01001000
00100101
10010000
01001010
00100001
10010100
01000010
11101001
NAME stair room with people (4,2)

TIL r2
01000101
00101000
10000101
01010000
00001010
10100001
00010100
01001010
NAME stair room with people (5,2)

TIL r3
01010010
10001001
01010100
00000010
10101000
00010101
10100000
00010101
NAME stair room with people (6,2)

TIL r4
00010001
01001010
00100011
10010000
01001010
00100001
10010100
01000010
NAME stair room with people (7,2)

TIL r5
01010100
00101010
10111001
10011110
01011110
01101111
10100111
00111011
NAME stair room with people (8,2)

TIL r6
10000100
01010010
00001001
01010111
10001001
01000100
10101010
11010001
NAME stair room with people (9,2)

TIL r7
01010101
10001000
01010101
10000000
01110101
10111010
01001110
01000011
NAME stair room with people (10,2)

TIL r8
00100001
10010100
01000010
00101001
01000100
00100010
10010100
10100010
NAME stair room with people (11,2)

TIL r9
00010101
10100010
00010101
01000000
00101010
10000100
01010010
10001000
NAME stair room with people (12,2)

TIL ra
01001000
00100101
01010000
00001010
10100001
01010100
10000010
01010101
NAME stair room with people (13,2)

TIL rb
01010010
10001001
01010100
00000010
10101001
00010100
10100010
00010001
NAME stair room with people (15,2)

TIL rc
10001001
00100100
10010010
00100001
10010100
00100010
10001001
00100100
NAME stair room with people (0,3)

TIL rd
00101010
10000001
01010100
00001010
10100000
00010101
01000010
00101000
NAME stair room with people (1,3)

TIL re
00010001
01001010
00100000
10010101
01001001
00100100
10010010
01001001
NAME stair room with people (2,3)

TIL rf
00000100
10101010
00010000
01001010
00100001
10010100
01000010
00101001
NAME stair room with people (3,3)

TIL rg
00110100
10011110
01000111
10101001
00000100
10101010
00010001
01001000
NAME stair room with people (4,3)

TIL rh
00100001
10110100
10001011
10100100
11110010
00111100
01001111
00100101
NAME stair room with people (5,3)

TIL ri
01000000
00101010
01000101
00101000
10000101
01010001
00101000
10000101
NAME stair room with people (6,3)

TIL rj
10101010
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (7,3)

TIL rk
10001101
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (8,3)

TIL rl
11111101
11111111
11111111
11111111
11111111
11111111
11011111
11101111
NAME stair room with people (9,3)

TIL rm
01011000
11111010
11111010
11111101
11111111
11111001
11111110
11111101
NAME stair room with people (10,3)

TIL rn
11111000
11111111
11111111
10101010
10101111
01010000
10001010
01100001
NAME stair room with people (11,3)

TIL ro
01101011
01111111
11111111
11101111
11111011
11111110
00110011
01001000
NAME stair room with people (12,3)

TIL rp
01000000
11110101
11100010
11111001
11110100
10001010
11101001
11110101
NAME stair room with people (13,3)

TIL rq
00100001
01010100
00000010
01010100
00100010
10010100
01000010
01010100
NAME stair room with people (14,3)

TIL rr
01001000
00100101
10010000
01001010
10100001
00010100
10100010
00010100
NAME stair room with people (15,3)

TIL rs
10000101
01010010
00001000
10100101
00010000
10101010
00000001
01010100
NAME stair room with people (1,4)

TIL rt
00100100
10010010
01001001
00100100
10010001
01001010
00100000
10010101
NAME stair room with people (2,4)

TIL ru
10000100
01010010
00001000
01010101
00000000
10101010
00010001
01001010
NAME stair room with people (3,4)

TIL rv
00100101
10010001
10101010
00000000
10101010
00010001
01001010
00100001
NAME stair room with people (4,4)

TIL rw
01010010
00001001
10100100
00010110
10101011
00000110
01010011
00101011
NAME stair room with people (5,4)

TIL rx
11110010
00111000
10011111
01001011
00100101
10010010
01001000
10100101
NAME stair room with people (6,4)

TIL ry
11111111
01111111
00011111
10101111
10100111
11110001
00111101
11001110
NAME stair room with people (7,4)

TIL rz
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11111110
NAME stair room with people (8,4)

TIL s0
11110111
11111111
11111111
11111111
11111111
11111111
10011111
11001110
NAME stair room with people (9,4)

TIL s1
11111111
11111111
11111111
11111110
11111110
11111100
01111010
10101000
NAME stair room with people (10,4)

TIL s2
10010100
11001010
10100001
00010100
10100010
01010101
10000000
01010100
NAME stair room with people (11,4)

TIL s3
10010101
01000000
00101010
10000101
01010000
00001010
10100001
01010100
NAME stair room with people (12,4)

TIL s4
00011110
10101111
00000001
01010100
01001010
10100000
00110101
11000010
NAME stair room with people (13,4)

TIL s5
11101010
01011010
10111001
01110100
10011010
01000001
00101010
10000101
NAME stair room with people (14,4)

TIL s6
10100010
10010001
00101010
10000000
01010101
00000010
01010100
00100010
NAME stair room with people (15,4)

TIL s7
10010100
00100010
10001000
00100101
10010000
00100101
10010000
00100101
NAME stair room with people (0,5)

TIL s8
00001010
10100001
01010100
00000010
10101001
00010101
10100011
00010001
NAME stair room with people (1,5)

TIL s9
01000000
00101010
10000101
01010101
00001011
10100010
10010101
01000000
NAME stair room with people (2,5)

TIL sa
10100001
00010100
01000010
00101000
10000101
11110000
11101010
00111100
NAME stair room with people (3,5)

TIL sb
01010100
00000010
10101001
10010100
01000010
00101001
10000100
01010010
NAME stair room with people (4,5)

TIL sc
10000000
01010101
00001000
10100101
00010000
01001010
00100001
10010100
NAME stair room with people (5,5)

TIL sd
10010000
01001010
10100010
00101001
10100100
00010010
01001000
10100101
NAME stair room with people (6,5)

TIL se
01101111
10111111
01111111
01011101
10101011
10010011
01001011
00100101
NAME stair room with people (7,5)

TIL sf
11111111
11101111
11110111
11110110
11111111
11110010
11101101
10011100
NAME stair room with people (8,5)

TIL sg
11110111
11101011
11100101
00100010
01010100
00100010
01010101
10100000
NAME stair room with people (9,5)

TIL sh
01011010
10001100
11010111
11000001
11110101
01101010
00110001
10111101
NAME stair room with people (10,5)

TIL si
10000010
01010100
00001010
01010001
10100100
11010010
01101010
10111010
NAME stair room with people (11,5)

TIL sj
10001010
10101110
00100101
01010010
10101001
10000100
10101010
00100000
NAME stair room with people (12,5)

TIL sk
10101000
00000101
01010010
00101000
01000101
00100000
10010101
01000100
NAME stair room with people (13,5)

TIL sl
01010000
00001010
10100101
00010000
01001010
10100001
00010100
10001010
NAME stair room with people (14,5)

TIL sm
10010001
01001010
00100001
10010100
01000010
00010100
10100010
00010001
NAME stair room with people (15,5)

TIL sn
10010000
00001010
10100001
00010100
10100010
00010101
01000000
00101010
NAME stair room with people (0,6)

TIL so
10001010
01010001
00001000
10100101
00010001
01001010
00100000
10010101
NAME stair room with people (1,6)

TIL sp
00101010
01000100
00101010
01000000
00101010
10000100
01010010
00110100
NAME stair room with people (2,6)

TIL sq
10101111
00010111
10100001
01010100
10010010
01010001
10101010
00000001
NAME stair room with people (3,6)

TIL sr
00101000
10000101
11101000
11100101
00111000
01001110
00101011
01000101
NAME stair room with people (4,6)

TIL ss
01000010
00101001
10000100
01010010
00001000
10100101
01010110
10101110
NAME stair room with people (5,6)

TIL st
00010010
01001010
00100011
10010100
01000010
00101001
10000100
01010010
NAME stair room with people (6,6)

TIL su
10010111
01001011
00101111
10010111
11001111
01101110
11011111
01101110
NAME stair room with people (7,6)

TIL sv
11001010
10101001
01010100
00000010
10110101
01000000
00101010
10100100
NAME stair room with people (8,6)

TIL sw
00010101
01000000
10101010
00000101
01010000
00101010
10000010
10101011
NAME stair room with people (9,6)

TIL sx
00010100
10011110
01000101
00110100
10011010
01100001
11010100
11101010
NAME stair room with people (10,6)

TIL sy
11011001
01101100
00100111
10010001
01001110
00100010
10010101
01000010
NAME stair room with people (11,6)

TIL sz
01010101
00000010
01010100
01000010
10101011
11010101
01101111
10111111
NAME stair room with people (12,6)

TIL t0
00101001
10100100
10010010
10101000
00100101
10010000
10101010
10000101
NAME stair room with people (13,6)

TIL t1
01010001
00001000
10100101
01010000
00001010
10100001
00010100
01000010
NAME stair room with people (14,6)

TIL t2
01001010
00100001
01010100
10000010
01010100
00000010
10101001
00010100
NAME stair room with people (15,6)

TIL t3
10000100
01010010
00001000
10100101
00010000
10001101
01010110
00001101
NAME stair room with people (0,7)

TIL t4
01000010
10101000
00000101
01010010
10001000
00100101
01010000
00001010
NAME stair room with people (1,7)

TIL t5
10010010
01001000
00100101
10010000
01001010
00100001
10010100
01000010
NAME stair room with people (2,7)

TIL t6
10101010
01000101
00101000
10000101
01010000
00001010
10100001
00010100
NAME stair room with people (3,7)

TIL t7
00101001
01000100
00100010
01010101
00000000
10101010
00010001
10101010
NAME stair room with people (4,7)

TIL t8
01100111
10111011
01011111
00100101
10010101
01000010
00101000
10000101
NAME stair room with people (5,7)

TIL t9
10001001
01010100
00000010
10101001
10100100
11101010
10110101
01011100
NAME stair room with people (6,7)

TIL ta
01111101
10111100
00111110
01011101
01111100
00111101
01111010
11110111
NAME stair room with people (7,7)

TIL tb
01010010
10001001
01010100
00000010
10101000
00010101
10100001
00010111
NAME stair room with people (8,7)

TIL tc
00010111
01001111
00111110
10111010
10111001
01110100
11101010
11000001
NAME stair room with people (9,7)

TIL td
11000001
00101010
10010000
01001010
00100000
10010101
01000010
00101000
NAME stair room with people (10,7)

TIL te
00101000
10000101
01010010
10001001
01010101
00010010
10101001
00001010
NAME stair room with people (11,7)

TIL tf
01010111
00010101
10101010
01010111
00101010
10011111
01001111
10111111
NAME stair room with people (12,7)

TIL tg
10101000
10010010
10101001
10000100
10101001
10010010
10101001
10000100
NAME stair room with people (13,7)

TIL th
00101001
10010100
01000010
00101000
01000101
00101000
00000101
10101000
NAME stair room with people (14,7)

TIL ti
01000010
00101001
10010100
01000010
00101001
10000100
01010010
00001001
NAME stair room with people (15,7)

TIL tj
10100111
00011011
10101101
00001011
01010111
00101011
10001101
01010101
NAME stair room with people (0,8)

TIL tk
01100001
11010100
11000010
11101001
11010100
11101010
11111001
11101100
NAME stair room with people (1,8)

TIL tl
00101001
10000100
01010010
00001000
10100101
00010000
01001010
00100001
NAME stair room with people (2,8)

TIL tm
01001010
00100001
10010100
01000010
00101001
10010100
01000010
00101000
NAME stair room with people (3,8)

TIL tn
00000000
01010101
00100010
10010100
01000010
00101000
10000101
01010010
NAME stair room with people (4,8)

TIL to
01010000
00001010
10100100
00010010
10101000
01000101
00100000
10010101
NAME stair room with people (5,8)

TIL tp
00101111
10010011
01001001
10100101
00010001
01001010
10100011
00010101
NAME stair room with people (6,8)

TIL tq
01101011
11100101
11110101
11111010
11011101
11000111
11010111
10010101
NAME stair room with people (7,8)

TIL tr
10100111
10010111
11011110
11111100
01111010
11111001
11111010
11111100
NAME stair room with people (8,8)

TIL ts
10101010
00010000
10101010
00010000
11111101
01111010
11110100
00001010
NAME stair room with people (9,8)

TIL tt
10000101
01010010
10001001
01010100
00000010
10101000
00010101
10100000
NAME stair room with people (10,8)

TIL tu
01011011
00111111
01011011
00111101
10001111
01010111
00001011
10100101
NAME stair room with people (11,8)

TIL tv
11011111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (12,8)

TIL tw
10101001
10010010
11001001
10100100
10010010
11001000
10100100
10010010
NAME stair room with people (13,8)

TIL tx
00010010
01001001
00100100
10010010
01001001
10000100
01010010
10010000
NAME stair room with people (14,8)

TIL ty
10100100
00010010
10101001
00000100
01010010
00101000
10000101
01010000
NAME stair room with people (15,8)

TIL tz
00001110
10101110
00010111
10001011
01010111
00000011
10101001
00010101
NAME stair room with people (0,9)

TIL u0
11111010
11111000
01111010
01111100
10111110
10111110
11110111
11001010
NAME stair room with people (1,9)

TIL u1
10010100
01000101
10101000
00000101
10101000
01000100
00101010
10001101
NAME stair room with people (2,9)

TIL u2
10000101
01010000
00001010
01010001
10001010
01010000
10001010
00100001
NAME stair room with people (3,9)

TIL u3
00001000
10101010
01010000
00010101
10100010
00010100
10100010
00010001
NAME stair room with people (4,9)

TIL u4
01000010
10010101
01000000
00101010
10000101
01010000
00001010
01010001
NAME stair room with people (5,9)

TIL u5
01000111
00101011
10010111
01001111
00100110
10011111
01001111
00011111
NAME stair room with people (6,9)

TIL u6
10101111
01010110
10111010
01111001
11110100
11100010
11101000
11010101
NAME stair room with people (7,9)

TIL u7
11111101
01111100
00111110
01011111
10110111
11010011
00101011
01000001
NAME stair room with people (8,9)

TIL u8
01010000
10001010
01010001
00101010
10111101
11111101
11110111
11110001
NAME stair room with people (9,9)

TIL u9
01001010
10100001
00010100
01000010
01110101
11011000
11111111
10101111
NAME stair room with people (10,9)

TIL ua
01010101
00001000
10100111
00010111
01011011
01000111
01010010
10101001
NAME stair room with people (11,9)

TIL ub
01111111
11111111
11111111
11111111
11111111
11111111
11111111
01111111
NAME stair room with people (12,9)

TIL uc
11001000
10100101
10010000
11001010
10100001
10010100
10000010
01010100
NAME stair room with people (13,9)

TIL ud
01011010
00001001
10100100
00010010
01001001
00100100
10010010
01001001
NAME stair room with people (14,9)

TIL ue
10001010
00100001
10010100
01000010
00101001
10000100
01010010
00001001
NAME stair room with people (15,9)

TIL uf
10000000
01010101
00001000
10100101
00010000
10100101
00010010
10001001
NAME stair room with people (0,10)

TIL ug
11100101
01110010
10110101
01111000
00111100
01011101
00101100
01010110
NAME stair room with people (1,10)

TIL uh
01000111
00101111
00010111
10100111
01001011
00100111
10010111
01001111
NAME stair room with people (2,10)

TIL ui
01010100
10000010
11010101
11001000
11100101
11110000
11111010
11111001
NAME stair room with people (3,10)

TIL uj
10101010
00000001
01010100
00100010
01010100
00000010
10101000
00010101
NAME stair room with people (4,10)

TIL uk
00101010
01000001
00101010
10000001
01010100
10001010
01010000
00001011
NAME stair room with people (5,10)

TIL ul
01011111
00101110
01011001
01111100
00111010
11110100
01110010
01111001
NAME stair room with people (6,10)

TIL um
00101000
10011101
01010100
00001010
10100001
01010100
10000010
00101001
NAME stair room with people (7,10)

TIL un
10101011
00000101
10101011
00001111
01010110
10001010
01010000
00001010
NAME stair room with people (8,10)

TIL uo
11111011
11111011
11011011
10100110
01010111
10010111
01011100
10101101
NAME stair room with people (9,10)

TIL up
11110101
11101010
01101001
10010100
10100010
10010000
10101010
00000100
NAME stair room with people (10,10)

TIL uq
11100100
11111010
01111101
00101111
10101011
01100101
10110010
01101001
NAME stair room with people (11,10)

TIL ur
10011111
01001011
00100101
01010010
11001001
11110100
01111101
00011110
NAME stair room with people (12,10)

TIL us
10010010
10101000
10000101
01010000
00101010
10000001
01010100
00001010
NAME stair room with people (13,10)

TIL ut
10100100
00010001
01001010
10100000
00010101
01000000
00101010
10000101
NAME stair room with people (14,10)

TIL uu
01010100
00000010
10101001
00010100
01000010
10101000
00000101
01010000
NAME stair room with people (15,10)

TIL uv
01010010
00001001
10100100
00010010
10001000
01010010
00001000
10100101
NAME stair room with people (0,11)

TIL uw
00001111
01010111
00000011
10101011
01000101
10101001
00000100
01010010
NAME stair room with people (1,11)

TIL ux
00100111
01010111
00101011
10100111
11010111
11001011
11100111
01110001
NAME stair room with people (2,11)

TIL uy
11111110
11111111
11111111
11111111
11111110
11111111
01111111
11111111
NAME stair room with people (3,11)

TIL uz
10100000
10010101
11000010
10101001
01001000
00100101
10010010
11001110
NAME stair room with people (4,11)

TIL v0
10101101
00011110
01111101
00101010
10010011
01001001
00100111
10010011
NAME stair room with people (5,11)

TIL v1
11100110
11101010
11010001
11001010
11100000
10010101
11001000
10100101
NAME stair room with people (6,11)

TIL v2
10010100
01000010
00101110
10001101
01011100
00111010
10010101
01001000
NAME stair room with people (7,11)

TIL v3
10100010
00010101
10100000
00010101
10101010
00000101
01010100
10000111
NAME stair room with people (8,11)

TIL v4
00011010
01001000
00111110
01011000
00101010
01110101
00101001
01110100
NAME stair room with people (9,11)

TIL v5
10101010
01000000
10101010
10010000
01001111
01010111
00101111
10111011
NAME stair room with people (10,11)

TIL v6
10100100
01101010
10111111
01111111
01111111
00111111
11101111
11010111
NAME stair room with people (11,11)

TIL v7
10100111
11010101
01010010
10101001
11110100
11111110
11111101
10111110
NAME stair room with people (12,11)

TIL v8
11010000
11100101
11110100
00111010
10001111
01010101
00000010
10101001
NAME stair room with people (13,11)

TIL v9
01010000
00101010
10000001
01010100
00001010
11100000
11111010
01111001
NAME stair room with people (14,11)

TIL va
00101010
10000001
01010100
00001010
10100001
01010100
10000010
00101001
NAME stair room with people (15,11)

TIL vb
00010000
10001010
01010001
00001000
10100101
00010000
10001010
01010101
NAME stair room with people (0,12)

TIL vc
10001001
01010100
00000010
10101001
00010100
10100010
00010001
01001010
NAME stair room with people (1,12)

TIL vd
01110100
10111111
01011011
00111111
10011111
01001111
00101111
01000111
NAME stair room with people (2,12)

TIL ve
01111111
01011111
01101011
10101011
11110011
11110101
11011011
11111111
NAME stair room with people (3,12)

TIL vf
10101010
11011110
11111100
11111010
11111100
11111101
10011100
01001101
NAME stair room with people (4,12)

TIL vg
01001011
10100111
00010111
10101110
01001110
00101110
10011101
01011100
NAME stair room with people (5,12)

TIL vh
00010000
10101010
00000001
10101010
01010001
10010100
01001010
00100001
NAME stair room with people (6,12)

TIL vi
00110101
10010010
01011001
00101000
00010101
10100001
00010100
01000010
NAME stair room with people (7,12)

TIL vj
01010010
00001101
01010111
00101111
01000111
00101111
10001111
01000111
NAME stair room with people (8,12)

TIL vk
11111110
11111110
01011111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (9,12)

TIL vl
11110101
11111010
10111101
10101011
10101111
11011111
11101111
11111111
NAME stair room with people (10,12)

TIL vm
11101001
11110100
11101010
01101101
11110101
11101010
11101101
11110100
NAME stair room with people (11,12)

TIL vn
01011111
10110011
11010101
01010010
01101000
11110101
10000100
01010011
NAME stair room with people (12,12)

TIL vo
00101110
01000110
00101001
10000100
01010010
00001001
10100100
00010010
NAME stair room with people (13,12)

TIL vp
10010100
01010010
00001001
10100100
01010010
00001001
10100100
00010010
NAME stair room with people (14,12)

TIL vq
10010100
01000010
00101001
10000100
01010010
00001001
10100100
00010010
NAME stair room with people (15,12)

TIL vr
00001000
10100101
00010000
10101010
00000001
01010100
00100010
10010101
NAME stair room with people (0,13)

TIL vs
00100001
01001000
10110110
01011011
00000110
10101000
00010010
01001000
NAME stair room with people (1,13)

TIL vt
00101011
10001111
01000111
00101011
10000101
01010111
10001111
01011110
NAME stair room with people (2,13)

TIL vu
11011110
11111101
11111100
11110011
11101001
11110100
01111101
10111110
NAME stair room with people (3,13)

TIL vv
00100010
01010101
10000101
01010010
11001001
10110100
01111010
11011000
NAME stair room with people (4,13)

TIL vw
10011101
00111010
01011101
01111010
00110100
11111010
01110001
11101001
NAME stair room with people (5,13)

TIL vx
01010100
00000010
01010100
10100010
01010100
10100010
01010000
01001010
NAME stair room with people (6,13)

TIL vy
00101001
10010100
01000010
10101001
00000100
10101001
01000100
10100010
NAME stair room with people (7,13)

TIL vz
00101111
10001111
01001111
00100111
10010111
00101111
10010111
01010111
NAME stair room with people (8,13)

TIL w0
11110101
11111011
11111111
11111111
11111111
11111111
11111111
11111111
NAME stair room with people (11,13)

TIL w1
10111101
11111101
11111110
11111110
11111010
11111111
11111111
11111111
NAME stair room with people (12,13)

TIL w2
01001001
00100100
10010010
10001000
01010101
00100000
10010101
01000010
NAME stair room with people (13,13)

TIL w3
01001001
00100100
10010010
01001000
00100101
10010000
01001010
00100001
NAME stair room with people (14,13)

TIL w4
01001000
00100101
10010000
01001010
00100001
10010100
01000010
00101001
NAME stair room with people (15,13)

TIL w5
01000000
00101010
10000001
00101010
10001001
00100100
10010010
00100100
NAME stair room with people (0,14)

TIL w6
00100101
10010000
01001010
00100001
00010111
10100111
00010111
10101110
NAME stair room with people (1,14)

TIL w7
00111100
11111010
11110001
10101010
11000001
10101100
00010101
10100010
NAME stair room with people (2,14)

TIL w8
01111111
10111111
00011101
10101110
01001111
00100111
01010011
00001011
NAME stair room with people (3,14)

TIL w9
11010111
11010101
11101110
01111010
00111111
01011111
00000111
11010111
NAME stair room with people (4,14)

TIL wa
01100100
11110011
11001001
11100100
11010010
10001011
11010101
11010110
NAME stair room with people (5,14)

TIL wb
10100100
01010110
00011100
10101110
00111000
01011101
01110100
10110010
NAME stair room with people (6,14)

TIL wc
00010100
10100010
01001011
10100110
00011110
01011001
10101010
00101000
NAME stair room with people (7,14)

TIL wd
10101111
10100111
10010111
10101111
01001111
00100111
10010111
01001111
NAME stair room with people (8,14)

TIL we
10101001
10000100
01010010
00101001
01000100
00100010
10010100
01000010
NAME stair room with people (13,14)

TIL wf
00010100
10100010
00011001
01001000
00110101
10111000
00111010
10110101
NAME stair room with people (14,14)

TIL wg
10000100
01010011
00001011
10100111
00011111
10101110
01111100
01110010
NAME stair room with people (15,14)

TIL wh
10010010
00100001
10001010
00100101
10010011
00100110
10010110
00101110
NAME stair room with people (0,15)

TIL wi
00111100
01111010
11110001
11101010
10100010
10010111
01001101
00100100
NAME stair room with people (1,15)

TIL wj
00010001
10101010
00000001
10101010
00010001
01001010
00100001
10010100
NAME stair room with people (2,15)

TIL wk
01011101
00101101
01010110
00001111
01010111
00100011
01001011
00100011
NAME stair room with people (3,15)

TIL wl
11001110
11101111
11101110
01111101
10111110
10111101
11111011
11111111
NAME stair room with people (4,15)

TIL wm
11110101
01111111
00111111
10001111
11110111
11111001
00111111
10001111
NAME stair room with people (5,15)

TIL wn
11111001
01110100
11110010
11111101
11111110
11111111
11111111
11111111
NAME stair room with people (6,15)

TIL wo
01000101
00101000
10000101
01010000
10001010
01010001
10001010
11010001
NAME stair room with people (7,15)

TIL wp
00100111
10010111
01001111
10100111
01010111
00001111
10101111
10000111
NAME stair room with people (8,15)

TIL wq
00101000
10000101
01010010
00001001
10100100
00010010
10101001
00000101
NAME stair room with people (13,15)

TIL wr
01110000
01110101
01110111
01101011
11101111
11100100
11010101
11011000
NAME stair room with people (14,15)

TIL ws
11110100
11001010
11010001
10001000
01010101
00000000
01010101
10001000
NAME stair room with people (15,15)

TIL wt
11111111
11111111
11111111
11111111
11111111
01111111
01111111
01110111
NAME Hand Radio (1,0)

TIL wu
11111111
11111111
11111110
11111110
11111110
11111110
11111110
11111111
NAME Hand Radio (4,0)

TIL wv
11111111
11111111
10111111
10110111
11111111
11011111
00101111
10111111
NAME Hand Radio (5,0)

TIL ww
11111111
11111110
11111110
11111110
11111100
11111100
11111000
11110000
NAME Hand Radio (10,0)

TIL wx
11111111
01111111
00111111
00011111
00011111
00011111
00011111
00111111
NAME Hand Radio (11,0)

TIL wy
11111111
11101111
10010101
00010101
01001000
10001010
10010000
00100100
NAME Hand Radio (13,0)

TIL wz
11111111
11111111
01010101
01010101
10101010
10101010
00010101
00000000
NAME Hand Radio (14,0)

TIL x0
11111111
11111111
11011110
01101111
10110001
11011101
11011110
00100011
NAME Hand Radio (15,0)

TIL x1
01111111
11111111
11111111
11111011
11111011
11111111
11111111
11111111
NAME Hand Radio (1,1)

TIL x2
10111111
00001111
11011111
11111111
01101111
00011111
10011111
10111111
NAME Hand Radio (5,1)

TIL x3
11110000
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (10,1)

TIL x4
00000100
10010101
00100100
00100100
00001001
00001000
00100000
00100100
NAME Hand Radio (13,1)

TIL x5
00000000
01000000
00001010
00010010
00000010
00000000
00010000
10010000
NAME Hand Radio (14,1)

TIL x6
01101101
01111110
10110011
10101111
10111101
00110110
01000111
01101111
NAME Hand Radio (15,1)

TIL x7
11111110
11111111
11111111
11111111
11111110
11111100
11111110
11111110
NAME Hand Radio (4,2)

TIL x8
00111111
01111111
11101111
10111111
00111111
00011111
11011111
11111111
NAME Hand Radio (5,2)

TIL x9
11111110
11111100
11111100
11111110
11111110
11111100
11111100
11111100
NAME Hand Radio (10,2)

TIL xa
01111111
00111111
00111111
00111111
00011111
00011111
00011111
00111111
NAME Hand Radio (11,2)

TIL xb
00010101
00000000
00000010
00000100
00000100
00000000
00000010
00001000
NAME Hand Radio (13,2)

TIL xc
01000101
01000000
00000101
00100001
10001000
01000001
00100101
00100010
NAME Hand Radio (14,2)

TIL xd
01101100
10001110
01011111
01010111
10101011
01011010
01010111
10111011
NAME Hand Radio (15,2)

TIL xe
11111100
11111110
11111110
11111010
11111011
11011011
11111010
11110101
NAME Hand Radio (4,3)

TIL xf
10111111
11111111
11111111
10111111
01111111
01111111
01111111
11111111
NAME Hand Radio (5,3)

TIL xg
11111000
11111001
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (10,3)

TIL xh
00000001
00000100
00010000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (13,3)

TIL xi
01000010
01000010
00000001
00010000
00000100
00100000
00000000
00000000
NAME Hand Radio (14,3)

TIL xj
10110101
10101010
01010101
10101110
10101101
01010101
10101010
01010101
NAME Hand Radio (15,3)

TIL xk
11110001
10000001
11010111
11010110
10100111
10110111
01110111
01001111
NAME Hand Radio (4,4)

TIL xl
11111111
11111111
11111110
11111110
11111110
11111100
11111100
11111000
NAME Hand Radio (10,4)

TIL xm
11111111
01111111
01111111
00011111
00011111
00001111
00001111
00011111
NAME Hand Radio (11,4)

TIL xn
11111111
11111111
11111110
11111111
11111111
11111111
11111110
11111111
NAME Hand Radio (12,4)

TIL xp
10000100
10000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (14,4)

TIL xq
10101010
00010101
00100010
10100000
10100000
00101000
00101000
01000000
NAME Hand Radio (15,4)

TIL xr
11111011
11111111
11111101
11111010
11111011
11110111
10110111
11001111
NAME Hand Radio (3,5)

TIL xs
01111111
01111111
01111111
01111111
01111111
11111111
11111111
11111111
NAME Hand Radio (4,5)

TIL xt
11111100
11111000
11111101
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (10,5)

TIL xu
00011111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (11,5)

TIL xv
11111110
11111111
11111111
11111110
11111111
11111111
11111111
11111110
NAME Hand Radio (12,5)

TIL xw
01000000
01000100
00001000
00001000
00001000
10001010
00010000
00010000
NAME Hand Radio (15,5)

TIL xx
11111111
11111110
11111111
11111111
11111100
11111110
11111110
11110010
NAME Hand Radio (2,6)

TIL xy
11101111
01101111
01001111
01101111
11101111
10111111
11111111
01111111
NAME Hand Radio (3,6)

TIL xz
11111110
11111110
11111110
11111110
11111110
11111110
11111110
11111110
NAME Hand Radio (12,6)

TIL y0
00000000
00001000
00001000
00000000
00000000
00000010
00000000
00000000
NAME Hand Radio (15,6)

TIL y1
11111111
11111111
11111111
11111111
11111111
11111111
11111110
11111110
NAME Hand Radio (1,7)

TIL y2
11110111
11111011
11111011
11000011
10001111
10101111
11101111
11111111
NAME Hand Radio (2,7)

TIL y3
11111111
11111111
11111111
11111111
11111111
11111111
11001111
00001111
NAME Hand Radio (10,7)

TIL y4
11111110
11111111
11111111
11111110
11111110
11111110
11111110
11111110
NAME Hand Radio (12,7)

TIL y5
00100000
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (15,7)

TIL y6
11111111
11111111
11111110
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (1,8)

TIL y7
10111111
10111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (2,8)

TIL y8
11111111
11111111
11110110
11111100
11111100
11110000
11110000
11000000
NAME Hand Radio (6,8)

TIL y9
11111111
11111111
01111111
01111111
01111111
00111111
00111111
00111111
NAME Hand Radio (7,8)

TIL ya
11111111
11111011
11111111
11111111
11110111
11110111
11111111
11111111
NAME Hand Radio (8,8)

TIL yb
00000111
10000011
10000001
10000001
10000000
10000001
10000001
10000001
NAME Hand Radio (10,8)

TIL yc
11111111
11111111
11111111
11111111
11111111
11111111
11101111
11111011
NAME Hand Radio (0,9)

TIL yd
11111111
11111111
11111111
11111101
11111110
11110110
11111010
01011000
NAME Hand Radio (5,9)

TIL ye
11000000
11010000
01010000
00000000
10010000
10000000
10000011
00000011
NAME Hand Radio (6,9)

TIL yf
00011111
00011111
01111111
01111111
11111111
11111111
11111111
11111111
NAME Hand Radio (7,9)

TIL yg
11111111
11111111
11111111
11111111
11111110
11111111
11111111
11111111
NAME Hand Radio (9,9)

TIL yh
11000011
10000111
00000111
00001111
01111111
11111111
11111111
11111111
NAME Hand Radio (10,9)

TIL yi
11111110
11111110
11111110
11111111
11111111
11111110
11111110
11111111
NAME Hand Radio (12,9)

TIL yj
00000000
00000000
00000000
00000000
00100000
00100000
00000000
00010000
NAME Hand Radio (15,9)

TIL yk
11111100
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (0,10)

TIL yl
01111111
00111111
10111111
11000111
11000011
11110110
11111110
11111111
NAME Hand Radio (1,10)

TIL ym
11111111
11111111
11111111
11111111
11111111
01111111
00001111
11100011
NAME Hand Radio (2,10)

TIL yn
11111111
11111111
11111111
11111111
11010111
11000111
01100110
11111111
NAME Hand Radio (3,10)

TIL yo
11111110
11111100
11111100
11111110
11111111
11111111
00011111
11110101
NAME Hand Radio (4,10)

TIL yp
11010100
11000100
00010000
00000001
10000000
11110100
11111100
11111111
NAME Hand Radio (5,10)

TIL yq
10000111
10000111
00001111
00111111
00111111
00111111
00111111
10111111
NAME Hand Radio (6,10)

TIL yr
11111111
11111111
11111111
11111111
11111111
11111111
11111101
11111100
NAME Hand Radio (8,10)

TIL ys
11111011
10000001
10000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (9,10)

TIL yt
11111111
11111111
00111111
00111111
00011111
00001111
00011111
00011111
NAME Hand Radio (10,10)

TIL yu
00000000
00000000
00000000
00000000
00001000
00001000
00001001
00000001
NAME Hand Radio (13,10)

TIL yv
00000000
00000000
00000000
00000000
00000100
00010000
01000000
01000000
NAME Hand Radio (14,10)

TIL yw
01000010
01001000
00001000
00000000
00000010
01000000
01000000
01000000
NAME Hand Radio (15,10)

TIL yx
11110000
11111100
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (2,11)

TIL yy
01111111
00011111
00000111
01000011
10000010
11110010
11111010
11111100
NAME Hand Radio (3,11)

TIL yz
11111100
11111111
11111111
11111111
11111111
00111111
00011111
11000011
NAME Hand Radio (4,11)

TIL z0
01111111
00000111
11000111
11111000
11111100
11111110
11111111
11111111
NAME Hand Radio (5,11)

TIL z1
11001111
11111110
11111110
01111101
00111101
00000001
10010001
11000000
NAME Hand Radio (6,11)

TIL z2
11111111
11111111
01111110
00001110
11000000
11110001
01110000
00010000
NAME Hand Radio (7,11)

TIL z3
11111000
10111000
00000001
00000011
00001111
00001111
00011111
00011111
NAME Hand Radio (8,11)

TIL z4
00000000
00001111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (9,11)

TIL z5
01111111
11111111
11111111
11111110
11111110
11111000
11111000
11111100
NAME Hand Radio (10,11)

TIL z6
11100111
10100000
00000000
00000000
00000100
00000000
00000010
00000111
NAME Hand Radio (11,11)

TIL z7
11111111
11111111
11111111
00011111
00001111
00001111
10000000
00000000
NAME Hand Radio (12,11)

TIL z8
00000001
10100010
10001000
01010000
11000000
10000000
00000000
00000000
NAME Hand Radio (13,11)

TIL z9
01000000
10000000
10000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (14,11)

TIL za
00100010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (15,11)

TIL zb
11111111
11111111
00111111
10011111
00001111
00000111
11000000
11000000
NAME Hand Radio (0,12)

TIL zc
11111111
11111110
11111110
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (4,12)

TIL zd
11111111
01111111
01111111
00111111
10011111
11001111
11100111
11110111
NAME Hand Radio (5,12)

TIL ze
11110000
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (6,12)

TIL zf
00000000
00000000
11000000
11100000
11111000
11111110
11111111
11111111
NAME Hand Radio (7,12)

TIL zg
00000111
10000011
00000000
00000000
00000000
00000000
00000000
11111110
NAME Hand Radio (8,12)

TIL zh
11111111
11111111
01111111
00111111
00001111
00000111
00000001
00100111
NAME Hand Radio (9,12)

TIL zi
11111100
11111100
01111100
00110100
00011000
11100100
11101111
11111111
NAME Hand Radio (10,12)

TIL zj
00000111
00000000
00000000
00000000
00000000
00000000
11110110
11111111
NAME Hand Radio (11,12)

TIL zk
00000000
00001100
00001111
00000011
11000000
00110000
00000000
11000000
NAME Hand Radio (12,12)

TIL zl
00110000
00010000
11011110
01111110
00000011
00000011
00000001
00000000
NAME Hand Radio (13,12)

TIL zm
01000000
01000000
10100000
10100100
01100101
11111101
11111111
11011110
NAME Hand Radio (14,12)

TIL zn
00000000
00000000
00000000
00000000
01000000
10110111
11111110
11110111
NAME Hand Radio (15,12)

TIL zo
01000000
10000000
00010000
00000000
00000000
00000000
00000000
01000000
NAME Hand Radio (0,13)

TIL zp
01111111
00001111
00000111
00000101
00001010
00000011
00000010
00000010
NAME Hand Radio (1,13)

TIL zq
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10111111
NAME Hand Radio (2,13)

TIL zr
00000000
10000000
10110000
11110000
11100000
10100011
11000011
11110101
NAME Hand Radio (13,13)

TIL zs
10001010
00000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (14,13)

TIL zt
11010110
00010010
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (15,13)

TIL zu
10110000
11110000
11110000
11111100
11111111
11111111
11111111
11111111
NAME Hand Radio (0,14)

TIL zv
10001010
10001010
10000001
00001000
00101010
11000000
11011011
11111011
NAME Hand Radio (1,14)

TIL zw
10101111
10101111
01011111
00100111
10101111
00011111
01110111
11110011
NAME Hand Radio (2,14)

TIL zx
11111111
11111111
11111111
11111111
11111111
11111111
11110000
00000000
NAME Hand Radio (11,14)

TIL zy
11111111
11111111
11111111
11111111
11111111
11111100
00000000
00000000
NAME Hand Radio (12,14)

TIL zz
11110010
11100100
11110000
10000000
10000000
00000000
00000000
00000000
NAME Hand Radio (13,14)

TIL 10a
11111100
01000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (10,15)

TIL 10b
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100100
NAME Hand Radio (12,15)

TIL xo
11111011
10000010
10010010
00000000
00000000
10101010
10000101
10010000
NAME Hand Radio (0,0)

TIL 10c
11101111
00001000
01001001
00000000
01000000
00101010
00100101
10000001
NAME Hand Radio (1,0)

TIL 10d
10111110
00100000
00100100
00000000
01000100
00101010
01111111
01111111
NAME Hand Radio (2,0)

TIL 10e
11111011
10000010
10010010
00000000
00010000
11101011
11111111
11111111
NAME Hand Radio (3,0)

TIL 10f
11101111
00001000
01001001
00000000
01000001
10101110
11111111
11111111
NAME Hand Radio (4,0)

TIL 10g
10111110
00100000
00100001
00000100
00000000
10101001
11000101
11000000
NAME Hand Radio (5,0)

TIL 10h
11111011
10000010
00100100
00000000
00000100
01101000
00100001
10001010
NAME Hand Radio (6,0)

TIL 10i
11100100
00000000
10000000
00000000
01000000
00000000
01000000
01000000
NAME Hand Radio (7,0)

TIL 10j
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00101010
NAME Hand Radio (8,0)

TIL 10k
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10101010
NAME Hand Radio (9,0)

TIL 10l
00001001
00000000
00000000
00000000
00000000
00000000
00000000
10101010
NAME Hand Radio (11,0)

TIL 10m
00100100
00000000
00000000
00000000
00000000
00000000
00000000
10101000
NAME Hand Radio (12,0)

TIL 10n
10010010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (13,0)

TIL 10o
01001001
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (14,0)

TIL 10p
00100100
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (15,0)

TIL 10q
10001000
10000010
10001001
10000100
10001000
10100000
10001001
10000010
NAME Hand Radio (0,1)

TIL 10r
00100000
00010100
01000100
00010001
10010100
01000000
00000010
00101010
NAME Hand Radio (1,1)

TIL 10s
01111111
11111101
01110111
01111111
11111111
01111111
11101111
01111111
NAME Hand Radio (2,1)

TIL 10t
11111110
11011011
11111111
11111111
11111111
01101110
11111111
11111111
NAME Hand Radio (3,1)

TIL 10u
11111011
11101111
11111111
11111111
11111111
11011101
11111111
11111111
NAME Hand Radio (4,1)

TIL 10v
11001000
10010011
11001000
11000000
11000100
11000010
10010100
11000000
NAME Hand Radio (5,1)

TIL 10w
00000001
01000100
00101000
10000001
01010000
10001010
00000010
01010010
NAME Hand Radio (6,1)

TIL 10x
00000000
01000000
00000000
10100000
10000000
00000000
10000000
00100000
NAME Hand Radio (7,1)

TIL 10y
00111111
01111111
00111111
01111110
00111011
01111111
00111111
01111111
NAME Hand Radio (8,1)

TIL 10z
11111111
11111111
11111111
11111111
11101101
11111111
11111111
11111111
NAME Hand Radio (9,1)

TIL 11a
10001000
00100010
00101001
01000100
00010001
00010000
10010100
01000010
NAME Hand Radio (6,2)

TIL 11b
10000000
01000000
00000000
01000000
00000000
00000000
10100000
00000000
NAME Hand Radio (7,2)

TIL 11c
00110111
01111111
00111111
01111110
00111011
01111111
00111111
01111111
NAME Hand Radio (8,2)

TIL 11d
10111110
11111011
11111111
11111111
11111111
11111111
11111111
11110111
NAME Hand Radio (9,2)

TIL 11e
11111011
11111111
11111111
11111111
11101111
11111111
11111110
01111111
NAME Hand Radio (10,2)

TIL 11f
11101111
11111111
11111111
10111110
11111111
11111111
11111111
11111011
NAME Hand Radio (11,2)

TIL 11g
10111110
11111100
11111100
11111110
11111110
11111110
11101110
11111110
NAME Hand Radio (12,2)

TIL 11h
10001000
10000010
10001000
10000100
10001001
10000001
10001000
10001010
NAME Hand Radio (0,3)

TIL 11i
10000000
00101010
00000010
11010010
00001000
00010001
00010000
10010100
NAME Hand Radio (1,3)

TIL 11j
11111111
01101101
10010101
00000000
00101010
00100000
10000100
00000101
NAME Hand Radio (2,3)

TIL 11k
11111111
11110111
00010100
00000000
10101010
00000000
00000000
00110100
NAME Hand Radio (3,3)

TIL 11l
11111111
01110111
10010100
00000000
10101010
00000000
00000000
11010011
NAME Hand Radio (4,3)

TIL 11m
11000000
00101001
10000100
00000000
10101000
00000101
00110001
01000000
NAME Hand Radio (5,3)

TIL 11n
00000000
00101000
10101010
10000000
00000011
00110100
00010000
01000010
NAME Hand Radio (6,3)

TIL 11o
00000000
10000000
01000000
11000000
00000000
00000000
00000000
10000000
NAME Hand Radio (7,3)

TIL 11p
00110111
01111111
00111111
01111111
00111011
01111111
00111111
01111111
NAME Hand Radio (8,3)

TIL 11q
11111111
11011111
11111111
11111111
11111111
11111101
10111111
11111111
NAME Hand Radio (9,3)

TIL 11r
11111111
11111111
11110111
11111111
01111111
11111111
11111011
11111111
NAME Hand Radio (10,3)

TIL 11s
11111111
11111111
11011111
01111110
11111111
11111111
11111011
11101111
NAME Hand Radio (11,3)

TIL 11t
11111110
11111110
10111110
11111110
11111110
11111110
11110110
11111110
NAME Hand Radio (12,3)

TIL 11u
10000000
10001001
10100010
10001001
10000000
10001010
10000000
10001001
NAME Hand Radio (0,4)

TIL 11v
01000001
00000000
00101010
00001001
00100010
10001000
00100101
01000001
NAME Hand Radio (1,4)

TIL 11w
01001000
00100000
00000101
01010100
00010000
01000101
00010000
01001010
NAME Hand Radio (2,4)

TIL 11x
10000010
00010000
00100100
10010010
00000000
01001001
00100101
00000100
NAME Hand Radio (3,4)

TIL 11y
00001000
10000010
01010001
10001010
00000000
01010001
00000101
01010000
NAME Hand Radio (4,4)

TIL 11z
00101001
00000100
01000001
00101000
00000101
01000000
00100100
00000101
NAME Hand Radio (5,4)

TIL 12a
01010000
00000010
01001010
00100000
10101000
10000101
00000001
01001000
NAME Hand Radio (3,5)

TIL 12b
00001010
10000001
00100101
10010100
00010001
01000000
00000110
00100000
NAME Hand Radio (4,5)

TIL 12c
01001000
00100000
00101010
01001101
00010001
00000100
10110000
00000010
NAME Hand Radio (5,5)

TIL 12d
10010000
00100101
10100001
10101011
00101001
00000000
11010100
00000001
NAME Hand Radio (6,5)

TIL 12e
01000000
00000000
01000000
01000000
01000000
00000000
00010000
01000000
NAME Hand Radio (7,5)

TIL 12f
00111111
00011111
00111011
00011111
00111111
00111111
01111011
10111111
NAME Hand Radio (8,5)

TIL 12g
11111011
11011111
11111111
11111111
11111111
11011111
11111110
11111111
NAME Hand Radio (9,5)

TIL 12h
11011101
11111111
11111111
01111111
11110111
11111111
11111111
11111111
NAME Hand Radio (10,5)

TIL 12i
11111111
11111111
11111110
11111011
11011111
01111111
11111111
11111111
NAME Hand Radio (11,5)

TIL 12j
11111110
11111110
11111110
11101110
11111110
11111110
11111110
10111110
NAME Hand Radio (12,5)

TIL 12k
10000100
10001000
10100010
10001000
10000000
00000010
00000000
00000000
NAME Hand Radio (0,6)

TIL 12l
01001100
00100000
10010001
10000101
10100100
00000100
00000000
00000000
NAME Hand Radio (1,6)

TIL 12m
10000000
10100110
00010000
00000101
01000001
00000000
00000000
00000000
NAME Hand Radio (2,6)

TIL 12n
00100100
10000101
01010000
00001010
01001000
00000000
00000000
00000000
NAME Hand Radio (3,6)

TIL 12o
10100100
00010010
00000010
10001000
01000101
00000100
00000000
00000000
NAME Hand Radio (4,6)

TIL 12p
10010000
00010100
10010001
01000100
00010000
00001010
00000001
00000100
NAME Hand Radio (5,6)

TIL 12q
00010010
11000001
00010100
01000000
01010100
01000100
00010000
01001010
NAME Hand Radio (6,6)

TIL 12r
00100010
01000000
00010100
10010000
10000010
00010010
01010101
00000000
NAME Hand Radio (7,6)

TIL 12s
01111111
00111101
10111111
10101110
01001001
00000000
01000001
00010100
NAME Hand Radio (8,6)

TIL 12t
11111111
11110111
11111111
10111010
00100010
00000000
00000100
01010000
NAME Hand Radio (9,6)

TIL 12u
11101110
11111111
11111010
10101000
10100000
00000000
00000000
00000000
NAME Hand Radio (10,6)

TIL 12v
11111110
11111111
10101010
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (11,6)

TIL 12w
11111010
11111110
11010110
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (12,6)

TIL 12x
00000111
00001111
00001111
00000111
00001111
00001111
00001101
00000111
NAME Hand Radio (13,6)

TIL 12y
11111111
11111111
01110111
11111111
11111111
10111101
11111111
11111111
NAME Hand Radio (14,6)

TIL 12z
11111110
11111110
01110110
11111110
11111110
11011110
11111110
11111010
NAME Hand Radio (15,6)

TIL 13a
11111110
11101110
11111110
11111110
10111110
11111110
11111110
11111110
NAME Hand Radio (15,7)

TIL 13b
00111110
01111111
00111111
00111011
00111111
00111111
00111111
00111111
NAME Hand Radio (3,8)

TIL 13c
11111111
11111111
11111101
11111111
11110111
11011111
01111111
11111111
NAME Hand Radio (4,8)

TIL 13d
11111110
11111111
11110110
11011111
11111110
11111111
11111110
11111110
NAME Hand Radio (5,8)

TIL 13e
10000000
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (6,8)

TIL 13f
00100010
00101000
10000001
00100100
00001000
00100010
00001001
00100100
NAME Hand Radio (8,8)

TIL 13g
00010000
01000101
00010000
01000000
00101001
01000100
01000000
00000110
NAME Hand Radio (9,8)

TIL 13h
00000000
01010000
00000000
10000010
00100100
00100100
10001010
10010000
NAME Hand Radio (10,8)

TIL 13i
00000000
00000000
00000000
01001001
00000000
10010010
01000001
00000100
NAME Hand Radio (11,8)

TIL 13j
00000000
00000000
00000000
00100100
00000001
01001000
00000010
00101001
NAME Hand Radio (12,8)

TIL 13k
00001111
00001111
01011110
00101111
00011111
01011111
00011101
00011111
NAME Hand Radio (13,8)

TIL 13l
11111111
11111101
11101111
11111111
11111111
10111111
11111111
11111110
NAME Hand Radio (14,8)

TIL 13m
11110110
11111110
11111110
11111110
11011110
11111110
11111110
11111110
NAME Hand Radio (15,8)

TIL 13n
00111111
00111101
00111111
00101010
00000000
00000000
00000000
00000000
NAME Hand Radio (3,9)

TIL 13o
11111111
11111111
11111111
10101010
00000000
00000000
00000000
00000000
NAME Hand Radio (4,9)

TIL 13p
11111111
10111110
11111110
10100101
00000000
00000000
00000100
00000000
NAME Hand Radio (5,9)

TIL 13q
00000000
00000000
00000000
00000000
00000000
00000000
00000000
10000001
NAME Hand Radio (6,9)

TIL 13r
00000000
00101010
00000000
00000010
00101000
00001001
01000101
00010000
NAME Hand Radio (8,9)

TIL 13s
10010000
01001010
01010001
00000100
00100001
01001000
00000010
00010010
NAME Hand Radio (9,9)

TIL 13t
00000010
01001000
01000010
00011000
00000010
10100000
00100101
10000100
NAME Hand Radio (10,9)

TIL 13u
10010001
00010000
10010100
01000010
00000100
10100000
00101010
00001001
NAME Hand Radio (11,9)

TIL 13v
00000010
00100000
10010010
10010010
00000000
01001010
01000010
00010000
NAME Hand Radio (12,9)

TIL 13w
00011111
00001111
01011111
01001111
00111111
01011110
00011111
01001111
NAME Hand Radio (13,9)

TIL 13x
11111111
01111011
11111111
11101111
10111111
11111111
11111111
11111111
NAME Hand Radio (14,9)

TIL 13y
11111010
11111110
11111110
11111110
11101110
11111110
11111110
10111110
NAME Hand Radio (15,9)

TIL 13z
00000100
00000001
00001000
00000001
00000100
00000000
00001000
00000001
NAME Hand Radio (5,10)

TIL 14a
00000100
00000001
00000100
00000000
00000100
00000001
00000000
00000000
NAME Hand Radio (5,11)

TIL 14b
01001010
00000000
01010001
00001010
01001000
01000000
00010100
01000010
NAME Hand Radio (6,11)

TIL 14c
00010000
10000010
00010010
00010010
10001000
01000000
00011010
10000000
NAME Hand Radio (7,11)

TIL 14d
01000000
00100010
10001010
00010000
10000010
01001000
00100101
10001000
NAME Hand Radio (8,11)

TIL 14e
10001001
01000100
00010001
10100101
00000100
00100000
00001000
10100100
NAME Hand Radio (9,11)

TIL 14f
01001101
00010000
01000000
00101001
00000101
01010000
10000100
10010000
NAME Hand Radio (10,11)

TIL 14g
01001011
00000111
00100111
00100111
00010111
01000111
10010011
01000111
NAME Hand Radio (11,11)

TIL 14h
11110000
10111010
11110000
11111000
01110000
11111010
11110000
11110010
NAME Hand Radio (12,11)

TIL 14i
01101111
00011111
10011111
10010101
00000010
01001000
01001000
10000010
NAME Hand Radio (13,11)

TIL 14j
11111110
11111111
11111111
01010101
00100000
10000101
00000000
00101000
NAME Hand Radio (14,11)

TIL 14k
11111010
11111110
11111110
01010100
00000000
00010000
01000010
00000010
NAME Hand Radio (15,11)

TIL 14l
01000010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (6,12)

TIL 14m
01010010
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (7,12)

TIL 14n
01000000
00001001
00000010
00000000
00000010
00000010
00000000
00000010
NAME Hand Radio (8,12)

TIL 14o
00010000
00100010
10100001
00000100
10010010
01001000
00001010
10100000
NAME Hand Radio (9,12)

TIL 14p
01000010
00000010
00101001
10101000
00000000
10001001
00001001
01000100
NAME Hand Radio (10,12)

TIL 14q
00000111
01000011
00010111
01010011
10000111
00010111
00010011
00101111
NAME Hand Radio (11,12)

TIL 14r
10111000
11110000
11111000
11110010
10111000
11110001
11111001
01110000
NAME Hand Radio (12,12)

TIL 14s
10010100
00010000
10000010
01001000
00100010
00101001
00100000
00000100
NAME Hand Radio (13,12)

TIL 14t
10100010
10000100
00000000
00101010
01010010
01000000
00000100
10010100
NAME Hand Radio (14,12)

TIL 14u
10010000
10010000
00000100
01001010
01001000
00000000
10100100
00100000
NAME Hand Radio (15,12)

TIL 14v
00001011
10011011
10001101
00111111
11111111
10111111
10111100
00101100
NAME Hand Radio (1,13)

TIL 14w
00000000
00000010
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (8,13)

TIL 14x
00010001
10000000
00001010
01010100
00000000
00000000
00000000
00000000
NAME Hand Radio (9,13)

TIL 14y
01000000
00010110
10000000
01010010
00000000
00000000
00000000
00000000
NAME Hand Radio (10,13)

TIL 14z
10100111
10000011
00001011
00101111
00000011
00000011
00000011
00000001
NAME Hand Radio (11,13)

TIL 15a
11111111
11111111
11011110
01110111
11111101
10110111
11111111
01011011
NAME Hand Radio (5,0)

TIL 15b
11111111
11111111
11111101
11010111
11111110
01111011
11011111
01111101
NAME Hand Radio (6,0)

TIL 15c
11111111
11111111
11101101
10111111
11110111
11111101
10110111
11111111
NAME Hand Radio (7,0)

TIL 15d
11111111
11111111
11011011
01111111
11010101
01111111
11101101
10111111
NAME Hand Radio (8,0)

TIL 15e
11111111
11111111
01101101
11111111
01010101
11111111
01010101
11111111
NAME Hand Radio (9,0)

TIL 15f
11111111
11111111
10110110
01111101
11010111
01111111
11101101
10111110
NAME Hand Radio (10,0)

TIL 15g
11111111
11111111
11011011
11111111
01010101
11111111
10110101
11111111
NAME Hand Radio (11,0)

TIL 15h
11111111
11111111
01101101
11111111
01010111
11111101
10110111
11101110
NAME Hand Radio (12,0)

TIL 15i
11111111
11111111
11011110
01110111
11111110
10110111
11111101
10101111
NAME Hand Radio (13,0)

TIL 15j
11111111
11111111
11111111
11011010
11111111
11101111
10111101
11111111
NAME Hand Radio (14,0)

TIL 15k
11111111
11111111
11111111
11010110
11111111
01111011
11101111
11111111
NAME Hand Radio (15,0)

TIL 15l
11101101
11111111
10101101
11111111
10110101
11111111
11010110
11111111
NAME Hand Radio (0,1)

TIL 15m
10111101
11110111
10111110
11101111
01111011
11011110
11111011
10111111
NAME Hand Radio (1,1)

TIL 15n
11111111
10110110
11111111
11101101
10111111
11110110
11111111
10110110
NAME Hand Radio (2,1)

TIL 15o
11110111
11011111
11111011
10111111
11101101
11111011
10101111
11111101
NAME Hand Radio (3,1)

TIL 15p
01101111
11111011
01011111
11110101
01011111
11110110
01111111
11010101
NAME Hand Radio (4,1)

TIL 15q
11111111
01101101
11111111
01010110
11111111
11011010
11111111
01010110
NAME Hand Radio (5,1)

TIL 15r
11101111
10111101
11110111
11011110
11111111
10110101
11111111
11010111
NAME Hand Radio (6,1)

TIL 15s
10110110
11111111
10110101
11111111
11011011
11111110
01101011
11011110
NAME Hand Radio (7,1)

TIL 15t
11110101
10111111
11101011
01111101
10101111
11111011
10101101
11111111
NAME Hand Radio (8,1)

TIL 15u
01101101
11110111
01011101
11110111
01011101
11110111
01011101
11101110
NAME Hand Radio (9,1)

TIL 15v
11101011
01111110
10101011
11111110
01010111
11111010
01011111
11101010
NAME Hand Radio (10,1)

TIL 15w
11010101
11111111
10101010
11111111
10101010
11111111
10101010
11111111
NAME Hand Radio (11,1)

TIL 15x
01111011
11011111
11110101
10111111
11010111
11111010
10101111
11111010
NAME Hand Radio (12,1)

TIL 15y
11111101
01110111
11011110
01111011
11011111
11110110
10111111
11101011
NAME Hand Radio (13,1)

TIL 15z
11101111
10111101
11111111
11101110
10111011
11111111
11011101
01110111
NAME Hand Radio (14,1)

TIL 16a
10110101
01111111
11010101
01010101
10111110
11111111
11111111
11111111
NAME Hand Radio (9,2)

TIL 16b
10111111
01101011
11011101
01010101
11010101
11111111
11111111
11111111
NAME Hand Radio (10,2)

TIL 16c
01010101
11111110
01010101
10111111
01000001
11111110
11111111
11111111
NAME Hand Radio (11,2)

TIL 16d
01011111
11101010
10111111
11010101
01111111
10001010
11110101
11111111
NAME Hand Radio (12,2)

TIL 16e
10111111
11110110
10111111
11101010
01111111
11010110
01111101
10001011
NAME Hand Radio (13,2)

TIL 16f
11111110
11011011
11111111
10110110
11111111
11010101
11111111
10101101
NAME Hand Radio (14,2)

TIL 16g
11111011
11101111
10111110
11110111
11011101
11111111
01101101
11111111
NAME Hand Radio (15,2)

TIL 16h
10111111
11101010
10111111
11101101
10111011
11101111
10111010
11101111
NAME Hand Radio (0,3)

TIL 16i
10101111
11111011
10101110
11111011
01101110
10111011
11101110
10111011
NAME Hand Radio (1,3)

TIL 16j
01111110
11101111
10111010
11111111
11010101
10111110
11101011
10111110
NAME Hand Radio (2,3)

TIL 16k
10111111
11101011
10111110
11101011
10111110
11101101
10111011
11101110
NAME Hand Radio (3,3)

TIL 16l
11101011
01111110
11010101
11110111
10101101
11011111
00111111
11111111
NAME Hand Radio (4,3)

TIL 16m
11010111
10101111
01111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (5,3)

TIL 16n
11111111
11111111
11111111
11111111
11111110
11111011
11010101
10111010
NAME Hand Radio (7,3)

TIL 16o
11111111
11111111
11111110
11110111
01011010
10101011
01010101
11010101
NAME Hand Radio (8,3)

TIL 16p
11111111
11111111
11010111
11111011
01001101
01110101
01001010
00101010
NAME Hand Radio (9,3)

TIL 16q
11111111
11111111
11111111
01110111
10101111
01011010
10101101
11010101
NAME Hand Radio (10,3)

TIL 16r
11111111
11111111
11111111
11111111
11111111
10111111
01010111
10111010
NAME Hand Radio (11,3)

TIL 16s
11111111
11111111
11111111
11111111
11111111
11111111
11111111
10110111
NAME Hand Radio (12,3)

TIL 16t
11111010
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (13,3)

TIL 16u
11111111
10101101
11010111
11101011
11111010
11111101
11111110
11111111
NAME Hand Radio (14,3)

TIL 16v
10110101
11101111
01111101
11011111
11110101
10111111
11010101
01111111
NAME Hand Radio (15,3)

TIL 16w
10110101
11011110
10110111
11111010
10101111
11011010
10110111
11101101
NAME Hand Radio (0,4)

TIL 16x
11101110
10111011
11011101
10110110
11101111
10111010
11010111
01111010
NAME Hand Radio (1,4)

TIL 16y
11101011
10111110
11010111
10111010
11101111
10111011
01101101
11011011
NAME Hand Radio (2,4)

TIL 16z
10111010
11101101
10111010
11101101
01011010
11110101
01011110
10110101
NAME Hand Radio (3,4)

TIL 17a
01101010
01111111
11010101
11111111
10101010
01110111
11011101
11101011
NAME Hand Radio (15,4)

TIL 17b
10111011
10101101
11110111
01011010
11101111
10110101
10101101
11010111
NAME Hand Radio (0,5)

TIL 17c
10101111
01110101
11011011
10101101
01110110
10101011
01111001
10101101
NAME Hand Radio (1,5)

TIL 17d
01101101
10011011
01010110
11011011
10101101
01101010
10101111
01101001
NAME Hand Radio (2,5)

TIL 17e
01101111
10110101
11011011
01101101
10110111
11011010
01101101
01010110
NAME Hand Radio (3,5)

TIL 17f
10101111
01010011
11101001
01111100
10101011
11011101
01101010
10110101
NAME Hand Radio (4,5)

TIL 17g
11111101
11110111
01111111
10101111
00010101
11101010
10111010
11010101
NAME Hand Radio (5,5)

TIL 17h
11101111
11111111
11011110
11111011
11111111
01011111
10101010
10101010
NAME Hand Radio (6,5)

TIL 17i
01101101
11010110
11111011
11111111
11111111
10111111
11111111
10101010
NAME Hand Radio (7,5)

TIL 17j
10101101
11010110
01111010
11010111
01111111
11111111
11111111
11111111
NAME Hand Radio (8,5)

TIL 17k
10101011
10101101
11010110
01111011
11101111
11111111
11111111
11111111
NAME Hand Radio (9,5)

TIL 17l
01011011
11101101
10110111
11111111
01111111
11111111
11111111
11101010
NAME Hand Radio (10,5)

TIL 17m
01101101
11111111
11111111
11111111
11111111
11111110
10101010
10101011
NAME Hand Radio (11,5)

TIL 17n
11101111
11111011
11101111
11111111
11111101
10101011
11011101
01110111
NAME Hand Radio (12,5)

TIL 17o
11111111
11111110
11110101
10101111
01110101
11011110
01101011
10111101
NAME Hand Radio (13,5)

TIL 17p
10111011
11101111
10111010
01101111
11011010
10111101
11010110
01101101
NAME Hand Radio (14,5)

TIL 17q
01011110
11110101
10101111
01110101
11011101
10110110
11011011
10101101
NAME Hand Radio (15,5)

TIL 17r
01101010
10110101
11011011
01010100
10110100
11011010
01010101
10101010
NAME Hand Radio (0,6)

TIL 17s
10110101
01010101
10101010
10110100
10101010
10100101
01010000
10010110
NAME Hand Radio (1,6)

TIL 17t
01010110
01101011
10101010
10101010
01010101
01010101
01010101
10000010
NAME Hand Radio (2,6)

TIL 17u
11011011
01101010
10101101
10101010
01010101
01010101
00101011
10101101
NAME Hand Radio (3,6)

TIL 17v
11001011
00101101
10110110
10101011
01101101
01010101
01010101
01101101
NAME Hand Radio (4,6)

TIL 17w
01011010
01101101
10010111
01110101
10101101
01101010
10110111
01011010
NAME Hand Radio (5,6)

TIL 17x
11110110
01011011
10101101
01110110
10101011
11011101
01101010
10101010
NAME Hand Radio (6,6)

TIL 17y
11010101
01101101
10110101
11011010
01101011
10101010
10101101
11010110
NAME Hand Radio (7,6)

TIL 17z
01001001
01101101
10110110
11011011
01101101
10110101
11010110
10111010
NAME Hand Radio (8,6)

TIL 18a
00101010
00101010
00010101
01000100
00010010
00001001
00000010
00000001
NAME Hand Radio (3,7)

TIL 18b
10110110
10101011
01011010
10101011
10101010
01010101
01010101
01010010
NAME Hand Radio (4,7)

TIL 18c
11010101
01010110
10101010
01101010
10101011
01010101
01010110
10101010
NAME Hand Radio (5,7)

TIL 18d
01010101
10101010
10101101
11010110
01101010
01011010
10101010
11010101
NAME Hand Radio (6,7)

TIL 18e
01101011
10101101
10110101
10101010
10101010
11010110
10101010
01010101
NAME Hand Radio (7,7)

TIL 18f
01010111
10101010
01101101
10010101
11011011
10010101
10101101
00101011
NAME Hand Radio (8,7)

TIL 18g
11111110
11111110
11111110
11111101
11011111
11111101
11011101
11111010
NAME Hand Radio (9,7)

TIL 18h
11010110
10111011
11001010
01101101
01010101
10101010
01011010
01010101
NAME Hand Radio (10,7)

TIL 18i
11011011
01010101
10101010
01101101
10110110
10101010
10101011
01010101
NAME Hand Radio (11,7)

TIL 18j
01110101
10011010
11101011
00101101
11010101
10110110
01011010
01101010
NAME Hand Radio (12,7)

TIL 18k
01101010
10101101
01010101
01101010
10101101
10110110
10101010
10101010
NAME Hand Radio (13,7)

TIL 18l
11011010
01010110
10101010
10110101
01011010
10101010
11010110
10101010
NAME Hand Radio (14,7)

TIL 18m
11010101
10101010
10110110
10101011
10110101
11010101
10101101
10101010
NAME Hand Radio (15,7)

TIL 18n
01010000
01000000
01010000
01000000
10010000
01000000
10100000
01010000
NAME Hand Radio (0,8)

TIL 18p
00000100
00000001
00000000
00000000
00000000
00000000
00000000
00000000
NAME Hand Radio (3,8)

TIL 18q
01000101
00010101
01001010
00101001
00010101
00001010
00010000
00101010
NAME Hand Radio (4,8)

TIL 18r
01011010
01010101
10101010
01010101
01001010
00101010
10010101
01010010
NAME Hand Radio (5,8)

TIL 18s
10101010
01010101
00101010
10101010
10101010
01010101
01010101
10101010
NAME Hand Radio (6,8)

TIL 18t
10101010
01010110
10101001
10110101
10101001
01010010
01010101
10100101
NAME Hand Radio (7,8)

TIL 18u
10110101
01010111
01010101
01010111
01010101
10101101
01010110
01010101
NAME Hand Radio (8,8)

TIL 18v
01011101
11111011
01011101
01110110
11011010
01111011
11011101
01111010
NAME Hand Radio (9,8)

TIL 18w
01010101
01010101
10101010
10101010
10010101
11010101
01010101
11010101
NAME Hand Radio (10,8)

TIL 18x
10110101
01010101
10101010
10101011
01010101
01010101
01010101
01010101
NAME Hand Radio (11,8)

TIL 18y
01010101
01010101
10101010
01010101
01010101
01010101
01010101
01010101
NAME Hand Radio (12,8)

TIL 18z
01010101
10110110
10101010
01010101
01010101
01010101
01010101
01010101
NAME Hand Radio (13,8)

TIL 19a
11011101
01111101
10111011
11011101
01111101
11011101
01111110
10111110
NAME Hand Radio (9,9)

TIL 19b
01010101
10101010
01010100
10101010
01101010
10101001
10110101
10101010
NAME Hand Radio (10,9)

TIL 19c
01010101
10101010
10010101
10101001
10100101
01010101
00101010
10100100
NAME Hand Radio (11,9)

TIL 19d
01010101
10101010
01010101
00101010
01010010
01001010
10101010
10101001
NAME Hand Radio (12,9)

TIL 19e
01010101
10101010
01010101
01001010
10101001
10100101
01010101
01010100
NAME Hand Radio (13,9)

TIL 19f
01010101
10101010
01010101
10101010
01010101
00100101
01010100
10101010
NAME Hand Radio (14,9)

TIL 19g
01010010
10101010
01010101
01001010
01010101
01010101
10101001
10010101
NAME Hand Radio (15,9)

TIL 19h
11111101
11010110
11111011
10101111
11111101
11010111
11111101
10110111
NAME Hand Radio (0,10)

TIL 19i
10100000
11011111
10110101
01110110
11011011
01111110
11010111
11111010
NAME Hand Radio (1,10)

TIL 19j
00000000
10101010
01101101
11011110
01101011
11011101
11110110
10111011
NAME Hand Radio (2,10)

TIL 19k
00010010
01001001
00100101
10011110
01010111
10111101
11101111
10111010
NAME Hand Radio (3,10)

TIL 19l
01001010
01110101
11111111
11011011
11111101
01010111
11111101
10101111
NAME Hand Radio (4,10)

TIL 19m
01010111
11111010
01011111
11111101
01101111
11011011
11111101
01010111
NAME Hand Radio (5,10)

TIL 19n
11110110
10101111
11111101
11110111
01011110
11111011
01011110
11110111
NAME Hand Radio (6,10)

TIL 19o
10100100
10110110
11111011
10101111
11111101
11011111
11110101
10111111
NAME Hand Radio (7,10)

TIL 19p
10101010
11011101
11111111
10111011
11111110
11011011
11111110
10111011
NAME Hand Radio (8,10)

TIL 19q
11111101
01011110
10111010
11111110
11111101
10111101
11111111
11111011
NAME Hand Radio (9,10)

TIL 19r
01101001
10101101
11010100
01011010
01101010
01001010
10111111
11111111
NAME Hand Radio (10,10)

TIL 19s
01010101
00101010
10100100
10010010
01001001
10101010
01110110
11011111
NAME Hand Radio (11,10)

TIL 19t
00100101
10010100
10101010
01010101
00100010
10010101
11101010
10111111
NAME Hand Radio (12,10)

TIL 19u
00100101
10101010
10010010
01001001
01010101
00100100
11011011
01101111
NAME Hand Radio (13,10)

TIL 19v
01001010
10101001
01010100
00100101
01010010
10010101
01101101
11111011
NAME Hand Radio (14,10)

TIL 19w
10101010
01010010
10010101
01001010
10101001
00100101
11011110
01111011
NAME Hand Radio (15,10)

TIL 19x
11011101
11110111
10111110
11101011
11111111
10101010
11011101
10101011
NAME Hand Radio (0,11)

TIL 19y
01011111
11110101
11011111
10110101
11111111
11101101
01011011
01101101
NAME Hand Radio (1,11)

TIL 19z
11011110
01101011
11111110
10101011
01111110
11111011
01010110
10110101
NAME Hand Radio (2,11)

TIL 1a0
11101111
10111010
11101111
10111011
11101101
11010110
10111111
11101010
NAME Hand Radio (3,11)

TIL 1a1
11110101
10111111
11010101
01111111
10101101
11110111
10111101
11010110
NAME Hand Radio (4,11)

TIL 1a2
11111110
01110111
11011101
01110110
11011011
11101111
01111101
11011111
NAME Hand Radio (5,11)

TIL 1a3
11011101
11110111
10111101
11010110
10111011
11111111
01101010
11111101
NAME Hand Radio (6,11)

TIL 1a4
11101111
01110110
11011111
11101110
01011111
11110101
10111110
11101101
NAME Hand Radio (7,11)

TIL 1a5
11111111
11011010
11111111
10110101
11111110
10110111
11111101
11101111
NAME Hand Radio (8,11)

TIL 1a6
11111111
11111101
10111111
11111101
11111111
11111101
11111111
11111110
NAME Hand Radio (9,11)

TIL 1a7
11110110
10111111
11011011
11111101
10111111
11010101
10111111
11011010
NAME Hand Radio (10,11)

TIL 1a8
11111011
10101110
11111111
11011010
11101111
10111010
11101111
11111011
NAME Hand Radio (11,11)

TIL 1a9
11110101
10111111
11101101
11111110
10101011
11111101
01010111
11101010
NAME Hand Radio (12,11)

TIL 1aa
11111101
11011111
11110101
10111111
11101010
01011101
10101111
11110101
NAME Hand Radio (13,11)

TIL 1ab
01011111
11110110
11011111
01111011
11011101
10101110
11110101
01011111
NAME Hand Radio (14,11)

TIL 1ac
11011101
11101111
10111011
11111101
01101111
11011011
10111101
11101111
NAME Hand Radio (15,11)

TIL 1ad
11111101
10101111
11011010
11101111
10110101
11101111
11111111
11011010
NAME Hand Radio (0,12)

TIL 1ae
10110110
01011011
11101101
10111011
11101111
01011010
11101101
10111110
NAME Hand Radio (1,12)

TIL 1af
11011010
01101111
10110101
11111111
01011011
11111110
10111101
11101111
NAME Hand Radio (2,12)

TIL 1ag
10111011
01010101
11011101
01110110
10111011
11011110
10110111
01111111
NAME Hand Radio (3,12)

TIL 1ah
01101011
10111111
01110111
11011010
11111011
11011111
01111101
11101111
NAME Hand Radio (4,12)

TIL 1ai
01101010
11111111
11010111
10110101
01011111
11110101
11011111
11111111
NAME Hand Radio (5,12)

TIL 1aj
10101111
01111010
11011111
01101011
11111110
01011111
11111011
11101111
NAME Hand Radio (6,12)

TIL 1ak
10111111
11111011
01011101
11111011
10111110
11110101
01111110
11101011
NAME Hand Radio (7,12)

TIL 1al
10110101
11111111
01101111
11111101
11101111
11011111
10111011
11111111
NAME Hand Radio (8,12)

TIL 1am
11111111
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (9,12)

TIL 1an
11111111
11101101
11110111
01111110
01111101
11111111
10110111
11111111
NAME Hand Radio (10,12)

TIL 1ao
10101101
11110101
11011110
11111011
01101111
11111010
11110111
11111111
NAME Hand Radio (11,12)

TIL 1ap
01011111
10110101
11011010
11111111
10101101
11111111
11101110
01111111
NAME Hand Radio (12,12)

TIL 1aq
10111101
01100110
10111011
11011101
01111111
11101101
11110111
10111101
NAME Hand Radio (13,12)

TIL 1ar
11101010
10110110
01011011
11110110
10101101
11110111
01111111
11111101
NAME Hand Radio (14,12)

TIL 1as
10111010
11001011
01110101
10101110
11011011
01111111
11101101
11111111
NAME Hand Radio (15,12)

TIL 1at
11111111
11110110
11111111
10111111
11111101
11111111
11111111
11111111
NAME Hand Radio (0,13)

TIL 1au
11111011
11111111
11111111
10111111
11111111
11111110
11111111
01111111
NAME Hand Radio (1,13)

TIL 1av
01110101
11111111
01011111
11101101
11111111
10101011
01111111
11101101
NAME Hand Radio (2,13)

TIL 1aw
11110110
11111111
11011010
11110111
01111101
11110111
11111111
11111111
NAME Hand Radio (3,13)

TIL 1ax
11110101
10111011
11101110
11111011
11011101
11101111
11111101
11111111
NAME Hand Radio (4,13)

TIL 1ay
01111110
11111111
11101111
11111111
01011111
10111111
11101101
01111111
NAME Hand Radio (5,13)

TIL 1az
11111111
11011111
11111111
11111111
11011101
01111111
11111011
11111111
NAME Hand Radio (6,13)

TIL 1b0
11111111
01011111
11111111
01010101
11110111
11010111
11101011
11111111
NAME Hand Radio (7,13)

TIL 1b1
11011111
01111111
11111111
10110111
01111111
11111110
11111111
11111010
NAME Hand Radio (8,13)

TIL 1b2
11101011
11111111
01101011
11111111
01011111
11010111
10111111
11101111
NAME Hand Radio (9,13)

TIL 1b3
10111110
11111101
11010111
11111110
11101111
11111011
11111111
11101111
NAME Hand Radio (10,13)

TIL 1b4
11111011
11111111
01111011
11111111
11111101
11111101
11111111
11111110
NAME Hand Radio (11,13)

TIL 1b5
11110111
11111111
11111111
11111111
11111111
01111111
10110111
11111111
NAME Hand Radio (12,13)

TIL 1b6
11111111
11011111
11111111
11111111
11111111
11101101
11101011
11010110
NAME Hand Radio (13,13)

TIL 1b7
11101111
11111110
11111111
11111111
11111111
01111111
11011111
10101011
NAME Hand Radio (14,13)

TIL 1b8
11011111
11111111
11101110
11111111
11111111
11101111
11111111
11111101
NAME Hand Radio (15,13)

TIL 1b9
11111111
11111111
11111101
11110111
11111111
11111111
11101111
11111111
NAME Hand Radio (0,14)

TIL 1ba
11111111
11101010
11111111
11111111
11111111
11111111
11111011
11111110
NAME Hand Radio (2,14)

TIL 1bb
11111111
11111111
01111111
11111111
11111111
11111111
11111101
11111111
NAME Hand Radio (3,14)

TIL 1bc
11111111
11111111
11111111
11111111
11111111
11111111
01111101
01011111
NAME Hand Radio (4,14)

TIL 1bd
11111111
11111101
11110111
11111110
11111111
11011110
11110111
11111011
NAME Hand Radio (6,14)

TIL 1be
11111111
11111111
11111111
11111111
11111111
11111111
10111111
01111111
NAME Hand Radio (7,14)

TIL 1bf
11111111
11111111
11111111
11111111
11111011
11011111
11111011
11101110
NAME Hand Radio (8,14)

TIL 1bg
11111010
11101111
11111101
11110111
11111111
11111101
11110111
11111111
NAME Hand Radio (9,14)

TIL 1bh
10111111
11101011
11111011
11111111
11110111
11111111
10111110
11111011
NAME Hand Radio (10,14)

TIL 1bi
11011111
11111111
11111111
11011111
01110101
11101111
01110111
01011011
NAME Hand Radio (11,14)

TIL 1bj
11111111
11111011
11111111
10111111
11111111
11111111
11101111
11111111
NAME Hand Radio (12,14)

TIL 1bk
10111011
11101110
11111111
11111111
11111111
11111111
11111111
10111111
NAME Hand Radio (13,14)

TIL 1bl
11101111
11111111
11110111
11111101
11111111
11111111
11111111
11111101
NAME Hand Radio (14,14)

TIL 1bm
11111111
11111011
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (15,14)

TIL 1bn
11101111
11111111
11111111
11111111
11111110
11111111
11111011
11111111
NAME Hand Radio (0,15)

TIL 1bo
11111011
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (3,15)

TIL 1bp
10111111
11111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (4,15)

TIL 1bq
11111111
01111111
11111111
11111111
11111111
11111111
11111111
11111011
NAME Hand Radio (5,15)

TIL 1br
11011111
11111010
11111111
11111111
11111111
11111111
01111111
11111111
NAME Hand Radio (6,15)

TIL 1bs
11011111
11111011
11111111
11011111
01110111
11111110
11111111
11110101
NAME Hand Radio (7,15)

TIL 1bt
11111111
11111111
11111111
11111111
11111111
11111111
01111111
11110111
NAME Hand Radio (8,15)

TIL 1bu
11101101
10111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME Hand Radio (9,15)

TIL 1bv
11111101
10111010
11011110
01101011
11111110
11111111
11111111
11111111
NAME Hand Radio (10,15)

TIL 1bw
01101111
10110110
01001111
01011111
11010111
11111101
11111111
11011111
NAME Hand Radio (11,15)

TIL 1bx
10111101
11101111
11111110
11011011
01101111
11011001
01111110
11011010
NAME Hand Radio (12,15)

TIL 1by
11111111
11111111
11011111
11111101
11111111
11111011
11101111
10110111
NAME Hand Radio (13,15)

TIL 1bz
11111111
11111111
11111111
11011111
11111110
11111011
11011111
11111111
NAME Hand Radio (14,15)

TIL 1c0
11111111
11111111
11111101
11110111
11111111
11011111
11111111
11111111
NAME Hand Radio (15,15)

TIL 18o
11110101
11101010
11110101
11101010
11110101
11110101
11101010
11110101
NAME Canvas Thing (0,0)

TIL 1c1
01010101
10100100
00110101
10010101
01010010
01010101
10101010
01010100
NAME Canvas Thing (1,0)

TIL 1c2
01010101
10101010
01010101
00101010
10100101
01010101
10101001
10010101
NAME Canvas Thing (2,0)

TIL 1c3
00101001
10010101
01001001
01010010
01001011
00101001
01010010
01001001
NAME Canvas Thing (3,0)

TIL 1c4
01111111
10101010
01110111
11011101
10110110
01101101
11011011
01101110
NAME Canvas Thing (4,0)

TIL 1c5
01110111
11011010
10110111
01101101
11011010
10110111
01101111
11011110
NAME Canvas Thing (5,0)

TIL 1c6
01110111
11011011
01101101
11011011
10110110
01101101
11111111
10101011
NAME Canvas Thing (6,0)

TIL 1c7
01110111
10101101
01110111
10101101
11011011
01110110
11011101
01110111
NAME Canvas Thing (7,0)

TIL 1c8
11111111
01010101
11111110
01010101
01101111
11111010
10101111
11111010
NAME Canvas Thing (8,0)

TIL 1c9
11111111
01010101
11111101
10101011
01111101
11010110
11001001
11010010
NAME Canvas Thing (9,0)

TIL 1ca
11111111
01010101
10111111
01101010
11011111
11111010
00000101
01010100
NAME Canvas Thing (10,0)

TIL 1cb
11111111
01011111
11111111
10111111
11011111
10111111
01010101
10100100
NAME Canvas Thing (11,0)

TIL 1cc
11111111
11111111
11111111
11111111
11111111
11111111
01010101
10101010
NAME Canvas Thing (12,0)

TIL 1cd
11111111
11111111
11111111
11111111
11111111
11111111
01011111
10111111
NAME Canvas Thing (13,0)

TIL 1ce
11111111
11111111
11111111
11111111
11111111
11111110
11111111
11111111
NAME Canvas Thing (14,0)

TIL 1cf
11111111
11111111
11111111
11111111
11111111
01111111
10111111
11011111
NAME Canvas Thing (15,0)

TIL 1cg
11110101
11110101
11111010
11110101
11110101
11111110
11111101
11111110
NAME Canvas Thing (0,1)

TIL 1ch
01010010
01010101
10101010
01010110
01011010
10101010
01010101
10101001
NAME Canvas Thing (1,1)

TIL 1ci
10100101
01010100
10101010
10100101
10010010
01010101
01001010
00101001
NAME Canvas Thing (2,1)

TIL 1cj
01010011
10100001
11001010
10100101
10010001
01010101
10100101
01010101
NAME Canvas Thing (3,1)

TIL 1ck
10110111
01101101
10111010
11101111
01011010
11101111
01011010
01110101
NAME Canvas Thing (4,1)

TIL 1cl
01110111
10101101
11110110
01011111
11101101
01010111
11111110
10101011
NAME Canvas Thing (5,1)

TIL 1cm
11111111
10111010
11101111
11111011
10101111
11111010
10111111
11101010
NAME Canvas Thing (6,1)

TIL 1cn
11011111
11111101
11011011
01111111
11101101
11111111
10101101
11111111
NAME Canvas Thing (7,1)

TIL 1co
01101111
11111111
10110111
11111101
01101111
11111101
10110111
11111110
NAME Canvas Thing (8,1)

TIL 1cp
11001001
01010101
11010010
11001010
01101110
11000010
11011010
11001001
NAME Canvas Thing (9,1)

TIL 1cq
01010101
00110010
10011001
10100101
10010111
10101000
01010101
01001010
NAME Canvas Thing (10,1)

TIL 1cr
00010010
10101010
01001001
00101010
10101001
10100101
01010101
01001010
NAME Canvas Thing (11,1)

TIL 1cs
10010100
10100101
01010100
01010011
01001011
00101011
01010111
10101111
NAME Canvas Thing (12,1)

TIL 1ct
11111111
01111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Canvas Thing (13,1)

TIL 1cu
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11110111
NAME Canvas Thing (0,2)

TIL 1cv
01010101
10101010
11100101
11011010
11111010
11111010
11111010
11111101
NAME Canvas Thing (1,2)

TIL 1cw
01010101
10111110
01001111
10101111
11011111
01111111
11111111
11111111
NAME Canvas Thing (2,2)

TIL 1cx
01010001
10101001
00010001
11000101
10100001
11011010
10100010
01001001
NAME Canvas Thing (3,2)

TIL 1cy
10111110
01101011
10111011
01101101
10110110
11011101
11110111
01011101
NAME Canvas Thing (4,2)

TIL 1cz
11011111
01101110
10110111
11011101
10110111
11011111
01101101
10110111
NAME Canvas Thing (5,2)

TIL 1d0
10111111
11101101
10111111
11101011
01111110
11010111
01111010
11011111
NAME Canvas Thing (6,2)

TIL 1d1
10110101
11111111
01010110
11111111
10110101
11111111
10101101
11111111
NAME Canvas Thing (7,2)

TIL 1d2
10110111
11111111
11011011
11111110
01101111
11111011
10101111
11111101
NAME Canvas Thing (8,2)

TIL 1d3
11010101
01010010
11010100
11010010
11101010
01101001
11100101
10110100
NAME Canvas Thing (9,2)

TIL 1d4
00100101
10111111
10111111
10001000
01100101
00010100
01010010
10101010
NAME Canvas Thing (10,2)

TIL 1d5
00101001
11111110
11111101
10100100
00101010
10100101
10010101
10101010
NAME Canvas Thing (11,2)

TIL 1d6
01010111
10101111
01010111
10101111
10101111
01010111
01010101
10101011
NAME Canvas Thing (12,2)

TIL 1d7
11111111
11111011
11111011
11111110
11111111
11111111
11111111
11111111
NAME Canvas Thing (0,3)

TIL 1d8
11111110
11111111
11111111
11111111
11111111
11111111
10111111
11101111
NAME Canvas Thing (1,3)

TIL 1d9
11111110
11111111
11111110
11111111
11111010
11111101
11111100
11111010
NAME Canvas Thing (2,3)

TIL 1da
10101001
01001001
11010110
01101111
01111011
01111111
10111111
01111111
NAME Canvas Thing (3,3)

TIL 1db
10110110
01101101
10111011
11101101
10110110
11011011
11101110
10110101
NAME Canvas Thing (4,3)

TIL 1dc
11011110
10110110
01101110
10111010
11101110
10110110
11011100
10110110
NAME Canvas Thing (5,3)

TIL 1dd
11101010
10111111
10000010
00100011
00000111
00001000
10100101
00000101
NAME Canvas Thing (6,3)

TIL 1de
11010101
11011111
11101101
01110111
10011110
01000010
01011010
01100101
NAME Canvas Thing (7,3)

TIL 1df
01101111
11111010
10111101
11101111
11111011
00001001
11101010
00101010
NAME Canvas Thing (8,3)

TIL 1dg
11101010
10100101
11110010
01101001
11010100
00100101
10101010
10010010
NAME Canvas Thing (9,3)

TIL 1dh
11010101
00100100
10010011
01010100
10101010
00100101
10011001
01000100
NAME Canvas Thing (10,3)

TIL 1di
01010010
01001010
10101010
11111111
11111111
11111111
11111111
11111111
NAME Canvas Thing (11,3)

TIL 1dj
10101101
10110110
10101010
11010101
11111010
11111010
11111011
11111010
NAME Canvas Thing (12,3)

TIL 1dk
01111111
11111111
10101111
10110111
10101101
11010110
01011010
10101011
NAME Canvas Thing (13,3)

TIL 1dl
11111111
11111111
11111101
11110101
01010101
10101010
11010101
01101010
NAME Canvas Thing (14,3)

TIL 1dm
10111111
01111111
01111111
00111111
01111111
10111111
01111111
10111111
NAME Canvas Thing (15,3)

TIL 1dn
11110111
11111111
11111111
11111111
11111111
11111111
11101111
11111111
NAME Canvas Thing (1,4)

TIL 1do
11111101
11111010
11111100
11101010
11110101
11110100
11101010
11110101
NAME Canvas Thing (2,4)

TIL 1dp
00111111
01111111
01011111
01011111
01101111
00111111
11011111
01111111
NAME Canvas Thing (3,4)

TIL 1dq
11011110
10110101
11011011
01101110
10110111
01101101
10110110
11011011
NAME Canvas Thing (4,4)

TIL 1dr
11011100
10110100
01101101
11011100
01110100
10101100
11111101
01010100
NAME Canvas Thing (5,4)

TIL 1ds
10100100
01010101
00000101
01010100
10000101
00100010
00011111
00001010
NAME Canvas Thing (6,4)

TIL 1dt
10010101
01010101
01010010
10101010
01001010
11011011
11111111
11101010
NAME Canvas Thing (7,4)

TIL 1du
01001001
10101010
10100100
01010101
10010100
01111111
11111111
10101011
NAME Canvas Thing (8,4)

TIL 1dv
01010101
10010010
10101001
01001010
10101010
11111111
11111111
10110111
NAME Canvas Thing (9,4)

TIL 1dw
01010101
01010101
00101000
10100101
10010101
11111111
11111111
01111101
NAME Canvas Thing (10,4)

TIL 1dx
11111010
11110101
11111010
11111010
11110101
11111010
11110101
11111010
NAME Canvas Thing (12,4)

TIL 1dy
10101010
01011101
10101010
10101010
01010101
10101010
01010101
10101010
NAME Canvas Thing (13,4)

TIL 1dz
10101010
01010101
10101010
10101001
01010100
10100101
01010100
10010010
NAME Canvas Thing (14,4)

TIL 1e0
10111111
01111111
10111111
01111111
10111111
01111111
10111111
01111111
NAME Canvas Thing (15,4)

TIL 1e1
11101011
11111011
11110101
11101111
11110111
11110111
11101101
11011011
NAME Canvas Thing (1,5)

TIL 1e2
11011000
11111111
11011111
11010111
11101011
11111111
11111111
11011111
NAME Canvas Thing (2,5)

TIL 1e3
11111111
11111111
11111111
11111111
11110111
11101011
11000111
11101011
NAME Canvas Thing (3,5)

TIL 1e4
11101110
10110111
11011010
10111111
11010101
10111011
11101101
10110111
NAME Canvas Thing (4,5)

TIL 1e5
11011100
01101100
11011100
01111100
11011111
01101101
10111100
01101101
NAME Canvas Thing (5,5)

TIL 1e6
10100101
00010101
00100101
00000101
11111111
10101011
10101011
01010100
NAME Canvas Thing (6,5)

TIL 1e7
10101010
01001001
10100100
01010101
11111110
11111111
01011011
10100100
NAME Canvas Thing (7,5)

TIL 1e8
11010100
10010011
10101001
00100101
10010100
11111111
01101010
10010101
NAME Canvas Thing (8,5)

TIL 1e9
01001001
10101010
01010010
00101001
10010101
11111111
10111111
01001010
NAME Canvas Thing (9,5)

TIL 1ea
00000010
10110101
10001001
01010100
00100101
11111111
11111111
11011011
NAME Canvas Thing (10,5)

TIL 1eb
11110100
11111010
11110101
11111000
11110101
11110101
11110100
11110010
NAME Canvas Thing (12,5)

TIL 1ec
10101001
10010101
01001010
10101001
11010100
10001010
10101001
10100101
NAME Canvas Thing (13,5)

TIL 1ed
01010101
00100101
10011001
01001010
10101001
01010100
01001010
00100101
NAME Canvas Thing (14,5)

TIL 1ee
00111111
01111111
00111111
10111111
00111111
10111111
10011111
01011111
NAME Canvas Thing (15,5)

TIL 1ef
11111011
11111111
11111011
11111111
11111010
11111111
11111010
11111101
NAME Canvas Thing (0,6)

TIL 1eg
11111111
01111101
11111111
11111111
11011111
11111111
11011111
01111011
NAME Canvas Thing (1,6)

TIL 1eh
11111111
10111111
11011110
10111111
10111110
11101101
10101010
10101110
NAME Canvas Thing (2,6)

TIL 1ei
10000011
11000011
01000010
01000011
00000001
01000001
10000101
00000101
NAME Canvas Thing (3,6)

TIL 1ej
11011101
10110110
11101101
10110111
01101101
10110110
01101101
11011011
NAME Canvas Thing (4,6)

TIL 1ek
11010100
10111101
11010110
01111100
10101010
11101100
10111101
01101100
NAME Canvas Thing (5,6)

TIL 1el
10001010
01010010
00001001
00101010
01001001
00011111
00010100
00010100
NAME Canvas Thing (6,6)

TIL 1em
01101010
10010010
01001011
01011101
01011011
00101010
10110101
00010101
NAME Canvas Thing (7,6)

TIL 1en
10101010
01001000
11010101
01010011
11010100
11001010
10010100
11101010
NAME Canvas Thing (8,6)

TIL 1eo
10101010
01001001
01010100
00100011
10010101
10101001
10100101
01010101
NAME Canvas Thing (9,6)

TIL 1ep
00100100
01010101
10100010
11010100
11010010
11001010
11101001
11010100
NAME Canvas Thing (10,6)

TIL 1eq
11110111
01010100
10001010
01100100
10010011
01001011
00101000
10100101
NAME Canvas Thing (11,6)

TIL 1er
11011001
01000100
10101010
10100100
00010010
10101010
01001001
00100101
NAME Canvas Thing (12,6)

TIL 1es
00101010
10010010
10101001
10010101
01001010
10111111
01111111
00111111
NAME Canvas Thing (13,6)

TIL 1et
10101000
01010101
01000101
00101001
10101010
01000100
11111111
11111111
NAME Canvas Thing (14,6)

TIL 1eu
10111111
00111111
01011111
00111111
10011111
10111111
11111111
11111111
NAME Canvas Thing (15,6)

TIL 1ev
11110111
11111101
11111101
11111110
11111011
11111110
11111011
11111101
NAME Canvas Thing (0,7)

TIL 1ew
01010111
10101101
01011011
11101101
01010111
11011101
01110111
11011111
NAME Canvas Thing (1,7)

TIL 1ex
10101011
10010101
10001010
10100101
10001010
10000101
10101010
00000101
NAME Canvas Thing (2,7)

TIL 1ey
00100101
10000101
00100100
10010101
10010001
01010101
10010101
01010100
NAME Canvas Thing (3,7)

TIL 1ez
01110110
10101101
11011011
01101010
10111111
01010001
11011110
01100101
NAME Canvas Thing (4,7)

TIL 1f0
11010110
10111111
01101010
11011110
01101100
10110100
11011111
01110110
NAME Canvas Thing (5,7)

TIL 1f1
00101000
00111111
00011011
00011111
00001111
10100111
11111111
11010110
NAME Canvas Thing (6,7)

TIL 1f2
01011010
01101111
11111010
11111111
11111110
11111111
11111110
01101110
NAME Canvas Thing (7,7)

TIL 1f3
10100101
11011100
10100110
11101001
10100101
11101010
01111111
10101011
NAME Canvas Thing (8,7)

TIL 1f4
00100101
10010100
10101010
01001001
00100101
10101010
11111111
11111111
NAME Canvas Thing (9,7)

TIL 1f5
01000010
10101010
00101001
01000101
01010101
01010010
11111111
11111111
NAME Canvas Thing (10,7)

TIL 1f6
10010100
01010010
01001010
01010101
00100100
10010010
11111101
11111111
NAME Canvas Thing (11,7)

TIL 1f7
10110100
10011010
01011001
01001010
10100101
01010100
10101010
11111111
NAME Canvas Thing (12,7)

TIL 1f8
10111111
01111111
00111111
10111111
01111111
00111111
11111111
11111111
NAME Canvas Thing (13,7)

TIL 1f9
11110111
11111010
11110111
11111101
11110110
11111101
11110111
11111011
NAME Canvas Thing (0,8)

TIL 1fa
01101101
11110111
01011101
11010111
10101011
11010110
01101011
11110101
NAME Canvas Thing (1,8)

TIL 1fb
10010010
01000101
01010011
00001000
01001011
10100100
11010010
01010010
NAME Canvas Thing (2,8)

TIL 1fc
10100100
01010100
10100100
10110100
01010100
10100100
11010100
10100100
NAME Canvas Thing (3,8)

TIL 1fd
10111011
11010101
10101110
11010101
10101010
10110110
11011011
11101111
NAME Canvas Thing (4,8)

TIL 1fe
10101111
01110110
11011111
10101010
11101111
10110101
11011011
01101101
NAME Canvas Thing (5,8)

TIL 1ff
01101011
11000000
11111111
10101101
11111110
01010111
11111010
01011111
NAME Canvas Thing (6,8)

TIL 1fg
11111010
01011111
11111111
10101010
11111111
10110111
11111111
10101111
NAME Canvas Thing (7,8)

TIL 1fh
10101101
11111111
11111111
10101010
11111111
11110110
11111011
11101110
NAME Canvas Thing (8,8)

TIL 1fi
01101101
10110111
11111111
11011011
10111110
11101011
10111110
11101011
NAME Canvas Thing (9,8)

TIL 1fj
11101110
01111011
11101111
01111101
11010111
11111101
10110111
11011101
NAME Canvas Thing (10,8)

TIL 1fk
11101111
10111110
11111111
01011111
11111111
01011111
11011111
01111111
NAME Canvas Thing (11,8)

TIL 1fl
11111111
11101111
11111101
11111111
11111111
11111111
11111111
11111111
NAME Canvas Thing (12,8)

TIL 1fm
11111111
11011111
11111111
11111111
11111111
11111111
11111111
11111111
NAME Canvas Thing (13,8)

TIL 1fn
11101101
11110111
11101011
11111101
11100111
11111010
11111011
11111101
NAME Canvas Thing (0,9)

TIL 1fo
10101110
01110101
10101011
01010101
10111010
11010110
01011011
01101101
NAME Canvas Thing (1,9)

TIL 1fp
11010101
01010101
01010101
01010010
10101010
10010001
01101101
01010010
NAME Canvas Thing (2,9)

TIL 1fq
01010100
00100101
01010101
00100101
10010101
01010101
01010100
01010101
NAME Canvas Thing (3,9)

TIL 1fr
11111111
01111101
11111110
11110111
11111101
11111111
11110110
11111111
NAME Canvas Thing (4,9)

TIL 1fs
10111011
11111101
10110110
11011011
01111101
11101110
10110101
11111111
NAME Canvas Thing (5,9)

TIL 1ft
01101010
10111111
11101010
01011111
10110101
11011011
01101110
10111011
NAME Canvas Thing (6,9)

TIL 1fu
11111011
10101101
11110110
01011010
11101101
01010101
11110110
10111101
NAME Canvas Thing (7,9)

TIL 1fv
11111011
10101110
11010111
10111010
01010111
10111011
10101101
10110110
NAME Canvas Thing (8,9)

TIL 1fw
10111110
11101011
01111101
11010110
01110111
10101101
11110110
10101101
NAME Canvas Thing (9,9)

TIL 1fx
11101111
01011010
11110111
10101101
01111011
11011110
11010101
10111111
NAME Canvas Thing (10,9)

TIL 1fy
10111111
10111111
10111111
01011111
11011111
10111111
11011111
01111111
NAME Canvas Thing (11,9)

TIL 1fz
11110110
11111011
10001000
11101101
10101010
11010101
10101010
11010101
NAME Canvas Thing (0,10)

TIL 1g0
10110111
11011011
00100100
10010010
01001001
01011111
00111111
10010111
NAME Canvas Thing (1,10)

TIL 1g1
11101101
01011011
01111111
11111111
01111111
11111111
11110011
11110111
NAME Canvas Thing (2,10)

TIL 1g2
10100100
11010101
11111111
11111111
10010111
10100101
11111001
11111110
NAME Canvas Thing (3,10)

TIL 1g3
11111101
11111111
11111111
11111111
11111111
01111111
00000000
11011011
NAME Canvas Thing (4,10)

TIL 1g4
11110101
11011110
11111011
11101101
11111011
11011101
01110110
01010101
NAME Canvas Thing (5,10)

TIL 1g5
01010101
11011111
01101010
10111101
01101011
10111110
11010101
11111011
NAME Canvas Thing (6,10)

TIL 1g6
01101011
10111111
11011011
11101111
01111101
11011111
10101101
11110110
NAME Canvas Thing (7,10)

TIL 1g7
11101011
01111101
11001011
11110110
11101111
11111010
10110111
11101111
NAME Canvas Thing (8,10)

TIL 1g8
01110111
11011101
01101011
11011101
10110110
11111111
11111011
10111111
NAME Canvas Thing (9,10)

TIL 1g9
01101010
11111111
01010101
10111011
11011101
01101111
11011010
11110110
NAME Canvas Thing (10,10)

TIL 1ga
11011111
01111111
10111111
11011111
01111111
10110111
10111111
11011111
NAME Canvas Thing (11,10)

TIL 1gb
10101010
11010101
11010101
10110110
11010101
11011010
10101011
11010101
NAME Canvas Thing (0,11)

TIL 1gc
01001000
00111010
10011010
01101011
11011101
10110110
01101011
10111010
NAME Canvas Thing (1,11)

TIL 1gd
00010110
11001110
01010111
11111101
01010110
11011011
01101101
10110101
NAME Canvas Thing (2,11)

TIL 1ge
11111110
10010110
01001110
10111111
11001111
01101011
10101111
10100011
NAME Canvas Thing (3,11)

TIL 1gf
10001001
10100100
10101111
11100010
11111010
11110110
00001010
01010001
NAME Canvas Thing (4,11)

TIL 1gg
01010110
01010101
11010111
11010101
11001011
11110101
11101011
11100101
NAME Canvas Thing (5,11)

TIL 1gh
10101101
11011111
01110101
11011010
01110111
10101100
11111011
01010111
NAME Canvas Thing (6,11)

TIL 1gi
01011010
11101011
01110101
11010101
10110110
11110101
01101010
11011011
NAME Canvas Thing (7,11)

TIL 1gj
10111110
01101111
01011111
01111111
10111111
01111111
10111111
01111111
NAME Canvas Thing (8,11)

TIL 1gk
11111101
11110111
11111101
11111110
11111111
11111111
11111111
01111111
NAME Canvas Thing (10,11)

TIL 1gl
10111111
01011111
10111111
11011111
01111111
10011111
11011111
10111111
NAME Canvas Thing (11,11)

TIL 1gm
11101110
10110101
11011011
11101101
11011010
11010111
10101000
10010101
NAME Canvas Thing (0,12)

TIL 1gn
11010111
01101010
10111010
11010110
10111011
11101100
01100101
01110010
NAME Canvas Thing (1,12)

TIL 1go
11110011
01110101
10110001
01110111
00110011
10010111
01010011
01101011
NAME Canvas Thing (2,12)

TIL 1gp
10101011
10100111
11111111
11111111
10111111
10001100
10101101
10011111
NAME Canvas Thing (3,12)

TIL 1gq
00110101
01010101
00111001
11111010
11111100
11011010
00100101
11010010
NAME Canvas Thing (4,12)

TIL 1gr
11010101
10010101
10101010
01001011
10101010
01001011
00101010
10101011
NAME Canvas Thing (5,12)

TIL 1gs
10101110
10110010
11101101
01011010
11110110
01011011
11110110
01001010
NAME Canvas Thing (6,12)

TIL 1gt
10101010
11101010
01011111
11111111
11001111
01111111
11101111
11111111
NAME Canvas Thing (7,12)

TIL 1gu
10111111
11111111
01011111
11111111
01011111
10111111
11101111
01011111
NAME Canvas Thing (8,12)

TIL 1gv
11101101
11111111
11101110
11111011
11111111
11111111
11111111
11111111
NAME Canvas Thing (9,12)

TIL 1gw
11011111
11011111
11011111
10111111
11011111
10111111
10111111
01011111
NAME Canvas Thing (11,12)

TIL 1gx
11011110
10111101
10101110
10111010
11011110
10110100
10111110
11010110
NAME Canvas Thing (0,13)

TIL 1gy
01101101
01101100
11110101
01101101
11110101
01100101
11010100
01101010
NAME Canvas Thing (1,13)

TIL 1gz
00010111
10100011
01111111
01111111
00000011
01010100
10110010
00111010
NAME Canvas Thing (2,13)

TIL 1h0
10111111
10000011
11010111
10010111
01010111
10010111
01010111
01001111
NAME Canvas Thing (3,13)

TIL 1h1
11110111
01110111
01001111
10100110
01010111
01001011
10100111
01101011
NAME Canvas Thing (4,13)

TIL 1h2
11101010
11101010
10101011
01010100
00101011
01001101
01010101
01010110
NAME Canvas Thing (5,13)

TIL 1h3
10110111
10101101
01010100
10101010
01010101
01110110
01011011
11010110
NAME Canvas Thing (6,13)

TIL 1h4
11011111
01100001
11011101
10100101
01110011
11001011
10111111
11011111
NAME Canvas Thing (7,13)

TIL 1h5
10110111
01111111
01010101
01101110
01010101
11011111
11111011
11111111
NAME Canvas Thing (8,13)

TIL 1h6
11111111
11111111
11111111
11111111
01011111
11101010
11111101
11111110
NAME Canvas Thing (9,13)

TIL 1h7
11111111
11111110
11111111
11111111
11101110
10110111
11011111
10110110
NAME Canvas Thing (10,13)

TIL 1h8
01111111
10111111
11011111
10111111
11011111
10111111
10111111
10111111
NAME Canvas Thing (11,13)

TIL 1h9
10111101
10101110
11011101
10111110
11011010
10111110
10101101
11011110
NAME Canvas Thing (0,14)

TIL 1ha
01100101
11111111
01111101
00001000
10100101
01010010
00001010
10111111
NAME Canvas Thing (1,14)

TIL 1hb
01110101
00110101
01110100
10110101
01111111
10111010
11110100
11111010
NAME Canvas Thing (2,14)

TIL 1hc
00100111
01010011
10011000
01000101
11110100
00001010
10100101
10101001
NAME Canvas Thing (3,14)

TIL 1hd
11111111
11111110
01100010
01110101
11100000
01110101
01110010
11111111
NAME Canvas Thing (4,14)

TIL 1he
00101011
10010001
01001100
00100010
10101010
00101001
10010101
11001011
NAME Canvas Thing (5,14)

TIL 1hf
01011101
00100100
10101010
10010101
01010010
10101001
11000101
10111010
NAME Canvas Thing (6,14)

TIL 1hg
01011111
10101111
01001111
01011111
01001111
01101111
01011111
11001110
NAME Canvas Thing (7,14)

TIL 1hh
11111111
11111111
11111111
11111101
11110111
11111111
10111111
11111111
NAME Canvas Thing (8,14)

TIL 1hi
01011101
11111101
11111110
11111101
11111110
11111010
10111101
11111101
NAME Canvas Thing (9,14)

TIL 1hj
11011111
01101111
10110110
11011111
11101011
11110111
11011111
11010111
NAME Canvas Thing (10,14)

TIL 1hk
10111111
10111111
11011111
10111111
10111111
10111111
10111111
10111111
NAME Canvas Thing (11,14)

TIL 1hl
10111101
11010110
10111110
10111010
11011110
10110110
10111101
11011110
NAME Canvas Thing (0,15)

TIL 1hm
00101110
10111110
01111110
10011110
01011100
10011010
00100100
10010010
NAME Canvas Thing (1,15)

TIL 1hn
01000100
10010010
01001010
10101010
01011111
10111111
10010000
10100110
NAME Canvas Thing (2,15)

TIL 1ho
10100100
01010101
10101011
10100100
11111111
11111111
00010011
11010111
NAME Canvas Thing (3,15)

TIL 1hp
01011111
00100111
10011110
01111111
11111111
11101000
11010101
11001010
NAME Canvas Thing (4,15)

TIL 1hq
10111001
00000101
10111111
11111111
11110110
00001001
10100100
01010010
NAME Canvas Thing (5,15)

TIL 1hr
11001000
11011011
11101001
11001100
10100010
00101010
10101010
10100101
NAME Canvas Thing (6,15)

TIL 1hs
01010111
01010111
01101111
11001111
01010111
11010111
01011111
01101111
NAME Canvas Thing (7,15)

TIL 1ht
11111101
11110111
11111111
11111111
11111110
11111111
11111111
11111111
NAME Canvas Thing (8,15)

TIL 1hu
11111101
11111101
10111101
11111101
11111101
11111101
11111101
11111110
NAME Canvas Thing (9,15)

TIL 1hv
11101110
01011111
11101011
01101111
11011101
01101111
01010111
10101101
NAME Canvas Thing (10,15)

TIL 1hw
10111111
10111111
10111111
10111111
10111111
10111111
10111111
10111111
NAME Canvas Thing (11,15)

TIL 1hy
00000000
00000000
00000010
00000000
00000010
00000100
00010000
00000001
NAME houseu (7,6)

TIL 1hz
00000000
10000000
01000000
00000000
10100000
00000000
00100000
00000100
NAME houseu (8,6)

TIL 1i0
00000001
00000000
00000101
00000000
00000101
00010000
00000000
01000100
NAME houseu (6,7)

TIL 1i1
01001000
00000001
01000100
00010000
00000001
01000100
00000000
10010010
NAME houseu (7,7)

TIL 1i2
00010001
00000000
01000100
00010000
00000001
00100100
00000000
01000100
NAME houseu (8,7)

TIL 1i3
00000000
10000000
01000000
00100000
00001000
00000000
01000100
00010000
NAME houseu (9,7)

TIL 1i4
00000000
00000000
00000001
00000000
00000000
00000000
00000000
00000001
NAME houseu (5,8)

TIL 1i5
10010000
01001010
00100010
10010100
01000010
10010100
01001001
00100010
NAME houseu (6,8)

TIL 1i6
01000001
10010100
00100010
10010100
01000010
10010100
00100010
01001000
NAME houseu (7,8)

TIL 1i7
00010001
01001010
10100001
00010100
10100010
01001001
10010100
01000010
NAME houseu (8,8)

TIL 1i8
01000101
00100000
00010101
10100100
01001001
00010010
10100100
00010010
NAME houseu (9,8)

TIL 1i9
00000000
10000000
00000000
00000000
00000000
00000000
10000000
00000000
NAME houseu (10,8)

TIL 1ia
00000000
00000000
00000001
00000000
00000000
00000000
00000001
00000000
NAME houseu (5,9)

TIL 1ib
10010100
01000010
00101001
01000100
10010010
01001001
00100100
10010010
NAME houseu (6,9)

TIL 1ic
10010010
01001001
00100100
10001001
00100100
01001011
00101101
10010110
NAME houseu (7,9)

TIL 1id
10010100
00100010
10010001
00100100
01001010
10110001
11010100
10110010
NAME houseu (8,9)

TIL 1ie
10100100
01001001
00010010
10100100
00010010
01001001
00100100
10010001
NAME houseu (9,9)

TIL 1if
10000000
00000000
00000000
10000000
00000000
00000000
00000000
00000000
NAME houseu (10,9)

TIL 1ig
00000000
00000001
00000000
00000000
00000000
00000001
00000000
00000000
NAME houseu (5,10)

TIL 1ih
01001000
00100010
01001001
10010010
01001001
00100100
10010010
01000100
NAME houseu (6,10)

TIL 1ii
01001101
10010110
00101101
01001011
00011101
10100110
00011011
10101101
NAME houseu (7,10)

TIL 1ij
11010100
10110001
11010100
01110010
10101001
10110100
01010010
11101001
NAME houseu (8,10)

TIL 1ik
01001010
00100001
10010100
01000100
00101001
10000100
01010010
00001001
NAME houseu (9,10)

TIL 1il
00000000
00000000
10000000
00000000
00000000
10000000
00000000
00000000
NAME houseu (10,10)

TIL 1im
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000001
NAME houseu (4,11)

TIL 1in
00000001
00000000
00000000
00000000
00001001
00100100
01000010
00101001
NAME houseu (5,11)

TIL 1io
00010010
01001001
10100100
00010010
01001000
10000010
00101000
00000100
NAME houseu (6,11)

TIL 1ip
01001101
00010110
10101101
00001010
10100000
00000001
10010100
01000001
NAME houseu (7,11)

TIL 1iq
01010100
11110010
01010100
10101001
00010000
00000010
01001000
00000010
NAME houseu (8,11)

TIL 1ir
10100100
00010010
10100100
00010010
01000100
00000000
10010010
00000000
NAME houseu (9,11)

TIL 1is
10000000
00000000
10000000
00000000
10010000
00000100
10010000
00000010
NAME houseu (10,11)

TIL 1it
00000000
00000000
00000000
00000000
00000000
00000000
00000000
01000000
NAME houseu (11,11)

TIL 1iu
00000100
00000101
00010101
00010101
00101010
00110110
00011011
00011111
NAME houseu (4,12)

TIL 1iv
10010010
01001001
00101010
10101010
10101010
11010101
01101101
10110110
NAME houseu (5,12)

TIL 1iw
01010010
01001001
00100100
10101010
10101010
01010101
10101010
11111101
NAME houseu (6,12)

TIL 1ix
00010100
01000010
01010100
10010010
10101001
01010101
10101010
11011011
NAME houseu (7,12)

TIL 1iy
01010000
00001010
10100001
01001010
00101001
01010100
10101010
01101011
NAME houseu (8,12)

TIL 1iz
01010100
00000000
01010010
00001000
01010010
10101010
10010100
01101011
NAME houseu (9,12)

TIL 1j0
10010000
00000101
10100000
00010101
10100000
10010110
10101001
01010110
NAME houseu (10,12)

TIL 1j1
00000000
00100000
00000000
01010100
00000100
11010100
00101000
11010000
NAME houseu (11,12)

TIL 1j2
00001010
00000111
00000011
00000000
00000000
00000000
00000000
00000000
NAME houseu (4,13)

TIL 1j3
11111011
10101111
11111010
11011111
00111101
00000111
00000000
00000000
NAME houseu (5,13)

TIL 1j4
01010110
11111011
10101110
11111011
11011110
01111011
11101111
00000101
NAME houseu (6,13)

TIL 1j5
10101101
11110110
10111011
11011111
11110101
10111111
11101101
10111111
NAME houseu (7,13)

TIL 1j6
10110101
11011110
01101011
11111101
01010111
11111101
10101111
11111010
NAME houseu (8,13)

TIL 1j7
10101101
11110110
01011011
11101101
01110111
10111101
11101110
10100000
NAME houseu (9,13)

TIL 1j8
01101010
10111011
11010101
01111110
10101000
11110000
00000000
00000000
NAME houseu (10,13)

TIL 1j9
10100000
01100000
10000000
00000000
00000000
00000000
00000000
00000000
NAME houseu (11,13)

TIL 1hx
01001011
11110111
11011111
11111011
10101111
11111111
11101111
10111111
NAME houseu (0,0)

TIL 1ja
11101111
11101001
11110010
11101100
11111000
11111010
11101010
11111000
NAME houseu (1,0)

TIL 1jb
11010010
00101111
11111111
11111110
01110111
01111111
01111101
10111111
NAME houseu (2,0)

TIL 1jc
11111011
11111101
10100111
11111101
11000010
11111111
11111110
10111011
NAME houseu (3,0)

TIL 1jd
11110111
11111111
11110100
00001011
11111111
11111110
11101111
11111011
NAME houseu (4,0)

TIL 1je
11111100
10100011
01011101
11111110
11010111
11111101
11011111
01110101
NAME houseu (5,0)

TIL 1jf
01101101
11110111
11101101
11101110
01110110
11101101
11111110
01101011
NAME houseu (6,0)

TIL 1jg
10101010
10110101
11010010
10101010
01010100
00100010
11011000
01010111
NAME houseu (7,0)

TIL 1jh
10100101
01010101
01001011
10101010
10010101
01010101
00000110
11010000
NAME houseu (8,0)

TIL 1ji
01010101
01011011
01101101
10101011
01011101
10101011
11110110
10101101
NAME houseu (9,0)

TIL 1jj
01010101
11101101
01010110
10111010
01101010
10101101
11011010
01101101
NAME houseu (10,0)

TIL 1jk
01010101
10101010
10101010
10110101
11010101
01010101
10101010
01010101
NAME houseu (11,0)

TIL 1jl
00000000
10010000
00001000
01000010
00010100
00010000
10001010
00100000
NAME houseu (12,0)

TIL 1jm
00000000
00000000
00000000
00000000
01000000
00000000
01000000
00000000
NAME houseu (13,0)

TIL 1jo
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00000100
NAME houseu (15,0)

TIL 1jp
11100011
11111111
10111111
11101011
10111111
11011111
11111111
10101111
NAME houseu (0,1)

TIL 1jq
11100110
11110000
11101110
11111111
11111111
11111111
11111111
11111010
NAME houseu (1,1)

TIL 1jr
01111111
01110110
01111111
01111111
10111111
11111111
11111110
10000001
NAME houseu (2,1)

TIL 1js
11111111
11111111
11111101
11110111
11111111
11111111
11111111
00000000
NAME houseu (3,1)

TIL 1jt
11011111
11111111
11111101
11110111
11111111
10111111
11111111
00011111
NAME houseu (4,1)

TIL 1ju
11111111
01101101
11011111
11111011
11101111
11111110
10111011
11011111
NAME houseu (5,1)

TIL 1jv
11111110
01101011
11011110
01101011
11111110
11110111
11111101
11101111
NAME houseu (6,1)

TIL 1jw
10101001
01010101
10110101
01010110
11011001
01101010
10101010
01010111
NAME houseu (7,1)

TIL 1jx
00101001
01010101
01010010
00001001
11110101
10110011
11110110
01110011
NAME houseu (8,1)

TIL 1jy
11011011
01110110
00010010
11111101
10101011
11111101
10101111
11110101
NAME houseu (9,1)

TIL 1jz
10110110
11011010
00100100
11111011
01011110
11101011
01111110
10101011
NAME houseu (10,1)

TIL 1k0
11011010
10100101
00010000
11101111
10110101
11011110
11110101
10111111
NAME houseu (11,1)

TIL 1k1
10010101
00100000
01010101
10001010
00101000
10010100
10010100
01010101
NAME houseu (12,1)

TIL 1k2
00101000
01000010
00010000
01000100
00100001
10010100
01000000
00101010
NAME houseu (13,1)

TIL 1k3
00000000
00001001
00100000
00000010
00001000
00100001
00000100
00100000
NAME houseu (14,1)

TIL 1k4
01000000
00010000
00000100
01000000
00010100
01000010
00010100
10000000
NAME houseu (15,1)

TIL 1k5
11111111
11010111
11111111
11010111
11111111
11101111
11110111
10110111
NAME houseu (0,2)

TIL 1k6
11110110
11111010
11110110
11110101
11110101
11111010
11110101
11110101
NAME houseu (1,2)

TIL 1k7
10111101
11010101
10101010
01010101
01011110
10101111
11111111
01111111
NAME houseu (2,2)

TIL 1k8
01011010
01010100
10100001
01010100
00101001
10010100
10100010
11111001
NAME houseu (3,2)

TIL 1k9
01001111
00011111
00001111
01011111
00001111
01001111
00011111
01001111
NAME houseu (4,2)

TIL 1ka
11111110
11111011
11101111
11111111
11111101
11000011
11000111
11100011
NAME houseu (5,2)

TIL 1kb
11101101
11111110
10110111
11111001
11110101
00110101
10111000
10001101
NAME houseu (6,2)

TIL 1kc
10111001
11010110
01111011
11010101
10111110
11000111
10011011
11111011
NAME houseu (7,2)

TIL 1kd
01011011
11110111
01110010
11101000
11101000
01101010
11110100
01101001
NAME houseu (8,2)

TIL 1ke
01011110
11110111
11111101
00000000
00000000
10010001
01001101
00100100
NAME houseu (9,2)

TIL 1kf
11111110
10101111
11011011
00001111
00001101
00100110
00010100
10001111
NAME houseu (10,2)

TIL 1kg
11010101
11111110
01101011
11111111
01011010
01110111
11010110
01101101
NAME houseu (11,2)

TIL 1kh
10010100
10010101
10101010
10011010
11010100
10011110
11010101
10011100
NAME houseu (12,2)

TIL 1ki
01010001
00101010
01001000
01010101
01010010
01010100
01010100
01010010
NAME houseu (13,2)

TIL 1kj
00001001
00100000
00001010
00100000
00010101
10001000
00100101
10010000
NAME houseu (14,2)

TIL 1kk
00101010
00000100
10101001
00000100
01010010
10001000
00100000
10000000
NAME houseu (15,2)

TIL 1kl
11111111
11110111
11110111
11011111
11111111
11110111
10111111
10111111
NAME houseu (0,3)

TIL 1km
11110101
11111010
11110010
11110111
11110111
11110111
11111111
11111111
NAME houseu (1,3)

TIL 1kn
01111111
10111111
00011111
11111111
11101111
10111111
11111111
11111111
NAME houseu (2,3)

TIL 1ko
11110110
10111111
11111111
11111111
11111111
11111111
11111111
11111111
NAME houseu (3,3)

TIL 1kp
10111111
11111111
11111111
11111111
11111111
11111101
11111111
11111111
NAME houseu (4,3)

TIL 1kq
11101011
11110111
11111111
11111111
11111011
11110111
11110111
11100111
NAME houseu (5,3)

TIL 1kr
10110100
01111000
11010100
11101000
10101000
11011000
11111100
11111100
NAME houseu (6,3)

TIL 1ks
10001111
01010110
01010111
00100111
01001111
00101110
01101100
11111100
NAME houseu (7,3)

TIL 1kt
11110100
11111010
11001101
10001010
00001010
00010101
00011010
00110001
NAME houseu (8,3)

TIL 1ku
10010101
10111111
01010101
01010100
10010010
01010101
11101101
10111110
NAME houseu (9,3)

TIL 1kv
01010111
11101111
00000000
10110101
10001010
01010001
10111110
00001011
NAME houseu (10,3)

TIL 1kw
10111011
11110000
00001010
01010010
10101001
00010101
11010101
00101010
NAME houseu (11,3)

TIL 1kx
11010110
00011101
10011110
01100010
01010001
01010100
11101011
01011000
NAME houseu (12,3)

TIL 1ky
01010101
01010100
01101011
01011010
01010101
00000000
01010000
10010010
NAME houseu (13,3)

TIL 1kz
00101000
00100000
00010101
01010010
00101010
00001001
10000000
00000000
NAME houseu (14,3)

TIL 1l0
00010010
00000000
01000000
10010010
01001010
01010100
00010010
00000001
NAME houseu (15,3)

TIL 1l1
11111111
11111111
11111111
11111011
11100011
01010111
11101111
11111111
NAME houseu (0,4)

TIL 1l2
11111111
11111111
11111101
11101010
11111100
11111110
11111111
11111111
NAME houseu (1,4)

TIL 1l3
11111111
00111111
01111111
00111111
00111111
01111111
11111111
11111111
NAME houseu (2,4)

TIL 1l4
11111111
11111111
11111111
11111111
11111110
11111100
11111100
11111001
NAME houseu (4,4)

TIL 1l5
11001111
10011111
10011111
00111111
01010111
11110111
11111111
11111111
NAME houseu (5,4)

TIL 1l6
11001100
10101100
11101101
10011101
10011110
10111100
11011111
11111111
NAME houseu (6,4)

TIL 1l7
11100000
11101000
01100010
01010101
01010001
10101101
11010111
11010101
NAME houseu (7,4)

TIL 1l8
01100000
10100110
01000010
11000011
10001011
10001101
10001101
00000101
NAME houseu (8,4)

TIL 1l9
11101000
01010011
01100110
01010100
01101101
00101001
01101111
11100010
NAME houseu (9,4)

TIL 1la
11100010
10111001
01000100
10111001
10101110
01101001
00111011
11010111
NAME houseu (10,4)

TIL 1lb
10000100
01001010
01100100
10010110
11010010
00101001
11010110
00101011
NAME houseu (11,4)

TIL 1lc
00101101
11000111
01011001
10001001
01101001
00100101
10100100
01011010
NAME houseu (12,4)

TIL 1ld
01001001
10101010
01101010
11110101
00110100
00101111
10101010
10010101
NAME houseu (13,4)

TIL 1le
01000000
10010000
01001010
00101001
10101010
01010101
11101010
10110010
NAME houseu (14,4)

TIL 1lf
00000000
00000000
00000000
01000000
10100000
00101010
10101010
10101001
NAME houseu (15,4)

TIL 1lg
11110011
11110011
11100111
11001111
11001111
10011111
00111111
01111111
NAME houseu (4,5)

TIL 1lh
11101111
11111011
11111110
11111111
11111100
11111110
11111101
11111100
NAME houseu (7,5)

TIL 1li
00010101
00010111
00111111
00011010
00101011
10000000
01111111
01111010
NAME houseu (8,5)

TIL 1lj
10101010
11101010
11111111
10110101
11111111
00000000
11111111
11110101
NAME houseu (9,5)

TIL 1lk
11101101
10101011
01011111
01010101
01010111
00000000
11111111
01001011
NAME houseu (10,5)

TIL 1ll
01010110
10101011
01101110
01010001
11101110
00100000
11111111
11011110
NAME houseu (11,5)

TIL 1lm
10101010
01000101
10111010
01111111
10101010
00000000
11101111
11110101
NAME houseu (12,5)

TIL 1ln
11110100
00000001
10101010
10101010
11010001
00000000
01011110
10101011
NAME houseu (13,5)

TIL 1lo
11011100
01101111
00010101
10101011
01001010
00000000
10110101
01011010
NAME houseu (14,5)

TIL 1lp
11010101
00101101
11001010
01110101
10111101
00001011
01111110
11010111
NAME houseu (15,5)

TIL 1lq
11111111
11110111
01011111
10111111
11111111
11111111
11111111
11111111
NAME houseu (0,6)

TIL 1lr
11111110
11111100
11111001
11110001
11110011
11100111
11000111
11001111
NAME houseu (3,6)

TIL 1ls
01111111
11111111
11111111
11111110
11111101
11111111
11111110
11110100
NAME houseu (4,6)

TIL 1lt
11111011
00000011
10100111
11011111
10111111
11111111
01111111
11111111
NAME houseu (5,6)

TIL 1lu
11111111
11111111
11111111
10100011
11101011
10101111
11111111
01101111
NAME houseu (6,6)

TIL 1lv
11111010
11111001
11111100
11110101
11111000
11100101
11110101
11101001
NAME houseu (7,6)

TIL 1lw
01011110
01011110
11111111
11110111
10111111
11111111
11111011
11111111
NAME houseu (8,6)

TIL 1lx
11110101
11110111
11110111
11110111
11110110
11110110
10111110
10111011
NAME houseu (9,6)

TIL 1ly
10101110
10111001
10110111
11110110
11111110
11011111
11001011
11010101
NAME houseu (10,6)

TIL 1lz
01111011
10111101
10110110
11111110
11011011
11111111
01101111
10111111
NAME houseu (11,6)

TIL 1m0
01011011
10101111
10010000
11011110
11111011
11101101
10010000
11111111
NAME houseu (12,6)

TIL 1m1
11010110
01101111
10000000
11011111
01101101
10110110
00001001
01101101
NAME houseu (13,6)

TIL 1m2
10110101
01101011
10010010
01001000
10111101
11011011
01101111
10110110
NAME houseu (14,6)

TIL 1m3
10001101
01011011
10110111
11111100
10110110
11111001
10110110
11001000
NAME houseu (15,6)

TIL 1m4
11111111
11111111
11111111
11111111
11011111
11111111
11111111
11111111
NAME houseu (0,7)

TIL 1m5
11111111
11111111
11111110
11111010
11001000
11111000
11110001
11110001
NAME houseu (2,7)

TIL 1m6
10011111
00011111
00010101
00101010
01101010
00011011
11101101
11110110
NAME houseu (3,7)

TIL 1m7
11111011
01111111
10101111
11010111
01111111
10111111
01111111
11111111
NAME houseu (4,7)

TIL 1m8
11010111
11011111
11111111
11100011
10011111
00100110
01010111
10101111
NAME houseu (7,7)

TIL 1m9
11111101
11101101
11111111
11101101
11111101
11110101
11111101
11011111
NAME houseu (8,7)

TIL 1ma
10111111
10111011
11111111
10111011
11111111
10111011
10111011
10111011
NAME houseu (9,7)

TIL 1mb
11111111
11101101
01101101
01001011
01111110
01110110
11110101
11110111
NAME houseu (10,7)

TIL 1mc
10111111
10001111
11111011
01001111
11100111
11100110
11100111
01111110
NAME houseu (11,7)

TIL 1md
11011011
11101101
01111110
11110000
10011011
11101100
01101100
11101111
NAME houseu (12,7)

TIL 1me
11111110
10010100
11011111
00100011
00110110
00111111
11111101
11011011
NAME houseu (13,7)

TIL 1mf
11011011
01111110
10110110
11111011
11101101
11110110
10111011
00000000
NAME houseu (14,7)

TIL 1mg
01110110
01011001
11101101
11110110
11011011
11101101
01110111
11011011
NAME houseu (15,7)

TIL 1mh
11111111
11111111
11111111
11111111
11111111
11111110
11111100
11111100
NAME houseu (1,8)

TIL 1mi
11100011
11100111
11001111
10001111
00001111
00001111
00110011
01111110
NAME houseu (2,8)

TIL 1mj
11111110
11111101
11111100
11111010
11111010
11111010
11111011
11111101
NAME houseu (6,8)

TIL 1mk
00001110
00101101
10111111
01011111
10111011
11111011
00111111
11111111
NAME houseu (7,8)

TIL 1ml
11011111
11111111
11111111
11111111
11111011
00111011
10111011
11101011
NAME houseu (8,8)

TIL 1mm
11111011
10111011
10111011
10111001
10111001
11111111
10111111
10111111
NAME houseu (9,8)

TIL 1mn
11111111
10111111
10111011
10000010
10111011
11111111
11011101
11010101
NAME houseu (10,8)

TIL 1mo
01110111
11110111
10111111
10111000
01111100
11011101
11011100
01010110
NAME houseu (11,8)

TIL 1mp
11111110
01110111
11111111
10101101
11001111
11111101
01101111
00101111
NAME houseu (12,8)

TIL 1mq
11101110
01111111
11111111
10111001
11001100
11111110
01100110
01110011
NAME houseu (13,8)

TIL 1mr
11101111
01110111
11111111
10011001
10001000
11101110
01110111
00100011
NAME houseu (14,8)

TIL 1ms
11011101
01101110
11111111
10111111
00011011
11101111
01111111
01110111
NAME houseu (15,8)

TIL 1mt
11111000
11111100
11110011
11100011
11100111
11000111
10001111
10001111
NAME houseu (1,9)

TIL 1mu
11011111
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME houseu (2,9)

TIL 1mv
11001010
11111111
11010100
11111110
11111110
11111111
11111111
11111111
NAME houseu (3,9)

TIL 1mw
00111111
11010111
11111111
10111111
11111111
11111111
11111111
11111111
NAME houseu (4,9)

TIL 1mx
11110101
11110110
11101010
11010011
11001100
10111001
01000100
10100010
NAME houseu (6,9)

TIL 1my
00110111
11111111
11111111
11111111
11111111
11101111
11111111
11111110
NAME houseu (7,9)

TIL 1mz
10111011
11111011
01111011
01111110
01111111
11111111
11111111
10001000
NAME houseu (8,9)

TIL 1n0
11111111
10111111
10111101
10111101
10111101
10111101
10111101
00001001
NAME houseu (9,9)

TIL 1n1
11011101
11011111
11010110
10100000
11111110
11101111
11101111
01101111
NAME houseu (10,9)

TIL 1n2
11111110
11101111
11100111
00111111
11110111
01010111
11011111
11111111
NAME houseu (11,9)

TIL 1n3
11111111
01110101
01111101
11111011
11111100
10101110
11101110
11011111
NAME houseu (12,9)

TIL 1n4
01110111
10011001
10011110
11111101
11100110
11100110
01110111
11111111
NAME houseu (13,9)

TIL 1n5
11111011
10011100
11001110
11101111
01110111
01110011
00111011
11111111
NAME houseu (14,9)

TIL 1n6
11011101
11101110
11110111
11111111
00111101
10111101
11001110
11111111
NAME houseu (15,9)

TIL 1n7
11111111
11111110
11111100
11111100
11111000
11110001
11110001
11100011
NAME houseu (0,10)

TIL 1n8
00011111
00111111
01111111
01111111
11111111
11111111
11111111
11111111
NAME houseu (1,10)

TIL 1n9
11111111
11111110
11111110
11111101
11111101
11111100
11111011
11110100
NAME houseu (5,10)

TIL 1na
01011011
01010101
10101011
01010111
10100011
01010111
10001111
00101111
NAME houseu (6,10)

TIL 1nb
11011110
11111110
11011111
11111110
11111111
11111111
10111111
11111101
NAME houseu (7,10)

TIL 1nc
11110111
11010111
11110111
11110111
11110111
11111111
11110111
10111111
NAME houseu (8,10)

TIL 1nd
10111101
10111101
10111101
10111110
11111111
10111111
10111110
10111111
NAME houseu (9,10)

TIL 1ne
11101111
11011111
11111111
11110111
11111111
11110111
11111101
11101111
NAME houseu (10,10)

TIL 1nf
11111011
01111111
11111101
10100000
11111101
10111110
11111110
11011010
NAME houseu (11,10)

TIL 1ng
11000110
11100011
11100111
00100000
11110111
11110001
11111001
11111000
NAME houseu (12,10)

TIL 1nh
10111001
01011010
10111100
01111011
10111111
11101111
11000111
11111011
NAME houseu (13,10)

TIL 1ni
10011110
11001110
11110111
11111111
11111011
01111001
00111101
10011110
NAME houseu (14,10)

TIL 1nj
11111111
11110111
01111011
11111111
10111110
11111111
11111111
11111011
NAME houseu (15,10)

TIL 1nk
11000111
10000111
00001110
00010111
00011111
00101111
01111111
10011011
NAME houseu (0,11)

TIL 1nl
11111111
11111111
11101111
11111111
10111011
01111010
11110111
01110111
NAME houseu (1,11)

TIL 1nm
11111111
11111111
11111111
11111111
11011011
01110111
11111111
10111111
NAME houseu (2,11)

TIL 1nn
11110001
11110001
11110100
11001010
11100101
10111010
11101001
10101101
NAME houseu (5,11)

TIL 1no
01001111
00101111
10101111
00101111
01011110
10111111
01011111
01111111
NAME houseu (6,11)

TIL 1np
01111101
11111111
11111101
11111111
11111011
11111011
11111011
11111111
NAME houseu (7,11)

TIL 1nq
11111101
11111111
11111111
11111111
11101111
11101111
11111111
11111111
NAME houseu (8,11)

TIL 1nr
10111111
11111110
11111111
11111110
11111111
11111111
11111110
11111110
NAME houseu (9,11)

TIL 1ns
11111011
11111011
11111011
11111011
11111011
11111001
00000000
11111111
NAME houseu (10,11)

TIL 1nt
00000000
11011111
11111111
11101111
11100111
10100111
00000101
11111111
NAME houseu (11,11)

TIL 1nu
00000011
01111101
01111100
10111110
10111110
10111110
10011111
11011111
NAME houseu (12,11)

TIL 1nv
11101111
11111111
11110101
00111101
00111101
10111100
11111111
01111111
NAME houseu (13,11)

TIL 1nw
11111111
11011111
11101111
11101111
01111111
11111111
11110111
11111111
NAME houseu (14,11)

TIL 1nx
11111111
11111111
01111100
11111100
10101110
11001111
11111111
11101011
NAME houseu (15,11)

TIL 1ny
11110101
01111111
11111111
11111111
11111111
11111111
11111111
10111010
NAME houseu (0,12)

TIL 1nz
01101111
11111101
01111111
11111011
11011111
01101111
11110111
01011110
NAME houseu (1,12)

TIL 1o0
01111011
11111111
11001111
11111111
11111111
10111111
11111111
11111111
NAME houseu (2,12)

TIL 1o1
11111111
11111111
11111111
11111110
11111101
11111110
11111101
11111011
NAME houseu (4,12)

TIL 1o2
10010010
10100100
01010001
01010100
01010101
01010010
01001011
00101000
NAME houseu (5,12)

TIL 1o3
01111111
10111101
00111111
11111101
01111111
01111011
11111111
11110111
NAME houseu (6,12)

TIL 1o4
11111111
11111111
11110111
11110111
11111111
11111111
11111111
11111111
NAME houseu (7,12)

TIL 1o5
11111110
11111110
11111110
10111110
10111110
10001010
10111111
11111111
NAME houseu (9,12)

TIL 1o6
11111101
11111101
11111101
11111101
11111101
11110000
11111101
01111110
NAME houseu (10,12)

TIL 1o7
11110111
11110111
11110110
11110111
11110111
01011011
11111011
11111011
NAME houseu (11,12)

TIL 1o8
11011111
11011111
11101111
11101101
11111111
11110111
11110111
11111111
NAME houseu (12,12)

TIL 1o9
10101110
10000110
11001111
11000111
11111011
11111111
11101111
11111111
NAME houseu (13,12)

TIL 1oa
11111110
11111101
11111100
11111110
11111110
11111111
11111111
11111111
NAME houseu (14,12)

TIL 1ob
11110011
01110001
10111000
01111010
01011100
11111111
01111110
10111111
NAME houseu (15,12)

TIL 1oc
11101101
01101111
11111111
01011110
10101011
11111111
11110111
01111101
NAME houseu (0,13)

TIL 1od
11111011
11111111
11011111
11111111
01110111
11111111
11101111
11011111
NAME houseu (1,13)

TIL 1oe
11111001
11111000
11110101
11100100
11101011
11100010
11011010
11101001
NAME houseu (4,13)

TIL 1of
01000100
00010011
11000101
01111101
01100111
00001011
11101111
01011111
NAME houseu (5,13)

TIL 1og
11111111
11111111
11111111
11111111
11101111
11111111
11111111
11111111
NAME houseu (6,13)

TIL 1oh
11111111
11111111
11111111
11011111
11111111
10001010
11111111
10111111
NAME houseu (8,13)

TIL 1oi
10111111
10111111
10111111
10111111
10111111
10101011
11111111
10111111
NAME houseu (9,13)

TIL 1oj
01111110
01111110
01111110
01111110
01111110
01010000
11111111
01111111
NAME houseu (10,13)

TIL 1ok
11111011
11111101
11111101
11111111
11111111
10111001
11111111
01111111
NAME houseu (11,13)

TIL 1ol
11111111
11111111
11111011
11111111
11111111
11010111
11111111
11111110
NAME houseu (12,13)

TIL 1om
11111111
11111111
11111111
11111111
11111100
11011111
11111111
11111100
NAME houseu (13,13)

TIL 1on
11111111
11101111
11111111
11110111
01110101
10100001
11111011
10111101
NAME houseu (14,13)

TIL 1oo
10111111
11011111
11011111
11101111
11100011
11111111
11111011
11111001
NAME houseu (15,13)

TIL 1op
11011011
11111011
11111100
11101111
11011111
11111011
11111111
11111111
NAME houseu (0,14)

TIL 1oq
01111111
11111111
11111111
10111111
11111111
11111111
11111111
11111111
NAME houseu (1,14)

TIL 1or
11000110
11011000
10101101
11010011
01011011
10101111
10111011
10111101
NAME houseu (4,14)

TIL 1os
10111111
11111111
11111111
01111111
11101111
11111111
10111111
11111111
NAME houseu (5,14)

TIL 1ot
11111111
11011111
11111111
11111111
10111111
10111111
10111111
01111111
NAME houseu (7,14)

TIL 1ou
10111111
10111111
10111111
10111111
10111111
11111111
10111111
00010000
NAME houseu (8,14)

TIL 1ov
10111111
10111111
10111111
10111111
10111111
00111111
10111111
00100111
NAME houseu (9,14)

TIL 1ow
01111111
01111111
01111111
10111111
00111111
10111111
10111111
10011111
NAME houseu (10,14)

TIL 1ox
11111111
01111111
01111111
11111111
11111111
11111111
11111111
11010111
NAME houseu (11,14)

TIL 1oy
11111111
11111111
01111111
11111111
11111111
11111111
11111111
11111111
NAME houseu (12,14)

TIL 1oz
11111110
11111110
01111111
11111111
11111111
10111111
11111111
11100000
NAME houseu (13,14)

TIL 1p0
01011100
00111110
00111110
00001110
00011111
00000011
10001111
10111111
NAME houseu (14,14)

TIL 1p1
11111101
10111101
11111110
01111110
00101111
00110111
10101111
10010111
NAME houseu (15,14)

TIL 1p2
01111111
01111111
11111111
11111101
10111111
11101111
11111101
11101111
NAME houseu (4,15)

TIL 1p3
10111111
11111111
11111111
11111111
11111110
01111110
11111100
01111101
NAME houseu (5,15)

TIL 1p4
11111111
11111111
01111111
11111111
11111111
11111110
11111110
11111110
NAME houseu (6,15)

TIL 1p5
11111111
01111111
11111111
01111111
01111111
01111111
11111111
11111111
NAME houseu (7,15)

TIL 1p6
11111111
01111111
01111111
01111111
01111111
01111111
11111111
01111111
NAME houseu (8,15)

TIL 1p7
11111111
00111111
10111111
00111111
00111111
00111111
10111111
00111111
NAME houseu (9,15)

TIL 1p8
11111111
11111111
11111111
11111111
11111111
11111111
11111111
11101111
NAME houseu (12,15)

TIL 1p9
11111111
11011111
11011111
11011111
11101111
11101111
11101111
11100111
NAME houseu (13,15)

TIL 1pa
11011111
11001011
11000111
11100011
11100001
11100101
11110000
11110010
NAME houseu (14,15)

TIL 1pb
11011111
11011111
11101011
11100101
11110010
11110111
11111001
11111001
NAME houseu (15,15)

TIL 1jn
11111111
11111111
11111111
11111011
11111111
11111111
11111111
11111111
NAME earthbound (1,0)

TIL 1pc
10110100
11010000
11101011
11010001
11111010
11101010
11111101
11111110
NAME earthbound (8,0)

TIL 1pd
10010000
01001001
01000000
01110100
10010010
01001000
00100000
10010000
NAME earthbound (9,0)

TIL 1pe
01000101
00000000
00000000
01010000
00000010
00001000
01000000
00010101
NAME earthbound (10,0)

TIL 1pf
11111101
00000110
10100010
00000000
00000000
00001010
00000011
01111110
NAME earthbound (11,0)

TIL 1pg
11101111
10101011
00010101
10000110
00100011
11100100
11100010
11110001
NAME earthbound (12,0)

TIL 1ph
11111111
11111111
10111111
11111111
01111111
11011111
10111111
01011011
NAME earthbound (13,0)

TIL 1pi
11111111
11111111
11111111
11111111
11111111
11111101
11010110
00010011
NAME earthbound (14,0)

TIL 1pj
11111111
11111111
11111111
11111111
11111111
11111111
11110110
01010010
NAME earthbound (15,0)

TIL 1pk
11111111
11111111
11111111
11111111
11111111
11111111
11110001
11111111
NAME earthbound (1,1)

TIL 1pl
11111111
11111111
11111111
11111111
11111111
11111011
11111111
11111111
NAME earthbound (2,1)

TIL 1pm
11111111
11111111
11111111
11111111
11111111
11111111
11110101
11111000
NAME earthbound (3,1)

TIL 1pn
11111111
11111111
11111111
11111111
11111111
11111111
11111111
00000001
NAME earthbound (4,1)

TIL 1po
11111110
11111111
11111111
11111111
11111110
11111111
11111110
11111001
NAME earthbound (8,1)

TIL 1pp
10000001
01001001
10111111
11100110
10110101
01000111
10100001
10010110
NAME earthbound (9,1)

TIL 1pq
01011111
11111111
11111111
11111111
11111111
11111111
01111111
11111111
NAME earthbound (10,1)

TIL 1pr
11111011
10101000
11001010
11100100
11010001
11010100
11101101
11011111
NAME earthbound (11,1)

TIL 1ps
10110001
01110101
10110001
01011000
00111000
10111000
01011000
01111000
NAME earthbound (12,1)

TIL 1pt
01010101
00101110
01110101
10010111
10101010
00101010
10001010
00000000
NAME earthbound (13,1)

TIL 1pu
10101010
10101010
01000000
01010010
10000000
00000000
00001010
00000100
NAME earthbound (14,1)

TIL 1pv
11001010
00000101
00101010
00000100
00000000
00010000
00000000
00000000
NAME earthbound (15,1)

TIL 1pw
01111111
10111111
11111111
11111011
11100011
11100111
11100111
11011111
NAME earthbound (0,2)

TIL 1px
11100000
11111110
11111111
11111111
11011111
10111111
10101111
10111111
NAME earthbound (4,2)

TIL 1py
01111111
01111111
10011111
10011111
11011111
11001110
11111100
11111111
NAME earthbound (5,2)

TIL 1pz
11111111
11111101
11110111
11010000
00100101
10000000
01000000
00010000
NAME earthbound (6,2)

TIL 1q0
10101111
01101111
10010010
01001111
00101011
00001111
01000110
00010110
NAME earthbound (7,2)

TIL 1q1
11110100
11010010
10111110
01110011
11101101
10010000
00100000
01000000
NAME earthbound (8,2)

TIL 1q2
10010101
10100111
10010101
10101111
11111111
11111000
00010000
00000001
NAME earthbound (9,2)

TIL 1q3
11111111
11111111
11111110
11100000
00000100
00010000
01000000
00000010
NAME earthbound (10,2)

TIL 1q4
11111111
11111010
10000000
00000001
00001000
01000000
00000100
00010001
NAME earthbound (11,2)

TIL 1q5
11111001
10011111
00010101
01000010
00010101
10001001
01010100
00001010
NAME earthbound (12,2)

TIL 1q6
00001001
11000000
01110000
10010100
01010110
01010101
10101011
10110110
NAME earthbound (13,2)

TIL 1q7
00010001
00000000
00000000
00000010
01001000
00100000
10110100
11010100
NAME earthbound (14,2)

TIL 1q8
00000000
00000000
01001000
00000101
00101010
00010111
10101011
00010111
NAME earthbound (15,2)

TIL 1q9
11101111
00101111
11101111
11111111
11111111
11111111
11111111
11111111
NAME earthbound (0,3)

TIL 1qa
11111111
11111111
11111111
11111111
11111111
11111111
11111101
10111100
NAME earthbound (1,3)

TIL 1qb
11111111
11111111
11111111
11111111
11111111
01111111
11111111
00010000
NAME earthbound (2,3)

TIL 1qc
11111101
11110111
11111111
11110111
11111111
10000001
11100000
00001111
NAME earthbound (3,3)

TIL 1qd
11010111
11101011
10100111
11100011
10100110
01011101
00000111
11110000
NAME earthbound (4,3)

TIL 1qe
11111010
11111111
11111110
11111111
11110111
11011111
11010101
00000101
NAME earthbound (5,3)

TIL 1qf
11101001
11111110
10001011
11111110
11111111
11111111
01111111
11111111
NAME earthbound (6,3)

TIL 1qg
00001100
10011000
11011100
11001001
11110010
11111101
11110110
00001100
NAME earthbound (7,3)

TIL 1qh
01000100
10000000
00010000
00000001
01000100
00000000
00000000
01001000
NAME earthbound (8,3)

TIL 1qi
10000000
00001000
00100000
00000000
00000100
00100000
10000000
00000100
NAME earthbound (9,3)

TIL 1qj
00000000
00100000
10000100
00000000
00010000
10000010
00000000
00010001
NAME earthbound (10,3)

TIL 1qk
01000000
00001010
00100000
10000100
00010010
01000000
00010101
00000010
NAME earthbound (11,3)

TIL 1ql
01010010
00101010
10010101
01001010
10101010
01010101
00101010
10101011
NAME earthbound (12,3)

TIL 1qm
10101101
11011011
01101111
10110101
11011110
01101011
10110111
01011101
NAME earthbound (13,3)

TIL 1qn
11111010
01111101
10110101
11111010
11011101
11110100
01111110
11011110
NAME earthbound (14,3)

TIL 1qo
10011111
01011111
01011011
10111110
01010000
00100100
01000000
00101010
NAME earthbound (15,3)

TIL 1qp
11011111
01111111
10110111
11111111
01101111
10111111
11101111
01111111
NAME earthbound (0,4)

TIL 1qq
11111111
10111111
11111111
10111111
11011110
11011111
11111110
11011111
NAME earthbound (1,4)

TIL 1qr
11111101
11111111
01101101
11011111
11111010
10111111
11101101
10111111
NAME earthbound (2,4)

TIL 1qs
00001010
01101010
11001011
01101010
10101011
11010011
01101011
01001011
NAME earthbound (3,4)

TIL 1qt
10101111
10000101
01010111
10001000
10100111
11000111
10000110
11001110
NAME earthbound (4,4)

TIL 1qu
11110111
01001010
11101111
00001010
10101101
01010111
01011010
10101111
NAME earthbound (5,4)

TIL 1qv
11111111
11111111
11111111
11111111
11111101
10111111
11111110
11111011
NAME earthbound (6,4)

TIL 1qw
11110110
11101010
11000100
01110101
11101100
01001010
11011000
10111010
NAME earthbound (7,4)

TIL 1qx
00000000
00000010
01001000
00000000
00000010
01001000
00000000
00000100
NAME earthbound (8,4)

TIL 1qy
00010000
01000000
00000010
00001000
01000000
00000100
10010000
00000010
NAME earthbound (9,4)

TIL 1qz
10000100
00000000
00100101
00000000
10010101
00000001
10101010
00001001
NAME earthbound (10,4)

TIL 1r0
01010101
00001001
01010101
00100101
01010101
00101010
10101010
01010101
NAME earthbound (11,4)

TIL 1r1
01010101
00101010
01010110
01011011
01101010
10101101
10110110
01011011
NAME earthbound (12,4)

TIL 1r2
11101111
10110110
11011111
01110101
11011111
10110110
11101111
01111011
NAME earthbound (13,4)

TIL 1r3
11110111
11011111
11111101
10111111
11110111
11111111
10111111
11110111
NAME earthbound (14,4)

TIL 1r4
00000000
00000000
00000000
10000000
10000010
11000011
11000001
11000001
NAME earthbound (15,4)

TIL 1r5
10101111
01110111
10111111
10101111
01010111
10110110
10111011
10110110
NAME earthbound (0,5)

TIL 1r6
11101110
11111111
11101010
11101110
11100101
11101010
11100101
11110010
NAME earthbound (1,5)

TIL 1r7
11101101
10111111
11101110
10111111
11101111
01011111
01101011
10101111
NAME earthbound (2,5)

TIL 1r8
10110011
11010011
10110011
11010101
01110011
11010011
10110011
11010001
NAME earthbound (3,5)

TIL 1r9
10000110
11001110
10001100
10101110
10001100
10001100
00001000
10001001
NAME earthbound (4,5)

TIL 1ra
01011101
10101111
10111010
01011111
00100010
10011001
01001010
00101010
NAME earthbound (5,5)

TIL 1rb
11111110
10111111
11101111
01011010
01000101
00101101
00000110
01101010
NAME earthbound (6,5)

TIL 1rc
11101000
01011100
11011000
10001010
00001000
00100101
10101000
10100101
NAME earthbound (7,5)

TIL 1rd
10010000
00000010
10001000
00100000
00001010
01000000
00010010
00000000
NAME earthbound (8,5)

TIL 1re
01001000
00000010
10101001
00000010
01010001
00001010
10100100
00010010
NAME earthbound (9,5)

TIL 1rf
10100100
00010101
01010101
01001010
00101001
10101010
10101010
10010101
NAME earthbound (10,5)

TIL 1rg
10010101
01010110
01010101
10101011
01011010
10101011
10101101
01101011
NAME earthbound (11,5)

TIL 1rh
10101101
11110111
01011010
01101111
10110101
11011110
01101011
01011101
NAME earthbound (12,5)

TIL 1ri
10101110
11111111
10101011
01111111
11101101
10111111
11101110
01111011
NAME earthbound (13,5)

TIL 1rj
11111110
11011111
01111011
11111111
11111111
11011111
11111111
11111111
NAME earthbound (14,5)

TIL 1rk
11100001
11110001
11100001
11100101
11100000
11000001
11100000
11000000
NAME earthbound (15,5)

TIL 1rl
10010111
10010101
10100000
10111101
10011111
10101111
01001111
10010111
NAME earthbound (0,6)

TIL 1rm
11100100
01010001
00001000
01000100
00100010
11111101
11111111
11111111
NAME earthbound (1,6)

TIL 1rn
01101101
00100000
10000100
01010010
00001000
01000101
11110100
11111111
NAME earthbound (2,6)

TIL 1ro
10100011
00000000
00000000
10100100
01010001
00000100
10100000
11010101
NAME earthbound (3,6)

TIL 1rp
00001000
00000000
00000000
00000000
00000000
10000000
00000000
01010101
NAME earthbound (4,6)

TIL 1rq
01001010
00000000
10100000
00000000
00000000
00000000
00000000
01000000
NAME earthbound (5,6)

TIL 1rr
00000101
00000000
00000000
00000000
00000000
00000000
00000000
00000000
NAME earthbound (6,6)

TIL 1rs
00010100
00000010
00000101
00000010
00000010
00000100
00000011
00000001
NAME earthbound (7,6)

TIL 1rt
01010101
00000000
01010101
00000000
10101010
01000101
00101000
01000101
NAME earthbound (8,6)

TIL 1ru
01001010
10101001
00010101
10100101
01010010
00101010
10010101
01010101
NAME earthbound (9,6)

TIL 1rv
01010101
01010101
01010101
01010110
10101010
10101010
01010110
01011011
NAME earthbound (10,6)

TIL 1rw
01011101
01100110
10111011
10101010
10101111
11011010
10110111
01101101
NAME earthbound (11,6)

TIL 1rx
10110111
11101101
01011111
11110101
10111111
11010101
01111111
11010110
NAME earthbound (12,6)

TIL 1ry
11011111
01111111
11101011
10111111
01111110
11101111
11111111
10111011
NAME earthbound (13,6)

TIL 1rz
11111111
01110111
11111111
11111111
11111111
11111111
11111111
11111111
NAME earthbound (14,6)

TIL 1s0
11000000
11000000
11000000
11000000
10000000
10000000
10000000
10000000
NAME earthbound (15,6)

TIL 1s1
01001111
00001111
10100111
00010111
01000111
01010001
00010000
01000000
NAME earthbound (0,7)

TIL 1s2
01001010
11101111
11111111
11111111
11111111
11111111
11111111
11111111
NAME earthbound (4,7)

TIL 1s3
10111110
11101010
11111111
11111111
11111111
11111111
11111111
11111111
NAME earthbound (5,7)

TIL 1s4
10100100
11011011
11101000
11110110
11111101
11111111
11111101
11110100
NAME earthbound (6,7)

TIL 1s5
00000101
01101000
10010100
10100000
10101000
01000000
00000010
00000000
NAME earthbound (7,7)

TIL 1s6
01010100
10101010
11010101
01110101
00110110
00011101
00001110
00000011
NAME earthbound (8,7)

TIL 1s7
10101010
10010101
01010101
01010101
10101011
10110101
11011110
11101011
NAME earthbound (9,7)

TIL 1s8
10101010
01101101
10110110
01010101
01101110
10110111
11011010
01101111
NAME earthbound (10,7)

TIL 1s9
10110110
11011011
10110110
11011111
11101011
01111110
11011011
11111111
NAME earthbound (11,7)

TIL 1sa
11111111
10110110
11111111
10101101
11111111
11111111
11011111
11111111
NAME earthbound (12,7)

TIL 1sb
11111111
11111111
11111110
11111100
11111100
11111000
11110000
11100000
NAME earthbound (14,7)

TIL 1sc
00000000
00000000
00000000
00000000
00000000
00000000
00010000
01000000
NAME earthbound (15,7)

TIL 1sd
00000000
10100001
00000100
10100001
01001000
00100100
10011001
10101010
NAME earthbound (0,8)

TIL 1se
00111111
00111111
01011111
00101111
10110111
10101011
00101111
11010011
NAME earthbound (1,8)

TIL 1sf
11111111
11111111
11111111
11111100
11110010
11000000
10010000
00000000
NAME earthbound (5,8)

TIL 1sg
11110100
11010000
01000010
00001000
00000000
00000000
00000000
00000000
NAME earthbound (6,8)

TIL 1sh
00000001
00000000
00000010
00001001
00000001
00000101
00000011
00000001
NAME earthbound (7,8)

TIL 1si
01000001
01101000
11110000
11111100
11111100
11111110
11111110
11111110
NAME earthbound (8,8)

TIL 1sj
10111101
01111111
00011111
00000111
00010010
00001001
00100010
10000000
NAME earthbound (9,8)

TIL 1sk
11111011
10111111
11111111
11111111
11111111
01011111
01000100
00101010
NAME earthbound (10,8)

TIL 1sl
01011111
11111111
11111111
11111111
11111111
11111111
10101010
10101010
NAME earthbound (11,8)

TIL 1sm
11111111
11111111
11111111
11111111
11111111
11110110
10011010
10100100
NAME earthbound (12,8)

TIL 1sn
11111111
11111111
11111110
11111000
11010000
10100000
10000000
00000001
NAME earthbound (13,8)

TIL 1so
11000000
00000010
00000000
00001001
00000011
00100011
00000111
00000011
NAME earthbound (14,8)

TIL 1sp
00000000
00000000
11100000
11111000
11111000
11111100
11111000
11111100
NAME earthbound (15,8)

TIL 1sq
10110111
10111111
11011101
11110111
10111111
11101111
01011111
00111110
NAME earthbound (0,9)

TIL 1sr
01111110
10110111
11011101
11111111
01101010
11111110
11011110
11111111
NAME earthbound (1,9)

TIL 1ss
11111111
11111111
01011111
01011111
10101111
10010111
00001101
01011010
NAME earthbound (2,9)

TIL 1st
10100000
11101010
11111010
11111111
11111111
11111111
11111111
11111111
NAME earthbound (5,9)

TIL 1su
00000000
00010000
01000000
00000000
11101000
11010101
11111010
11111010
NAME earthbound (6,9)

TIL 1sv
00000101
00000001
00000000
00000000
01000000
00000000
00000000
10100000
NAME earthbound (7,9)

TIL 1sw
11111110
11111110
10111110
01011101
00000010
00000000
00000000
00000000
NAME earthbound (8,9)

TIL 1sx
00000000
10000000
00000000
00000010
00000000
00000000
00000000
00001001
NAME earthbound (9,9)

TIL 1sy
10000000
00000010
00000000
00000000
00100000
00000100
00000000
00000000
NAME earthbound (10,9)

TIL 1sz
00100100
00000010
00010000
00000000
00000000
10000000
00001000
00000000
NAME earthbound (11,9)

TIL 1t0
10010000
00000000
00000000
00000001
00000100
10010000
00000000
00000000
NAME earthbound (12,9)

TIL 1t1
00000000
00001000
00100000
00000000
00000000
00000010
00010000
00000000
NAME earthbound (13,9)

TIL 1t2
00000111
00010001
00000000
10000000
00000000
00000000
00000100
00000000
NAME earthbound (14,9)

TIL 1t3
11111000
11110000
10101000
00000000
00000000
00000000
00000000
00100000
NAME earthbound (15,9)

TIL 1t4
10010111
01011111
11011011
01101110
10101011
11101101
10111111
11111011
NAME earthbound (0,10)

TIL 1t5
11010101
11111111
11111111
11111111
11110111
01111111
11111111
11111101
NAME earthbound (1,10)

TIL 1t6
10101110
11111101
10111111
11111011
01111111
11101111
01111101
11110110
NAME earthbound (2,10)

TIL 1t7
10111111
11011111
01000111
11110111
01011010
01001101
10010110
10101100
NAME earthbound (3,10)

TIL 1t8
11111111
11111111
11111111
11111111
11111111
00111111
00011111
00101111
NAME earthbound (4,10)

TIL 1t9
01001000
10100100
11110010
11111010
11111101
11111111
11111111
11111111
NAME earthbound (7,10)

TIL 1ta
00001000
00100000
10000000
00000000
01000000
01010000
10101010
11100100
NAME earthbound (8,10)

TIL 1tb
00000000
00100000
00000000
00000000
00000000
00000000
00000000
10000000
NAME earthbound (9,10)

TIL 1tc
00000000
00010001
00000000
00000000
00000000
00000000
00000000
00000000
NAME earthbound (10,10)

TIL 1td
00000001
00010000
00000000
00000000
00000000
00000010
00000000
00100000
NAME earthbound (11,10)

TIL 1te
00000000
00000100
00010000
00000000
10000000
00000000
00000000
00000000
NAME earthbound (12,10)

TIL 1tf
10000000
00000000
00000000
00000010
00000000
00000000
00000000
00010000
NAME earthbound (13,10)

TIL 1tg
00000000
00000000
00000000
00010000
00000001
00000100
00010010
10101010
NAME earthbound (14,10)

TIL 1th
00000010
00000001
00010101
01001011
00101111
10111111
10111111
11111111
NAME earthbound (15,10)

TIL 1ti
11111111
11111101
11111111
11111110
11111111
11111111
11111111
11111111
NAME earthbound (2,11)

TIL 1tj
10101010
11011101
01110100
11011010
01111110
11011010
11110101
11010111
NAME earthbound (3,11)

TIL 1tk
00111111
00011111
00111111
01111111
10111111
01011110
01101111
11111111
NAME earthbound (4,11)

TIL 1tl
11111111
11111111
11111111
11111101
10110110
11001010
11000100
11010000
NAME earthbound (5,11)

TIL 1tm
11111111
11111111
11111111
10001111
10001111
00011111
01001111
00010110
NAME earthbound (6,11)

TIL 1tn
11111111
11111111
11111111
11111111
11111110
11111010
11111010
11011000
NAME earthbound (7,11)

TIL 1to
10110010
11101000
11101010
10100000
10000000
00000000
00000010
00000000
NAME earthbound (8,11)

TIL 1tp
00000000
10000000
00000001
00000100
00010000
00000000
00000000
00000000
NAME earthbound (9,11)

TIL 1tq
00000000
00000100
00000000
00000000
00000000
00000000
00000000
00000000
NAME earthbound (10,11)

TIL 1tr
00000000
00000000
00000000
00000000
00100000
00001000
00100100
00010010
NAME earthbound (12,11)

TIL 1ts
00000000
00000010
00000000
10000001
00000000
00000000
00000000
10000000
NAME earthbound (13,11)

TIL 1tt
00001001
10100010
00010101
01000110
00010011
00000100
01000000
00000001
NAME earthbound (14,11)

TIL 1tu
01111111
10111111
11111111
11111111
11111111
11111111
00011111
00001111
NAME earthbound (15,11)

TIL 1tv
11111111
11111111
11111111
11111111
11111110
11101011
11011110
10000101
NAME earthbound (2,12)

TIL 1tw
11101011
10100111
11100001
10100000
11010000
10000000
00000000
00000001
NAME earthbound (3,12)

TIL 1tx
11111111
11110111
00001111
00001111
00001111
00111111
01011111
01111111
NAME earthbound (4,12)

TIL 1ty
11000000
11100000
11100000
11101010
11110100
11110110
11111011
11111111
NAME earthbound (5,12)

TIL 1tz
00001011
00000111
00100001
10000000
01000000
10000000
10000000
01000100
NAME earthbound (6,12)

TIL 1u0
11101000
01010000
10000000
00000000
00000010
00000001
10010001
01000111
NAME earthbound (7,12)

TIL 1u1
10001000
00000000
00000000
10100100
11010000
11000000
11001000
11010100
NAME earthbound (8,12)

TIL 1u2
00100000
00000000
00000000
01000000
00000000
00000000
00000001
00000010
NAME earthbound (9,12)

TIL 1u3
00000010
00000000
00010101
00001001
01010010
10001001
01010100
00101010
NAME earthbound (10,12)

TIL 1u4
10000000
01000000
00000000
00000000
00000000
00010000
01000000
00000000
NAME earthbound (11,12)

TIL 1u5
00001001
00000100
00010010
00000001
10001010
00000001
00001000
00000010
NAME earthbound (12,12)

TIL 1u6
00000000
10101000
00010000
01001010
11010001
01101010
10111010
10111111
NAME earthbound (13,12)

TIL 1u7
00000100
00010000
00000000
00000000
00000000
01000000
10100000
00010100
NAME earthbound (14,12)

TIL 1u8
01000010
00101001
00000000
00101010
10000101
00000000
00000010
00001000
NAME earthbound (15,12)

TIL 1u9
11111111
11111111
11111111
11110100
11100000
11001001
11100110
11011111
NAME earthbound (1,13)

TIL 1ua
10000110
10000111
00000011
00000001
00100000
01010000
10110100
11111000
NAME earthbound (2,13)

TIL 1ub
10000000
10000010
00000001
01000001
00000001
00000101
00000101
00100111
NAME earthbound (3,13)

TIL 1uc
11111111
11111111
11111111
11111111
10111111
11011111
11111111
11111111
NAME earthbound (4,13)

TIL 1ud
11111111
11111110
11111110
11111110
11111110
11111101
11111111
11111111
NAME earthbound (5,13)

TIL 1ue
00000011
00101111
10011111
01011111
10111111
11111111
01111111
11111111
NAME earthbound (6,13)

TIL 1uf
11110111
11010111
10110010
11010000
01100000
10111011
10010111
11011111
NAME earthbound (7,13)

TIL 1ug
11101000
10110100
11101000
01100000
11010000
11000010
11100001
10001111
NAME earthbound (8,13)

TIL 1uh
00000101
01001010
00010101
00101010
10111101
01111011
11111110
11110111
NAME earthbound (9,13)

TIL 1ui
01001101
01010100
01111010
10101000
11111010
10101000
11111010
11101000
NAME earthbound (10,13)

TIL 1uj
00000000
00000000
00000000
00010000
00000000
00000000
00000000
00100001
NAME earthbound (11,13)

TIL 1uk
00000000
00000010
00000000
00000001
00000000
00000000
01000000
00000000
NAME earthbound (12,13)

TIL 1ul
10101111
01111111
00101111
01011111
00101111
10010111
00101111
10010111
NAME earthbound (13,13)

TIL 1um
11010000
11101010
11110101
11111010
11111110
11111111
11111111
11111111
NAME earthbound (14,13)

TIL 1un
00100000
00000000
00000000
10000000
01000000
10100100
11010000
11110100
NAME earthbound (15,13)

TIL 1uo
11111111
11111110
11111110
11111100
11111000
11110000
11101100
11011000
NAME earthbound (0,14)

TIL 1up
10101111
01011110
00001101
00000100
00010011
01000101
00010111
00010111
NAME earthbound (1,14)

TIL 1uq
11111101
11111011
01111010
00100011
00110111
00011111
10111111
11001111
NAME earthbound (2,14)

TIL 1ur
00000111
10101010
11111100
01111110
10111111
11111111
11111111
11111111
NAME earthbound (3,14)

TIL 1us
11111111
00111111
10001111
00011111
10101111
11010111
11111111
11111111
NAME earthbound (4,14)

TIL 1ut
11010111
01011111
10111111
01111111
11111111
11111111
11111111
11111111
NAME earthbound (8,14)

TIL 1uu
11111111
11101111
11111111
11011111
10111111
10111111
00111111
00111111
NAME earthbound (9,14)

TIL 1uv
10110100
11101000
11110000
10101000
11100100
11110000
11001000
11100000
NAME earthbound (10,14)

TIL 1uw
00000000
00000000
00001000
10000000
00000000
00000000
00000000
00010000
NAME earthbound (11,14)

TIL 1ux
00000000
00000000
00000000
00000000
00000000
00000000
00000000
00100000
NAME earthbound (12,14)

TIL 1uy
00010111
01001111
00010111
00001011
01001111
00000101
00100111
00010011
NAME earthbound (13,14)

TIL 1uz
11111000
11111110
11111111
11111111
11111111
11111111
11111111
11111111
NAME earthbound (15,14)

TIL 1v0
01110000
00000010
01001011
10101111
11010111
11101011
11110110
11111001
NAME earthbound (0,15)

TIL 1v1
01001111
00101010
10000100
11000000
10000101
01000000
00010101
01000001
NAME earthbound (1,15)

TIL 1v2
11101111
10100011
00000011
00000001
00000101
10000101
00000110
01101011
NAME earthbound (2,15)

TIL 1v3
11111111
11111111
11111111
11110111
11111011
11110111
11111111
10111111
NAME earthbound (3,15)

TIL 1v4
11111110
11111100
11111000
11111000
11110000
11110000
11100000
11000000
NAME earthbound (8,15)

TIL 1v5
01111111
00111111
11111111
01111111
01111111
01111111
00111010
01111000
NAME earthbound (9,15)

TIL 1v6
11010000
11010000
11001000
11010000
01000000
11010000
01000000
00000000
NAME earthbound (10,15)

TIL 1v7
01000000
00000001
00000001
00000010
10000010
00000101
00000010
00001010
NAME earthbound (11,15)

TIL 1v8
10010001
01111000
01001000
10001010
10101100
00110100
01010010
11101010
NAME earthbound (12,15)

TIL 1v9
00000111
00010011
00000101
00000011
00001001
00000010
00000001
00000001
NAME earthbound (13,15)

TIL 1va
11111111
11111111
11111111
11111111
11111101
11111101
11111001
01110001
NAME earthbound (14,15)

TIL 1vb
11110101
11110110
11110101
11110110
11111010
11111011
11101101
11110101
NAME line (0,0)

TIL 1vc
01010111
11011001
01101101
10101010
10101011
11010101
01011101
01101010
NAME line (1,0)

TIL 1vd
11111111
10111101
01010101
11010110
01101011
01011011
10101111
11011111
NAME line (2,0)

TIL 1ve
11111111
11101101
00101010
11110101
11110110
11101110
10101111
01011110
NAME line (3,0)

TIL 1vf
01101010
01101010
10101101
01111111
10111111
11110101
01010110
10111010
NAME line (4,0)

TIL 1vg
10101010
11010101
01010110
11111111
11111111
10111111
10101101
11010110
NAME line (5,0)

TIL 1vh
10101010
10110101
10101011
11110101
11111111
11111111
11111111
11011111
NAME line (6,0)

TIL 1vi
11111010
10010101
01101011
01010101
11111111
11111111
11101010
11111101
NAME line (7,0)

TIL 1vj
11101011
11101011
11111101
11011101
11111111
11111111
11111111
01011011
NAME line (8,0)

TIL 1vk
11010110
11101010
11101101
11010101
11111010
11111111
11111111
01111011
NAME line (9,0)

TIL 1vl
11111010
11110101
01110110
11110101
11010101
11111111
11111111
11101010
NAME line (10,0)

TIL 1vm
11111010
01111010
11111101
00110101
11111010
11111111
11111111
10111111
NAME line (11,0)

TIL 1vn
10101011
11010111
01011011
10101111
11011011
11111011
11111111
11111111
NAME line (12,0)

TIL 1vo
11011110
11011101
11111110
10111010
11011101
11101010
11111111
11111111
NAME line (13,0)

TIL 1vp
10101010
01010110
10111010
11001011
01110101
10101101
11110110
11111010
NAME line (14,0)

TIL 1vq
10101111
10111111
11011111
01011111
01101111
10101111
10111111
11001111
NAME line (15,0)

TIL 1vr
11110111
11110101
11110101
11110110
11110101
11110110
11111011
11101010
NAME line (0,1)

TIL 1vs
01010110
01101010
10110101
10101111
01101111
10111111
01111101
11111010
NAME line (1,1)

TIL 1vt
10111101
11111011
11110111
11011010
10101011
01101110
10101010
11111111
NAME line (2,1)

TIL 1vu
10111111
11101111
11111111
11111111
11111111
10111111
11011111
01011111
NAME line (3,1)

TIL 1vv
01110110
01111010
01110101
11111010
11111111
11111111
11111110
10111111
NAME line (4,1)

TIL 1vw
10110101
11010101
01111011
11111110
11111111
11111111
10111111
11010101
NAME line (5,1)

TIL 1vx
10110011
11011010
01010111
10101111
11011111
11111011
11111101
11111111
NAME line (6,1)

TIL 1vy
01111111
11011111
01101101
10101010
11111011
11111111
01111111
10110111
NAME line (7,1)

TIL 1vz
11010101
11111011
11111111
11011111
01101101
01010110
11101011
11111101
NAME line (8,1)

TIL 1w0
01111011
01111101
01010111
10110111
11010111
10101111
01101111
10101110
NAME line (9,1)

TIL 1w1
11011101
11010110
11011011
10101010
11011010
01101011
10101101
10101010
NAME line (10,1)

TIL 1w2
11111011
01111101
11111010
11011101
11110101
01111011
11110101
11111101
NAME line (11,1)

TIL 1w3
01101111
10110101
10101011
10110111
01010111
01011011
10101111
01101011
NAME line (12,1)

TIL 1w4
11011010
11111101
10011010
11111110
10111010
11111101
10111101
10111010
NAME line (13,1)

TIL 1w5
11111101
10110111
11010101
10110101
11010110
01011010
10101011
11101010
NAME line (14,1)

TIL 1w6
01101111
01011111
01101111
01001111
10101111
11011111
01011111
10101111
NAME line (15,1)

TIL 1w7
11110111
11111011
11101111
11110101
11110101
11110110
11110101
11110110
NAME line (0,2)

TIL 1w8
11110110
11011011
10101010
01101101
01010101
11011010
01010111
11011001
NAME line (1,2)

TIL 1w9
11111111
01010101
10111010
11010110
01011011
10101011
01101111
10101111
NAME line (2,2)

TIL 1wa
10101111
01111110
10111111
11111101
11101111
11111110
10101110
01111111
NAME line (3,2)

TIL 1wb
10111111
11110111
01111101
01111010
11110110
10111101
11010111
10110111
NAME line (4,2)

TIL 1wc
11111101
11111111
01111111
11111111
10111111
01111111
11110111
11010110
NAME line (5,2)

TIL 1wd
10111111
10110111
11011011
11110101
11111110
11111111
01011111
10101111
NAME line (6,2)

TIL 1we
11110101
11111110
01111111
10111111
11011011
10101101
11110110
11111111
NAME line (7,2)

TIL 1wf
11111111
10110111
01011011
11101101
11111101
11111111
11011111
10110111
NAME line (8,2)

TIL 1wg
11010110
11111010
11111111
01111111
10011011
01101101
11011010
11110110
NAME line (9,2)

TIL 1wh
11011010
10101011
10110101
10101101
01010110
10110101
11010101
10101101
NAME line (10,2)

TIL 1wi
11110110
01111011
01111010
11110110
11111011
01110101
11111011
01110101
NAME line (11,2)

TIL 1wj
10110111
01010111
11011011
10101111
01101011
01010111
01101111
10110111
NAME line (12,2)

TIL 1wk
01111101
10111011
11111010
01111010
10111011
11111010
01011101
10111110
NAME line (13,2)

TIL 1wl
01010101
01101101
10110101
11010110
01011010
11010101
01010101
11011010
NAME line (14,2)

TIL 1wm
01101111
10111111
01011111
10111111
11011111
01011111
10111111
10111111
NAME line (15,2)

TIL 1wn
11110101
11110110
11110101
11110110
11110101
11110110
11110101
11110110
NAME line (0,3)

TIL 1wo
01010110
11011010
01010101
11011011
01010111
10101111
10111111
11011110
NAME line (1,3)

TIL 1wp
10111110
10111101
11111111
11110111
11111111
11111011
11110111
10101111
NAME line (2,3)

TIL 1wq
11111111
11101111
11101101
11111110
11011111
11111101
11011111
10101111
NAME line (3,3)

TIL 1wr
10101111
01111111
10101111
10111111
01111111
11111011
11101101
11010110
NAME line (4,3)

TIL 1ws
01011110
10101111
11101010
11101111
11010110
01101111
10110110
10101111
NAME line (5,3)

TIL 1wt
11010101
01110110
10011010
11110101
11111110
01011111
11101111
00110111
NAME line (6,3)

TIL 1wu
11111111
10111111
11011111
10110101
11010110
10110101
11110110
11111101
NAME line (7,3)

TIL 1wv
11011011
11111101
11111110
11111111
11111111
01011111
10101011
11010111
NAME line (8,3)

TIL 1ww
11111111
11111111
10111111
11010101
11110110
11111011
11111111
11111111
NAME line (9,3)

TIL 1wx
01010101
11110110
11111010
11111110
11111111
01101111
10110111
11110101
NAME line (10,3)

TIL 1wy
11011110
11110101
11111010
11010110
11111010
11111101
11111111
11111111
NAME line (11,3)

TIL 1wz
10101011
01010111
11011011
10110111
11010111
01101011
01101111
10110111
NAME line (12,3)

TIL 1x0
11111101
01111011
10111100
10111011
11011101
01111010
10111011
10111010
NAME line (13,3)

TIL 1x1
01101101
10101010
10101011
01110101
10010110
11101010
00110101
11011011
NAME line (14,3)

TIL 1x2
10111111
10111111
01011111
01111111
10111111
11011111
01111111
01011111
NAME line (15,3)

TIL 1x3
11111010
11101010
11101101
11101111
11101011
11101111
11011110
11111101
NAME line (0,4)

TIL 1x4
10111101
11111011
11110101
11111111
11111111
10110111
11011011
01010111
NAME line (1,4)

TIL 1x5
01011111
01111110
01011010
11111111
11111111
11111111
11011111
01101111
NAME line (2,4)

TIL 1x6
01011111
11101110
10111101
11111111
11111111
11111111
11011011
10101101
NAME line (3,4)

TIL 1x7
11011011
10101101
11110101
11011010
11111111
11111111
01101111
10110101
NAME line (4,4)

TIL 1x8
11101110
11101111
11101011
11111110
11111111
11111111
11110110
11011011
NAME line (5,4)

TIL 1x9
11011010
01010110
01101011
10110101
11111111
11111111
11101111
01011010
NAME line (6,4)

TIL 1xa
11111111
11011111
01011011
01101101
10101010
11011011
01110111
11110111
NAME line (7,4)

TIL 1xb
01011111
11111110
11111101
11111110
11111111
11110111
11101011
11011101
NAME line (8,4)

TIL 1xc
01111111
10101111
10101010
11101011
10110101
11111101
11111110
01111111
NAME line (9,4)

TIL 1xd
11111110
11111111
11111111
01111111
10101111
01010101
10110101
11010111
NAME line (10,4)

TIL 1xe
11111111
01110111
11111011
11111010
11111111
11111111
01111111
11111111
NAME line (11,4)

TIL 1xf
11110111
11111011
01111111
11101011
01010111
11011011
11101111
11110101
NAME line (12,4)

TIL 1xg
10111011
11111011
01011111
10111011
11011111
01111011
01011111
01111011
NAME line (13,4)

TIL 1xh
11010101
01101101
10101010
10110101
11010110
01011010
10101010
11010110
NAME line (14,4)

TIL 1xi
01111111
10111111
10111111
10111111
11011111
10111111
11011111
10111111
NAME line (15,4)

TIL 1xj
11111010
11101101
11101011
11101111
11010111
11111011
11010111
11101111
NAME line (0,5)

TIL 1xk
10111111
10110111
11111111
11111111
11111111
10101011
11011111
01010111
NAME line (1,5)

TIL 1xl
10101111
01111110
11111110
11111111
11111111
11111111
11101101
10110111
NAME line (2,5)

TIL 1xm
11110101
10010110
10111111
11111111
11111111
11111111
11011101
11010110
NAME line (3,5)

TIL 1xn
01011111
11101001
10101111
11111111
11111111
11111111
11011011
01101101
NAME line (4,5)

TIL 1xo
11101101
11110110
11101101
11111111
11111111
11111011
11101101
11101011
NAME line (5,5)

TIL 1xp
01101011
10110101
11011010
11111111
11111111
10111111
01010111
10111111
NAME line (6,5)

TIL 1xq
01110111
11111111
10111110
11111111
11111111
11111111
11111101
11111111
NAME line (7,5)

TIL 1xr
10101010
01101011
10110111
11111111
11111111
11111111
10110110
11011011
NAME line (8,5)

TIL 1xs
11011111
01111111
11111111
11110110
11111111
11111111
11011011
01101101
NAME line (9,5)

TIL 1xt
11111111
11111111
11111111
10111111
11111111
11111111
01111010
01111101
NAME line (10,5)

TIL 1xu
11111111
01111101
11111110
11101101
11111111
11111111
01111111
11101110
NAME line (11,5)

TIL 1xv
11101010
01011101
11010101
01101101
01010110
01101010
10110101
10101110
NAME line (12,5)

TIL 1xw
10111011
11011111
01111011
10111111
10111011
11011111
01111011
11111111
NAME line (13,5)

TIL 1xx
01101010
10110110
11011010
10101011
11010101
11110110
10101010
11011011
NAME line (14,5)

TIL 1xy
10111111
11111111
10111111
01011111
01111111
10111111
11011111
01111111
NAME line (15,5)

TIL 1xz
11101111
11110111
11011011
11101101
11101011
11110110
11011010
11101011
NAME line (0,6)

TIL 1y0
11111111
11111111
11111011
01110111
01101011
11011101
10101011
01101101
NAME line (1,6)

TIL 1y1
11111111
11111111
11101111
11111110
11011111
11101111
11111111
11011111
NAME line (2,6)

TIL 1y2
11111111
11111111
10111111
11011010
01101111
10111111
01011111
10111111
NAME line (3,6)

TIL 1y3
11111111
11111111
11111111
11101101
01010111
10111011
01101011
11011011
NAME line (4,6)

TIL 1y4
11111111
11111111
11111111
11111111
11111011
11111111
11110111
11101111
NAME line (5,6)

TIL 1y5
11111111
11111111
11111111
01011111
10111111
01111110
11111101
11111011
NAME line (6,6)

TIL 1y6
11111111
11111111
11111111
01111111
11111111
11111111
11110111
11111011
NAME line (7,6)

TIL 1y7
01010101
11111110
11111101
01101010
10110101
10101111
10111111
11011101
NAME line (8,6)

TIL 1y8
01010101
10110101
10101011
10110111
11101111
11111111
10111111
01110111
NAME line (9,6)

TIL 1y9
11111111
11111011
11111010
11110101
11101101
11011110
11111101
11010110
NAME line (10,6)

TIL 1ya
11110111
11101111
11110110
11101111
11101111
11011011
11110111
11111011
NAME line (11,6)

TIL 1yb
01010101
10110101
11011010
01010110
11011011
11010101
11101101
10110101
NAME line (12,6)

TIL 1yc
01011011
10111111
11111011
10111111
01111011
01111111
10111011
01011111
NAME line (13,6)

TIL 1yd
11101101
10101010
10101101
11011110
10111110
10101110
11011111
10111101
NAME line (14,6)

TIL 1ye
01011111
10111111
10111111
11011111
10111111
11011111
01111111
01011111
NAME line (15,6)

TIL 1yf
11101101
11110101
11010110
11101011
11111101
11010101
11101101
11110110
NAME line (0,7)

TIL 1yg
10110111
01010101
11011011
01101101
10101011
01010111
10111011
11010101
NAME line (1,7)

TIL 1yh
11101111
11011111
11101110
11111111
11011111
11101111
11111111
11011110
NAME line (2,7)

TIL 1yi
01111110
10111110
10111111
11011110
01111110
01011111
01111101
10111111
NAME line (3,7)

TIL 1yj
11010111
11111011
01010111
10111111
11011111
01111111
11111111
11110101
NAME line (4,7)

TIL 1yk
11110111
11101111
11111111
11111111
11111111
11101111
11111111
11111111
NAME line (5,7)

TIL 1yl
11111111
11100111
11011111
10101111
01111110
10111111
01111101
11111011
NAME line (6,7)

TIL 1ym
11101111
11110111
11111011
01110111
10111011
11111101
01111101
01011110
NAME line (7,7)

TIL 1yn
11010110
11101111
10111111
11110111
11011111
11101101
11111010
11110111
NAME line (8,7)

TIL 1yo
11111111
11011110
11011111
01111111
01111010
11110101
11101110
11110101
NAME line (9,7)

TIL 1yp
01010101
11111101
11111111
01111111
10101111
10101011
11011010
01101101
NAME line (10,7)

TIL 1yq
11101111
01110111
11111011
11110111
11111011
11111011
11111101
01110111
NAME line (11,7)

TIL 1yr
11010110
11011011
11011101
11101110
10101110
11010101
11101101
10110110
NAME line (12,7)

TIL 1ys
11111011
01011111
10111011
11011111
10110111
10111111
01111011
11011111
NAME line (13,7)

TIL 1yt
11011110
10111110
11111111
11011101
11011111
10111101
11111110
11011110
NAME line (14,7)

TIL 1yu
10111111
11011111
01111111
01011111
01111111
10111111
10111111
10111111
NAME line (15,7)

TIL 1yv
11011010
11101011
11110111
11011010
11101101
11110111
11011010
11101101
NAME line (0,8)

TIL 1yw
10101101
01110111
10101011
10111011
10101101
01110101
11010111
10111011
NAME line (1,8)

TIL 1yx
11011111
11101111
11011111
11111111
11011111
11101111
11011111
11101110
NAME line (2,8)

TIL 1yy
11011101
01111111
10111111
01011111
11111111
01011101
10111110
11111101
NAME line (3,8)

TIL 1yz
11111011
11101111
11101011
01101111
11110111
11101111
11111111
01111111
NAME line (4,8)

TIL 1z0
11111111
11111111
11111111
11111111
11111111
11101111
11111111
11111111
NAME line (5,8)

TIL 1z1
11110110
11101101
11110111
11011101
10111101
01111110
10101011
11110111
NAME line (6,8)

TIL 1z2
11111011
01011101
10111110
01101111
10111111
10101111
01110110
10101111
NAME line (7,8)

TIL 1z3
01111001
11101111
11110111
01011011
01101101
10101010
11010111
01111111
NAME line (8,8)

TIL 1z4
11010101
11010110
10101011
01110101
10011111
11111111
11111110
11101011
NAME line (9,8)

TIL 1z5
10101010
11011011
01111111
11111110
11110111
11011110
10101011
01110101
NAME line (10,8)

TIL 1z6
11111011
01111011
11111101
10111111
11111011
11111101
01111111
01111011
NAME line (11,8)

TIL 1z7
11011011
11011111
11111111
11110101
11010111
11011011
11101111
10111111
NAME line (12,8)

TIL 1z8
10110111
11110111
10101011
11011111
10101011
11101111
11111011
11111111
NAME line (13,8)

TIL 1z9
11111101
10111110
11011110
11011101
11011110
10111101
11011111
01111110
NAME line (14,8)

TIL 1za
11111111
10111111
10111111
11011111
10111111
01011111
10111111
11011111
NAME line (15,8)

TIL 1zb
11101010
11110111
11011010
11101101
11110110
11011010
11101101
11110111
NAME line (0,9)

TIL 1zc
11010101
01101111
10110101
11011011
10101101
11010111
01110101
10101111
NAME line (1,9)

TIL 1zd
10111111
11011111
11111111
10111111
11011111
11101111
11011111
11011110
NAME line (2,9)

TIL 1ze
11111011
11111110
11111101
11011110
10111101
01111111
01011111
11101111
NAME line (3,9)

TIL 1zf
11111111
10111101
11111111
11110111
11111011
10101111
11111111
11011111
NAME line (4,9)

TIL 1zg
11111111
11111111
11111111
11110111
11111111
11111111
11111111
11111111
NAME line (5,9)

TIL 1zh
10101101
11110111
01011011
11101101
01111111
10111101
01101110
10111111
NAME line (6,9)

TIL 1zi
11011111
10110111
01101111
11110101
10110111
01111110
11111111
01011111
NAME line (7,9)

TIL 1zj
10111110
11110111
11011101
11101010
01010111
11111111
01111111
11011011
NAME line (8,9)

TIL 1zk
10111011
01010111
11011111
01010111
10101110
11101111
11011111
01101111
NAME line (9,9)

TIL 1zl
10101101
10101010
01110111
10101010
11011010
01111011
10111101
01110110
NAME line (10,9)

TIL 1zm
11101111
10111011
11101111
10110111
11101011
01110111
11101011
10110111
NAME line (11,9)

TIL 1zn
11010101
11111111
10111111
11101111
10110101
11010111
10110101
11011011
NAME line (12,9)

TIL 1zo
10101011
11011111
10101011
11101111
10111111
11111111
11111011
11101111
NAME line (13,9)

TIL 1zp
11111110
11111110
11111111
11011101
11111110
10111111
11011101
11111101
NAME line (14,9)

TIL 1zq
10111111
11011111
01111111
01011111
10111111
01111111
10111111
01011111
NAME line (15,9)

TIL 1zr
11011001
11101110
11110101
11011011
11101101
11110101
11011011
11101101
NAME line (0,10)

TIL 1zs
01010101
11110111
01011010
10101101
01110111
10101011
01101111
10110110
NAME line (1,10)

TIL 1zt
11111111
11111111
11111111
11101111
11011111
10111111
01101111
11011111
NAME line (2,10)

TIL 1zu
10111110
10111101
01111110
11111111
11111100
11111111
11111011
11111111
NAME line (3,10)

TIL 1zv
11111111
10111101
11111011
11101111
11110101
11010111
11110101
11011011
NAME line (4,10)

TIL 1zw
11111111
11111111
11101111
11111111
11111111
11101111
11111111
11111111
NAME line (5,10)

TIL 1zx
01110101
10111011
11011101
11110110
11011011
11111101
11111011
01111110
NAME line (6,10)

TIL 1zy
10111111
01101011
11011111
11101011
01011011
10110111
11111101
10101110
NAME line (7,10)

TIL 1zz
10111110
11011111
11111010
11010110
11111011
11110101
11111111
11110111
NAME line (8,10)

TIL 20a
10111111
11011110
01111110
11111101
11111011
11111101
11101110
11111011
NAME line (3,11)

TIL 20b
11110111
11101011
11011101
11101011
01101111
11010101
11101111
11011011
NAME line (4,11)

TIL 20c
11111111
11111111
11111111
11111111
11111110
11111111
11101111
11111111
NAME line (5,11)

TIL 20d
01111111
10111111
01111110
10111011
11110111
01011111
10110101
01111010
NAME line (6,11)

TIL 20e
01111011
10101110
11010101
10111111
11011111
11101111
01111011
11110111
NAME line (7,11)

TIL 20f
11111111
11111111
11110111
01111101
11111111
11111101
11111111
11111111
NAME line (8,11)

TIL 20g
11011111
11101111
11111111
11111110
11110111
11101110
11111111
11111111
NAME line (9,11)

TIL 20h
10101110
11011111
01111111
10111101
11111011
11110110
01110110
11101011
NAME line (10,11)

TIL 20i
11100111
11111101
11010110
10101011
01110111
10111111
10111110
01111111
NAME line (11,11)

TIL 20j
11111111
11111110
11110101
11111011
11010110
10111011
11010101
01101111
NAME line (12,11)

TIL 20k
11111111
11101011
10111111
11100111
10111011
11010111
01101111
10110111
NAME line (13,11)

TIL 20l
11111110
11011110
11111110
10111111
11011101
11111110
10111110
11011110
NAME line (14,11)

TIL 20m
10111111
11011111
11111111
01011111
10111111
11011111
10111111
11011111
NAME line (15,11)

TIL 20n
11101101
11110110
11101011
11111111
11010101
11111110
11101011
11101101
NAME line (0,12)

TIL 20o
10110101
11011011
01101110
01010111
10111010
11010101
01101111
10110101
NAME line (1,12)

TIL 20p
11101111
10111111
11011111
11011111
11101111
10111011
11010110
11101111
NAME line (2,12)

TIL 20q
10101101
11010110
01111011
10101101
01101011
10111101
11011110
01101011
NAME line (3,12)

TIL 20r
11101101
11110111
11011011
01101101
11010111
11101011
11011101
11101011
NAME line (4,12)

TIL 20s
11111111
11011111
11111111
11101111
11111111
11111111
11101111
11111111
NAME line (5,12)

TIL 20t
10110111
01111010
10101101
11110110
01011011
11110101
01011110
11110101
NAME line (6,12)

TIL 20u
01111101
11111111
10111111
11011111
01101111
10111111
11010111
10111011
NAME line (7,12)

TIL 20v
11011111
11101111
11110111
11101111
11111011
11110111
11111101
11110111
NAME line (8,12)

TIL 20w
11110111
11101111
11111111
11010111
11111111
11010111
11111110
11101111
NAME line (9,12)

TIL 20x
11111101
11010011
10101111
11111111
01111110
11110101
11111010
10110111
NAME line (10,12)

TIL 20y
11110101
11101011
11011101
01101010
10110111
10101010
11111101
11111111
NAME line (11,12)

TIL 20z
01011001
01101111
10110101
11010101
01011011
11101101
01010101
10110111
NAME line (12,12)

TIL 21a
01101010
10110111
01011011
11101101
10110110
11011011
01101101
10110110
NAME line (7,13)

TIL 21b
11111011
01111110
11111101
01011111
11111111
01011111
10111111
11011111
NAME line (8,13)

TIL 21c
11111101
11010111
11011111
11111111
10101111
11111110
11111011
11101101
NAME line (9,13)

TIL 21d
01011111
11111110
11111111
11111111
10101010
11011011
01101101
10110110
NAME line (10,13)

TIL 21e
10101001
01010110
11111111
11111111
11101101
00110110
11011011
10101101
NAME line (11,13)

TIL 21f
01011010
11010101
10110111
11011011
10101011
11101101
01010111
01111011
NAME line (12,13)

TIL 21g
11010111
11101111
10101011
10110111
11011011
11010111
01101111
01010111
NAME line (13,13)

TIL 21h
11011110
11111110
10111110
11011110
11011110
11111111
10111101
11011110
NAME line (14,13)

TIL 21i
10111111
11011111
10111111
11011111
10111111
01011111
10111111
10111111
NAME line (15,13)

TIL 21j
10101101
11110110
11011011
11101101
11011011
11101110
11011011
11110101
NAME line (0,14)

TIL 21k
10101101
11011011
01101111
10110101
01101111
11110101
10111111
01101011
NAME line (1,14)

TIL 21l
11011011
11101111
11011010
11101111
11010111
11111110
10101011
11101111
NAME line (2,14)

TIL 21m
01111010
10111101
11110111
01011111
10111111
11111111
10111101
01111011
NAME line (3,14)

TIL 21n
11110111
01011011
11010111
01111010
01010111
11101101
01011010
01101111
NAME line (4,14)

TIL 21o
11111111
11101111
10110111
11011101
01101011
10110110
11011011
10110110
NAME line (5,14)

TIL 21p
11111011
01111101
11111011
01110110
11111111
11101010
01111111
11110101
NAME line (6,14)

TIL 21q
11011011
01101101
10110110
11011011
01101101
11011110
01101011
10110101
NAME line (7,14)

TIL 21r
01101111
10110111
11011101
01101111
11010101
10111010
01101111
11011010
NAME line (8,14)

TIL 21s
11110110
11111011
11101101
01110111
10101010
11011111
01101010
10110110
NAME line (9,14)

TIL 21t
11010101
01101110
10110101
01101101
11011011
01101101
10110110
11011011
NAME line (10,14)

TIL 21u
11110101
10101101
01110110
10101011
01011010
10101101
11110110
01010101
NAME line (11,14)

TIL 21v
10101011
01010101
11101110
01010101
10110110
11011011
10101101
01111111
NAME line (12,14)

TIL 21w
10110111
10101011
11011111
01100101
10110101
01011011
01111111
10110101
NAME line (13,14)

TIL 21x
11101111
10111101
11010110
10111010
01101011
01111111
10101011
11110110
NAME line (14,14)

TIL 21y
01111111
10111111
10111111
11011111
01111111
11011111
11111111
10111111
NAME line (15,14)

TIL 21z
11011110
11101011
11111101
11010111
11111010
10101111
11110101
11011110
NAME line (0,15)

TIL 22a
10101111
11111110
11110101
01011011
11101101
01010101
11110111
11111111
NAME line (11,15)

TIL 22b
11010101
11111110
01001010
01110101
10101110
10110101
11011111
11111111
NAME line (12,15)

TIL 22c
11011011
10101010
10110110
10101011
11011101
01110101
11011010
11111111
NAME line (13,15)

TIL 22d
01101011
10110101
11011010
01010111
01101101
10110101
11011010
11110111
NAME line (14,15)

TIL 22e
01011111
10111111
11011111
01111111
01011111
10111111
11011111
01111111
NAME line (15,15)

SPR A
00011000
00011000
00011000
00111100
01111110
10111101
00100100
00000000
POS 1 9,14

SPR a
00000000
00000000
01010001
01110001
01110010
01111100
00111100
00100100
NAME cat
DLG 0
POS 0 8,12

ITM 0
00000000
00000000
00000000
00111100
01100100
00100100
00011000
00000000
NAME tea
DLG 1

ITM 1
00000000
00111100
00100100
00111100
00010000
00011000
00010000
00011000
NAME key
DLG 2

DLG 0
I'm a cat
NAME cat dialog

DLG 1
You found a nice warm cup of tea
NAME tea dialog

DLG 2
A key! {wvy}What does it open?{wvy}
NAME key dialog

VAR a
42

TUNE 1
0,0,5l,0,0,0,0,0,m,0,0,0,0,0,0,0
16m2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
16s2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,l,0,l,0,m,0,r,0,0,0,0,0
16l2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,3l,0,0,r,3l,0,0,s,m,0,0,0,0,0
16r2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
KEY C,D,E,F,G,A,B d,r,m,s,l
TMP MED
SQR P8 P2
ARP INT8

TUNE 2
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
16s2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
16m2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
16l2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
16d2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,l,0,0,0,0,0,0,0,0,0,0,0,0,0
16s2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,8s,0,0,0,0,0,0,0,0,0,0,0
16m2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,2m,0,s,0,0,0,0,0,0,0,0,0
16s2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,3s,0,0,m,0,0,0,0,0
16r2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
KEY C,D,E,F,G,A,B d,r,m,s,l
TMP SLW
SQR P4 P2
ARP INT8

TUNE 3
0,0,0,l,r,2l,0,0,0,0,0,r,s,0,0,0
16r2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,d5,m,l,0,0,0,m,s,0,0,0,0,0,0,0
16s2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,s,0,0,5l,0,0,0,0,s,0,0
16l2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,6l,0,0,0,0,0,0,m,0,0,0,0,0
16l2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
KEY C,D,E,F,G,A,B d,r,m,s,l
TMP FST
SQR P8 P4
ARP UP

TUNE 4
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
>
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
KEY C,D,E,F,G,A,B d,r,m,s,l
TMP FST
SQR P2 P8
ARP DWN


</script>

<style>
html {
	margin:0px;
	padding:0px;
}

body {
	margin:0px;
	padding:0px;
	overflow:hidden;
	background:#ffffff;
}

#game {
	background:black;
	width:100vw;
	max-width:100vh;
	margin:auto;
	display:block;
}
</style>

<!-- SCRIPTS -->
<script>
function startExportedGame() {
	var gameCanvas = document.getElementById("game");
	var gameData = document.getElementById("exportedGameData").text.slice(1);
	var defaultFontData = document.getElementById(defaultFontName).text.slice(1);
	loadGame(gameCanvas, gameData, defaultFontData);
	initSystem();
}
</script>

<!-- system -->
<script>
function InputSystem() {
	var self = this;

	this.Key = {
		LEFT: 37,
		RIGHT: 39,
		UP: 38,
		DOWN: 40,
		SPACE: 32,
		ENTER: 13,
		W: 87,
		A: 65,
		S: 83,
		D: 68,
		R: 82,
		SHIFT: 16,
		CTRL: 17,
		ALT: 18,
		CMD: 224
	};

	var pressed;
	var ignored;
	var touchState;

	var isRestartComboPressed = false;

	var SwipeDir = {
		None : -1,
		Up : 0,
		Down : 1,
		Left : 2,
		Right : 3,
	};

	function resetAll() {
		isRestartComboPressed = false;

		pressed = {};
		ignored = {};

		touchState = {
			isDown : false,
			startX : 0,
			startY : 0,
			curX : 0,
			curY : 0,
			swipeDistance : 30,
			swipeDirection : SwipeDir.None,
			tapReleased : false
		};
	}

	resetAll();

	function stopWindowScrolling(e) {
		if (e.keyCode == self.Key.LEFT || e.keyCode == self.Key.RIGHT || e.keyCode == self.Key.UP || e.keyCode == self.Key.DOWN || !isPlayerEmbeddedInEditor) {
			e.preventDefault();
		}
	}

	function isRestartCombo(e) {
		return (e.keyCode === self.Key.R && (e.getModifierState("Control")|| e.getModifierState("Meta")));
	}

	function eventIsModifier(event) {
		return (event.keyCode == self.Key.SHIFT || event.keyCode == self.Key.CTRL || event.keyCode == self.Key.ALT || event.keyCode == self.Key.CMD);
	}

	function isModifierKeyDown() {
		return (self.isKeyDown(self.Key.SHIFT) || self.isKeyDown(self.Key.CTRL) || self.isKeyDown(self.Key.ALT) || self.isKeyDown(self.Key.CMD));
	}

	this.ignoreHeldKeys = function() {
		for (var key in pressed) {
			if (pressed[key]) { // only ignore keys that are actually held
				ignored[key] = true;
				// bitsyLog("IGNORE -- " + key, "system");
			}
		}
	}

	this.onkeydown = function(event) {
		enableGlobalAudioContext();
		// bitsyLog("KEYDOWN -- " + event.keyCode, "system");

		stopWindowScrolling(event);

		isRestartComboPressed = isRestartCombo(event);

		// Special keys being held down can interfere with keyup events and lock movement
		// so just don't collect input when they're held
		{
			if (isModifierKeyDown()) {
				return;
			}

			if (eventIsModifier(event)) {
				resetAll();
			}
		}

		if (ignored[event.keyCode]) {
			return;
		}

		pressed[event.keyCode] = true;
		ignored[event.keyCode] = false;
	}

	this.onkeyup = function(event) {
		// bitsyLog("KEYUP -- " + event.keyCode, "system");
		pressed[event.keyCode] = false;
		ignored[event.keyCode] = false;
	}

	this.ontouchstart = function(event) {
		enableGlobalAudioContext();

		event.preventDefault();

		if( event.changedTouches.length > 0 ) {
			touchState.isDown = true;

			touchState.startX = touchState.curX = event.changedTouches[0].clientX;
			touchState.startY = touchState.curY = event.changedTouches[0].clientY;

			touchState.swipeDirection = SwipeDir.None;
		}
	}

	this.ontouchmove = function(event) {
		event.preventDefault();

		if( touchState.isDown && event.changedTouches.length > 0 ) {
			touchState.curX = event.changedTouches[0].clientX;
			touchState.curY = event.changedTouches[0].clientY;

			var prevDirection = touchState.swipeDirection;

			if( touchState.curX - touchState.startX <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Left;
			}
			else if( touchState.curX - touchState.startX >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Right;
			}
			else if( touchState.curY - touchState.startY <= -touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Up;
			}
			else if( touchState.curY - touchState.startY >= touchState.swipeDistance ) {
				touchState.swipeDirection = SwipeDir.Down;
			}

			if( touchState.swipeDirection != prevDirection ) {
				// reset center so changing directions is easier
				touchState.startX = touchState.curX;
				touchState.startY = touchState.curY;
			}
		}
	}

	this.ontouchend = function(event) {
		event.preventDefault();

		touchState.isDown = false;

		if( touchState.swipeDirection == SwipeDir.None ) {
			// tap!
			touchState.tapReleased = true;
		}

		touchState.swipeDirection = SwipeDir.None;
	}

	this.isKeyDown = function(keyCode) {
		return pressed[keyCode] != null && pressed[keyCode] == true && (ignored[keyCode] == null || ignored[keyCode] == false);
	}

	this.anyKeyDown = function() {
		var anyKey = false;

		for (var key in pressed) {
			if (pressed[key] && (ignored[key] == null || ignored[key] == false) &&
				!(key === self.Key.UP || key === self.Key.DOWN || key === self.Key.LEFT || key === self.Key.RIGHT) &&
				!(key === self.Key.W || key === self.Key.S || key === self.Key.A || key === self.Key.D)) {
				// detected that a key other than the d-pad keys are down!
				anyKey = true;
			}
		}

		return anyKey;
	}

	this.isRestartComboPressed = function() {
		return isRestartComboPressed;
	}

	this.swipeLeft = function() {
		return touchState.swipeDirection == SwipeDir.Left;
	}

	this.swipeRight = function() {
		return touchState.swipeDirection == SwipeDir.Right;
	}

	this.swipeUp = function() {
		return touchState.swipeDirection == SwipeDir.Up;
	}

	this.swipeDown = function() {
		return touchState.swipeDirection == SwipeDir.Down;
	}

	this.isTapReleased = function() {
		return touchState.tapReleased;
	}

	this.resetTapReleased = function() {
		touchState.tapReleased = false;
	}

	this.onblur = function() {
		// bitsyLog("~~~ BLUR ~~", "system");
		resetAll();
	}

	this.resetAll = resetAll;

	this.listen = function(canvas) {
		document.addEventListener('keydown', self.onkeydown);
		document.addEventListener('keyup', self.onkeyup);

		if (isPlayerEmbeddedInEditor) {
			canvas.addEventListener('touchstart', self.ontouchstart, {passive:false});
			canvas.addEventListener('touchmove', self.ontouchmove, {passive:false});
			canvas.addEventListener('touchend', self.ontouchend, {passive:false});
		}
		else {
			// creates a 'touchTrigger' element that covers the entire screen and can universally have touch event listeners added w/o issue.

			// we're checking for existing touchTriggers both at game start and end, so it's slightly redundant.
			var existingTouchTrigger = document.querySelector('#touchTrigger');

			if (existingTouchTrigger === null) {
				var touchTrigger = document.createElement("div");
				touchTrigger.setAttribute("id","touchTrigger");

				// afaik css in js is necessary here to force a fullscreen element
				touchTrigger.setAttribute(
					"style","position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; overflow: hidden;"
				);

				document.body.appendChild(touchTrigger);

				touchTrigger.addEventListener('touchstart', self.ontouchstart);
				touchTrigger.addEventListener('touchmove', self.ontouchmove);
				touchTrigger.addEventListener('touchend', self.ontouchend);
			}
		}

		window.onblur = self.onblur;
	}

	this.unlisten = function(canvas) {
		document.removeEventListener('keydown', self.onkeydown);
		document.removeEventListener('keyup', self.onkeyup);

		if (isPlayerEmbeddedInEditor) {
			canvas.removeEventListener('touchstart', self.ontouchstart);
			canvas.removeEventListener('touchmove', self.ontouchmove);
			canvas.removeEventListener('touchend', self.ontouchend);
		}
		else {
			//check for touchTrigger and removes it

			var existingTouchTrigger = document.querySelector('#touchTrigger');

			if (existingTouchTrigger !== null) {
				existingTouchTrigger.removeEventListener('touchstart', self.ontouchstart);
				existingTouchTrigger.removeEventListener('touchmove', self.ontouchmove);
				existingTouchTrigger.removeEventListener('touchend', self.ontouchend);

				existingTouchTrigger.parentElement.removeChild(existingTouchTrigger);
			}
		}

		window.onblur = null;
	}
}
</script>

<script>
// init global audio context
var audioContext = new AudioContext();

function enableGlobalAudioContext() {
	audioContext.resume();
}

function SoundSystem() {
	var self = this;

	// volume
	var maxGain = 0.15;

	// curves for different pulse wave duties (ratios between on and off)
	var dutyCycle_1_8 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_8[i] = ((i / 256) * 2) - 1.75;
	}

	var dutyCycle_1_4 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_4[i] = ((i / 256) * 2) - 1.5;
	}

	var dutyCycle_1_2 = new Float32Array(256);
	for (var i = 0; i < 256; i++) {
		dutyCycle_1_2[i] = ((i / 256) * 2) - 1.0;
	}

	var dutyCycles = [
		dutyCycle_1_8,
		dutyCycle_1_4,
		dutyCycle_1_2 // square wave
	];

	function createPulseWidthModulator() {
		// the base oscillator: start with a sawtooth wave that we'll shape into a pulse wave
		var oscillator = audioContext.createOscillator();
		oscillator.type = "sawtooth";

		// create a gain node to control the volume of the sound
		var volumeControl = audioContext.createGain();
		volumeControl.gain.value = 0;

		// create a wave shaper that turns the sawtooth wave into a pulse
		// by mapping any negative value to -1 and any positive value to 1
		var pulseCurve = new Float32Array(256);
		for (var i = 0; i < 128; i++) {
			pulseCurve[i] = -1;
		}
		for (var i = 128; i < 256; i++) {
			pulseCurve[i] = 1;
		}

		var pulseShaper = audioContext.createWaveShaper();
		pulseShaper.curve = pulseCurve;

		var dutyShaper = audioContext.createWaveShaper();
		dutyShaper.curve = dutyCycle_1_2;

		oscillator.connect(dutyShaper);
		dutyShaper.connect(pulseShaper);
		pulseShaper.connect(volumeControl);
		volumeControl.connect(audioContext.destination);
		oscillator.start();

		return {
			oscillator: oscillator,
			volumeControl: volumeControl,
			dutyShaper: dutyShaper
		};
	}

	var pulseChannels = [createPulseWidthModulator(), createPulseWidthModulator()];

	this.setPulse = function(channel, pulse) {
		var pulseChannel = pulseChannels[channel];
		pulseChannel.dutyShaper.curve = dutyCycles[pulse];
	}

	this.setFrequency = function(channel, frequencyHz) {
		var pulseChannel = pulseChannels[channel];
		// set frequency in hertz
		pulseChannel.oscillator.frequency.setValueAtTime(frequencyHz, audioContext.currentTime);
	}

	this.setVolume = function(channel, volumeNorm) {
		var pulseChannel = pulseChannels[channel];
		pulseChannel.volumeControl.gain.value = volumeNorm * maxGain;
	}

	this.mute = function() {
		for (var i = 0; i < pulseChannels.length; i++) {
			pulseChannels[i].volumeControl.gain.value = 0;
		}
	}
}

var sound = new SoundSystem();
</script>

<script>
function GraphicsSystem() {
	var self = this;

	var canvas;
	var ctx;

	var scale;
	var textScale;
	var palette = [];
	var images = [];
	var imageFillColors = [];

	function makeFillStyle(color, isTransparent) {
		var i = color * 3;
		if (isTransparent) {
			return "rgba(" + palette[i + 0] + "," + palette[i + 1] + "," + palette[i + 2] + ", 0)";
		}
		else {
			return "rgb(" + palette[i + 0] + "," + palette[i + 1] + "," + palette[i + 2] + ")";
		}
	}

	this._images = images;
	this._getPalette = function() {
		return palette;
	};

	// todo : do I really need to pass in size here?
	this.attachCanvas = function(c, size) {
		canvas = c;
		canvas.width = size * scale;
		canvas.height = size * scale;
		ctx = canvas.getContext("2d");
	};

	this.getCanvas = function() {
		return canvas;
	};

	this.getContext = function() {
		return ctx;
	};

	this.setScale = function(s) {
		scale = s;
	};

	this.setTextScale = function(s) {
		textScale = s;
	};

	this.getTextScale = function() {
		return textScale;
	};

	this.setPalette = function(p) {
		palette = p;
	};

	// todo : rename this since it doesn't always create a totally new canvas?
	this.createImage = function(id, width, height, pixels, useTextScale) {
		var imageScale = useTextScale === true ? textScale : scale;
		var widthScaled = width * imageScale;
		var heightScaled = height * imageScale;

		// try to use an existing image canvas if it is the right size,
		// instead of expensively creating a new one
		var imageCanvas = images[id];
		if (imageCanvas === undefined || imageCanvas.width != widthScaled || imageCanvas.height != heightScaled) {
			imageCanvas = document.createElement("canvas");
			imageCanvas.width = widthScaled;
			imageCanvas.height = heightScaled;
		}

		var imageCtx = imageCanvas.getContext("2d");

		// if we know the fill color for this image, we can speed things up
		// by filling the whole image with that color
		var fillColor;
		if (imageFillColors[id] != undefined) {
			fillColor = imageFillColors[id];
			var isTransparent = (fillColor === 0);
			if (isTransparent) {
				imageCtx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
			}
			else {
				imageCtx.fillStyle = makeFillStyle(fillColor, isTransparent);
				imageCtx.fillRect(0, 0, imageCanvas.width, imageCanvas.height);
			}
		}

		for (var i = 0; i < pixels.length; i++) {
			var x = i % width;
			var y = Math.floor(i / width);
			var color = pixels[i];
			if (color != fillColor) {
				var isTransparent = (color === 0);
				imageCtx.fillStyle = makeFillStyle(color, isTransparent);
				imageCtx.fillRect(x * imageScale, y * imageScale, imageScale, imageScale);
			}
		}

		images[id] = imageCanvas;
	};

	this.setImageFill = function(id, color) {
		imageFillColors[id] = color;
	};

	this.drawImage = function(id, x, y, destId) {
		if (!images[id]) {
			bitsyLog("image doesn't exist: " + id, "graphics");
			return;
		}

		var destCtx = ctx;
		if (destId != undefined) {
			// if there's a destination ID, that means we're drawing this image *onto* another image canvas
			var destCanvas = images[destId];
			destCtx = destCanvas.getContext("2d");
		}

		destCtx.drawImage(images[id], x * scale, y * scale, images[id].width, images[id].height);
	};

	this.hasImage = function(id) {
		return images[id] != undefined;
	};

	this.getImage = function(id) {
		return images[id];
	};

	this.deleteImage = function(id) {
		delete images[id];
		delete imageFillColors[id];
	};

	this.getCanvas = function() {
		return canvas;
	};

	this.clearCanvas = function(color) {
		bitsyLog("pal? " + palette.length + " / " + color, "graphics");
		ctx.fillStyle = makeFillStyle(color);
		ctx.fillRect(0, 0, canvas.width, canvas.height);
	};
}
</script>

<script>
/* LOGGING */
var DebugLogCategory = {
	// system
	input: false,
	sound: false,
	graphics: false,
	system: false,

	// engine
	bitsy: false,

	// editor
	editor: false,

	// tools
	room: false,
	tune: false,
	blip: false,
};

var isLoggingVerbose = false;

function bitsyLog(message, category) {
	if (!category) {
		category = "bitsy";
	}

	var summary = category + "::" + message;

	if (DebugLogCategory[category] === true) {
		if (isLoggingVerbose) {
			console.group(summary);

			console.dir(message);

			console.group("stack")
			console.trace();
			console.groupEnd();

			console.groupEnd();
		}
		else {
			console.log(summary);
		}
	}
}

/* GLOBALS */
var tilesize = 8;
var mapsize = 16;
var width = mapsize * tilesize;
var height = mapsize * tilesize;
var scale = 4;
var textScale = 2;

/* SYSTEM */
var updateInterval = null;
var prevTime = 0;
var deltaTime = 0;

function initSystem() {
	prevTime = Date.now();
	updateInterval = setInterval(updateSystem, 16);
}

function updateSystem() {
	var curTime = Date.now();
	deltaTime = curTime - prevTime;

	// update all active processes
	for (var i = 0; i < processes.length; i++) {
		bitsy = processes[i].system;
		if (bitsy._active) {
			bitsyLog(bitsy._name + " img count: " + bitsy._graphics._images.length, "system");
			var shouldContinue = bitsy._update(deltaTime);
			if (!shouldContinue) {
				// todo : do I really care about this _exit thing?
				if (bitsy._name != "bitsy") {
					bitsy._exit();
				}
			}
		}
	}

	bitsy = mainProcess.system;
	prevTime = curTime;
}

function loadGame(canvas, gameData, defaultFontData) {
	bitsyLog("load!", "system");
	// initialize bitsy system
	bitsy._attachCanvas(canvas);
	bitsy._write(bitsy._gameDataBlock, gameData);
	bitsy._write(bitsy._fontDataBlock, defaultFontData);
	bitsy._start();
}

function quitGame() {
	// hack to press the menu button to force game over state
	bitsy._injectPreLoop = function() { bitsy._poke(bitsy._buttonBlock, bitsy.BTN_MENU, 1); };

	// one last update to clean up (a little hacky to do this here?)
	bitsy._update(0);
	bitsy._exit();

	// clean up this gross hack
	bitsy._injectPreLoop = null;
}

/* GRAPHICS */
var canvas; // can I get rid of these?
var ctx;

function attachCanvas(c) {
	// hack : tes tnew system
	bitsy._attachCanvas(c);
	// extra hacky
	canvas = bitsy._getCanvas();
	ctx = bitsy._getContext();
}

/* PROCESSES */
var processes = [];

function addProcess(name) {
	var proc = {};
	proc.system = new BitsySystem(name);

	processes.push(proc);

	return proc;
}

/* == SYSTEM v0.2 === */
function BitsySystem(name) {
	var self = this;

	if (!name) {
		name = "bitsy";
	}

	// memory
	var memory = {
		blocks: [],
		changed: []
	};

	// input
	var input = new InputSystem();

	// sound
	var sound = new SoundSystem();
	var soundDurationIndex = 0;
	var soundFrequencyIndex = 1;
	var soundVolumeIndex = 2;
	var soundPulseIndex = 3;
	var maxVolume = 15;

	// graphics
	var graphics = new GraphicsSystem();
	graphics.setScale(scale);
	graphics.setTextScale(textScale);
	var initialPaletteSize = 64;
	var tilePoolStart = null;
	var tilePoolSize = 512;
	// hack!!! (access for debugging)
	this._graphics = graphics;

	function updateTextScale() {
		// make sure the text scale matches the text mode
		var textMode = self._peek(modeBlock, 1);
		var textModeScale = (textMode === self.TXT_LOREZ) ? scale : textScale;
		if (graphics.getTextScale() != textModeScale) {
			graphics.setTextScale(textModeScale);
			memory.changed[self.TEXTBOX] = true;
		}
	}

	function updateInput() {
		// update input flags
		self._poke(self._buttonBlock, self.BTN_UP,
			(input.isKeyDown(input.Key.UP) || input.isKeyDown(input.Key.W) || input.swipeUp()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_DOWN,
			(input.isKeyDown(input.Key.DOWN) || input.isKeyDown(input.Key.S) || input.swipeDown()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_LEFT,
			(input.isKeyDown(input.Key.LEFT) || input.isKeyDown(input.Key.A) || input.swipeLeft()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_RIGHT,
			(input.isKeyDown(input.Key.RIGHT) || input.isKeyDown(input.Key.D) || input.swipeRight()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_OK,
			(input.anyKeyDown() || input.isTapReleased()) ? 1 : 0);

		self._poke(self._buttonBlock, self.BTN_MENU,
			(input.isRestartComboPressed()) ? 1 : 0);

		input.resetTapReleased();
	}

	function updateSound(dt) {
		var changed0 = memory.changed[self.SOUND1];
		var changed1 = memory.changed[self.SOUND2];

		// update sound channel timers
		var timer0 = self._peek(self.SOUND1, soundDurationIndex);
		timer0 -= dt;
		if (timer0 <= 0) {
			timer0 = 0;
			if (self._peek(self.SOUND1, soundVolumeIndex) > 0) {
				self._poke(self.SOUND1, soundVolumeIndex, 0);
				changed0 = true;
			}
		}
		self._poke(self.SOUND1, soundDurationIndex, timer0);

		var timer1 = self._peek(self.SOUND2, soundDurationIndex);
		timer1 -= dt;
		if (timer1 <= 0) {
			timer1 = 0;
			if (self._peek(self.SOUND2, soundVolumeIndex) > 0) {
				self._poke(self.SOUND2, soundVolumeIndex, 0);
				changed1 = true;
			}
		}
		self._poke(self.SOUND2, soundDurationIndex, timer1);

		// send updated channel attributes to the sound system
		if (changed0) {
			sound.setPulse(0, self._peek(self.SOUND1, soundPulseIndex));

			var freq = self._peek(self.SOUND1, soundFrequencyIndex);
			var freqHz = freq / 100;
			sound.setFrequency(0, freqHz);

			var volume = self._peek(self.SOUND1, soundVolumeIndex);
			volume = Math.max(0, Math.min(volume, maxVolume));
			volumeNorm = (volume / maxVolume);
			sound.setVolume(0, volumeNorm);
		}

		if (changed1) {
			sound.setPulse(1, self._peek(self.SOUND2, soundPulseIndex));

			var freq = self._peek(self.SOUND2, soundFrequencyIndex);
			var freqHz = freq / 100;
			sound.setFrequency(1, freqHz);

			var volume = self._peek(self.SOUND2, soundVolumeIndex);
			volume = Math.max(0, Math.min(volume, maxVolume));
			volumeNorm = (volume / maxVolume);
			sound.setVolume(1, volumeNorm);
		}
	}

	function updateGraphics() {
		if (self._enableGraphics === false) {
			return;
		}

		bitsyLog("update graphics", "system");

		if (memory.changed[paletteBlock]) {
			graphics.setPalette(self._dump()[paletteBlock]);
		}

		if (tilePoolStart != null) {
			for (var i = 0; i < tilePoolSize; i++) {
				var tile = tilePoolStart + i;
				if (memory.blocks[tile] != undefined && memory.changed[tile]) {
					bitsyLog("tile changed? " + tile, "system");
					// update tile image
					graphics.createImage(tile, self.TILE_SIZE, self.TILE_SIZE, self._dump()[tile]);
				}
			}
		}

		var textboxChanged = memory.changed[self.TEXTBOX] || memory.changed[textboxAttributeBlock];
		if (textboxChanged) {
			// todo : should this be optimized in some way?
			// update textbox image
			var w = self._peek(textboxAttributeBlock, 3); // todo : need a variable to store this index?
			var h = self._peek(textboxAttributeBlock, 4);
			if (w > 0 && h > 0) {
				bitsyLog("textbox changed! " + memory.changed[self.TEXTBOX] + " " + memory.changed[textboxAttributeBlock] + " " + w + " " + h, "system");
				var useTextBoxScale = true; // todo : check mode here?
				graphics.createImage(self.TEXTBOX, w, h, self._dump()[self.TEXTBOX], useTextBoxScale);
			}
		}

		var mode = self._peek(modeBlock, 0);
		if (mode === self.GFX_VIDEO) {
			if (memory.changed[self.VIDEO]) {
				graphics.clearCanvas(0);
				// update screen image
				graphics.createImage(self.VIDEO, self.VIDEO_SIZE, self.VIDEO_SIZE, self._dump()[self.VIDEO]);
				// render screen onto canvas
				graphics.drawImage(self.VIDEO, 0, 0);
			}
		}
		else if (mode === self.GFX_MAP) {
			// redraw any changed layers
			var layers = self._getTileMapLayers();
			var anyMapLayerChanged = false;
			for (var i = 0; i < layers.length; i++) {
				var layerId = layers[i];
				if (memory.changed[layerId]) {
					// need to redraw this map layer
					anyMapLayerChanged = true;
					// clear layer canvas
					graphics.setImageFill(layerId, 0); // fill transparent
					graphics.createImage(layerId, self.VIDEO_SIZE, self.VIDEO_SIZE, []);
					// render tiles onto layer canvas
					var layerData = self._dump()[layerId];
					for (var ty = 0; ty < self.MAP_SIZE; ty++) {
						for (var tx = 0; tx < self.MAP_SIZE; tx++) {
							var tileIndex = (ty * self.MAP_SIZE) + tx;
							var tile = layerData[tileIndex];
							if (tile > 0) {
								graphics.drawImage(tile, tx * self.TILE_SIZE, ty * self.TILE_SIZE, layerId);
							}
						}
					}
				}
			}

			// redraw the main canvas
			if (textboxChanged || anyMapLayerChanged) {
				bitsyLog("map changed? " + memory.changed[self.MAP1] + " " + memory.changed[self.MAP2], "system");
				graphics.clearCanvas(0);

				for (var i = 0; i < layers.length; i++) {
					var layerId = layers[i];
					// draw the layer's image canvas onto the main canvas
					graphics.drawImage(layerId, 0, 0);
				}

				// draw textbox onto canvas
				var visible = self._peek(textboxAttributeBlock, 0)
				var x = self._peek(textboxAttributeBlock, 1);
				var y = self._peek(textboxAttributeBlock, 2);
				var w = self._peek(textboxAttributeBlock, 3);
				var h = self._peek(textboxAttributeBlock, 4);
				if (visible > 0 && w > 0 && h > 0) {
					graphics.drawImage(self.TEXTBOX, x, y);
				}
			}
		}
	}

	/* == PRIVATE / DEBUG == */
	this._name = name;

	this._active = false;

	this._attachCanvas = function(c) {
		graphics.attachCanvas(c, self.VIDEO_SIZE);
	};

	this._getCanvas = graphics.getCanvas;
	this._getContext = graphics.getContext;

	this._start = function() {
		input.listen(graphics.getCanvas());
		updateTextScale();
		self._active = true;
	};

	// hacky...
	this._startNoInput = function() {
		updateTextScale();
		self._active = true;
	};

	this._exit = function() {
		input.unlisten(graphics.getCanvas());
		sound.mute();
		self._active = false;
	};

	// hacky....
	this._injectPreLoop = null;
	this._injectPostDraw = null;

	this._update = function(dt) {
		var shouldContinue = false;

		updateInput();

		// too hacky???
		if (self._injectPreLoop) {
			self._injectPreLoop();
		}

		// run main loop
		if (onLoopFunction) {
			shouldContinue = onLoopFunction(dt);
		}

		if (memory.changed[modeBlock]) {
			updateTextScale();
		}

		// update output systems
		updateSound(dt);
		updateGraphics();

		if (self._injectPostDraw) {
			self._injectPostDraw();
		}

		// reset memory block changed flags
		for (var i = 0; i < memory.changed.length; i++) {
			memory.changed[i] = false;
		}

		// todo : should the _exit() call go in here?

		return shouldContinue;
	};

	this._updateGraphics = updateGraphics;

	this._allocate = function(args) {
		// find next available block in range
		var next = (args && args.start) ? args.start : 0;
		var count = (args && args.max) ? args.max : -1;
		while (memory.blocks[next] != undefined && count != 0) {
			next++;
			count--;
		}

		if (memory.blocks[next] != undefined) {
			// couldn't find any available block
			return null;
		}

		if (args && args.str) {
			memory.blocks[next] = args.str;
		}
		else {
			var size = args && args.size ? args.size : 0;
			memory.blocks[next] = [];
			for (var i = 0; i < size; i++) {
				memory.blocks[next].push(0);
			}
		}

		memory.changed[next] = false;

		return next;
	};

	this._free = function(block) {
		delete memory.blocks[block];
		delete memory.changed[block];
	};

	this._peek = function(block, index) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			return memoryBlock.charCodeAt(index);
		}
		else {
			return memoryBlock[index];
		}
	};

	this._poke = function(block, index, value) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			memory.blocks[block] = memoryBlock.substring(0, index) + String.fromCharCode(value) + memoryBlock.substring(index + 1);
		}
		else {
			var value = parseInt(value);
			if (!isNaN(value)) {
				memoryBlock[index] = value;
			}
		}
		memory.changed[block] = true;
	};

	this._read = function(block) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			return memoryBlock;
		}
		else {
			var str = "";
			for (var i = 0; i < memoryBlock.length; i++) {
				str += String.fromCharCode(memoryBlock[i]);
			}
			return str;
		}
	};

	this._write = function(block, str) {
		var memoryBlock = memory.blocks[block];
		if (typeof(memoryBlock) === "string") {
			memory.blocks[block] = str;
		}
		else {
			memory.blocks[block] = [];
			for (var i = 0; i < str.length; i++) {
				memory.blocks[block][i] = str.charCodeAt(i);
			}
		}
		memory.changed[block] = true;
	};

	this._dump = function() {
		return memory.blocks;
	};

	// convenience methods for hacking around with map layers
	var tileMapLayers = [];
	this._getTileMapLayers = function() {
		return tileMapLayers;
	};
	this._addTileMapLayer = function() {
		var layer = self._allocate({
			start: (tilePoolStart + tilePoolSize),
			size: (self.MAP_SIZE * self.MAP_SIZE)
		});

		tileMapLayers.push(layer);

		return layer;
	};

	/* == CONSTANTS == */
	// memory blocks (these will be initialized below)
	this.VIDEO;
	this.TEXTBOX;
	this.MAP1;
	this.MAP2;
	this.SOUND1;
	this.SOUND2;

	// graphics modes
	this.GFX_VIDEO = 0;
	this.GFX_MAP = 1;

	// text modes
	this.TXT_HIREZ = 0; // 2x resolution
	this.TXT_LOREZ = 1; // 1x resolution

	// size
	this.TILE_SIZE = tilesize;
	this.MAP_SIZE = mapsize;
	this.VIDEO_SIZE = width;
	// todo : should text scale have a constant?

	// button codes
	this.BTN_UP = 0;
	this.BTN_DOWN = 1;
	this.BTN_LEFT = 2;
	this.BTN_RIGHT = 3;
	this.BTN_OK = 4;
	this.BTN_MENU = 5;

	// pulse waves
	this.PULSE_1_8 = 0;
	this.PULSE_1_4 = 1;
	this.PULSE_1_2 = 2;

	/* == IO == */
	this.log = function(message) {
		bitsyLog(message, name);
	};

	this.button = function(code) {
		return self._peek(buttonBlock, code) > 0;
	};

	this.getGameData = function() {
		return self._read(gameDataBlock);
	};

	this.getFontData = function() {
		return self._read(fontDataBlock);
	};

	/* == GRAPHICS == */
	this.graphicsMode = function(mode) {
		// todo : store the mode flag indices somewhere?
		if (mode != undefined) {
			self._poke(modeBlock, 0, mode);
		}

		return self._peek(modeBlock, 0);
	};

	this.textMode = function(mode) {
		// todo : test whether the requested mode is supported!
		if (mode != undefined) {
			self._poke(modeBlock, 1, mode);
		}

		return self._peek(modeBlock, 1);
	};

	this.color = function(color, r, g, b) {
		self._poke(paletteBlock, (color * 3) + 0, r);
		self._poke(paletteBlock, (color * 3) + 1, g);
		self._poke(paletteBlock, (color * 3) + 2, b);

		// mark all graphics as changed
		memory.changed[self.VIDEO] = true;
		memory.changed[self.TEXTBOX] = true;
		memory.changed[self.MAP1] = true;
		memory.changed[self.MAP2] = true;

		if (tilePoolStart != null) {
			for (var i = 0; i < tilePoolSize; i++) {
				if (memory.blocks[tilePoolStart + i] != undefined) {
					memory.changed[tilePoolStart + i] = true;
				}
			}
		}
	};

	this.tile = function() {
		return self._allocate({
			start: tilePoolStart,
			max: tilePoolSize,
			size: (self.TILE_SIZE * self.TILE_SIZE)
		});
	};

	this.delete = function(tile) {
		if (graphics.hasImage(tile)) {
			graphics.deleteImage(tile);
		}

		self._free(tile);
	};

	this.fill = function(block, value) {
		var len = memory.blocks[block].length;
		for (var i = 0; i < len; i++) {
			self._poke(block, i, value);
		}

		var isImage = (block === self.VIDEO) ||
			(block === self.TEXTBOX) ||
			(block >= tilePoolStart && block < (tilePoolStart + tilePoolSize));

		// optimize rendering by notifying the graphics system what the fill color is for this image
		if (isImage) {
			graphics.setImageFill(block, value);
		}
	};

	this.set = function(block, index, value) {
		self._poke(block, index, value);
	};

	this.textbox = function(visible, x, y, w, h) {
		if (visible != undefined) {
			self._poke(textboxAttributeBlock, 0, (visible === true) ? 1 : 0);
		}
		
		if (x != undefined) {
			self._poke(textboxAttributeBlock, 1, x);
		}
		
		if (y != undefined) {
			self._poke(textboxAttributeBlock, 2, y);
		}

		var prevWidth = self._peek(textboxAttributeBlock, 3);
		var prevHeight = self._peek(textboxAttributeBlock, 4);

		if (w != undefined) {
			self._poke(textboxAttributeBlock, 3, w);
		}
		
		if (h != undefined) {
			self._poke(textboxAttributeBlock, 4, h);
		}

		if (w != undefined && h != undefined && (prevWidth != w || prevHeight != h)) {
			// re-allocate the textbox block (should I have a helper function for this?)
			memory.blocks[self.TEXTBOX] = [];
			for (var i = 0; i < (w * h); i++) {
				memory.blocks[self.TEXTBOX].push(0);
			}
			memory.changed[self.TEXTBOX] = true;
		}
	};

	/* == SOUND == */
	// duration is in milliseconds (ms)
	this.sound = function(channel, duration, frequency, volume, pulse) {
		self._poke(channel, soundDurationIndex, duration);
		self._poke(channel, soundFrequencyIndex, frequency);
		self._poke(channel, soundVolumeIndex, volume);
		self._poke(channel, soundPulseIndex, pulse);
	};

	// frequency is in decihertz (dHz)
	this.frequency = function(channel, frequency) {
		self._poke(channel, soundFrequencyIndex, frequency);
	};

	// volume: min = 0, max = 15
	this.volume = function(channel, volume) {
		self._poke(channel, soundVolumeIndex, volume);
	};

	/* == EVENTS == */
	this.loop = function(fn) {
		onLoopFunction = fn;
	};

	/* == INTERNAL == */
	// initialize memory blocks
	var gameDataBlock = this._allocate({ str: "" });
	var fontDataBlock = this._allocate({ str: "" });
	this.VIDEO = this._allocate({ size: self.VIDEO_SIZE * self.VIDEO_SIZE });
	this.TEXTBOX = this._allocate();
	this.MAP1 = this._allocate({ size: self.MAP_SIZE * self.MAP_SIZE });
	tileMapLayers.push(this.MAP1);
	this.MAP2 = this._allocate({ size: self.MAP_SIZE * self.MAP_SIZE });
	tileMapLayers.push(this.MAP2);
	var paletteBlock = this._allocate({ size: initialPaletteSize * 3 });
	var buttonBlock = this._allocate({ size: 8 });
	this.SOUND1 = this._allocate({ size: 4 });
	this.SOUND2 = this._allocate({ size: 4 });
	var modeBlock = this._allocate({ size: 8 });
	var textboxAttributeBlock = this._allocate({ size: 8 });

	tilePoolStart = (textboxAttributeBlock + 1);

	// access for debugging
	this._gameDataBlock = gameDataBlock;
	this._fontDataBlock = fontDataBlock;
	this._buttonBlock = buttonBlock;

	// events
	var onLoopFunction = null;
}

var mainProcess = addProcess();
var bitsy = mainProcess.system;
</script>

<!-- engine -->
<script>
/* BITSY VERSION */
// is this the right place for this to live?
var version = {
	major: 8, // major changes
	minor: 3, // smaller changes
	devBuildPhase: "RELEASE",
};
function getEngineVersion() {
	return version.major + "." + version.minor;
}

/* TEXT CONSTANTS */
var titleDialogId = "title";

// todo : where should this be stored?
var tileColorStartIndex = 16;

var TextDirection = {
	LeftToRight : "LTR",
	RightToLeft : "RTL"
};

var defaultFontName = "ascii_small";

/* TUNE CONSTANTS */
var barLength = 16; // sixteenth notes
var minTuneLength = 1;
var maxTuneLength = 16;

// chromatic notes
var Note = {
	NONE 		: -1,
	C 			: 0,	// C
	C_SHARP 	: 1,	// C sharp / D flat
	D 			: 2,	// D
	D_SHARP 	: 3,	// D sharp / E flat
	E 			: 4,	// E
	F 			: 5,	// F
	F_SHARP 	: 6,	// F sharp / G flat
	G 			: 7,	// G
	G_SHARP 	: 8,	// G sharp / A flat
	A 			: 9,	// A
	A_SHARP 	: 10,	// A sharp / B flat
	B 			: 11,	// B
	COUNT 		: 12
};

// solfa notes
var Solfa = {
	NONE 	: -1,
	D 		: 0,	// Do
	R 		: 1,	// Re
	M 		: 2,	// Mi
	F 		: 3,	// Fa
	S 		: 4,	// Sol
	L 		: 5,	// La
	T 		: 6,	// Ti
	COUNT 	: 7
};

var Octave = {
	NONE: -1,
	2: 0,
	3: 1,
	4: 2, // octave 4: middle C octave
	5: 3,
	COUNT: 4
};

var Tempo = {
	SLW: 0, // slow
	MED: 1, // medium
	FST: 2, // fast
	XFST: 3 // extra fast (aka turbo)
};

var SquareWave = {
	P8: 0, // pulse 1 / 8
	P4: 1, // pulse 1 / 4
	P2: 2, // pulse 1 / 2
	COUNT: 3
};

var ArpeggioPattern = {
	OFF: 0,
	UP: 1, // ascending triad chord
	DWN: 2, // descending triad chord
	INT5: 3, // 5 step interval
	INT8: 4 // 8 setp interval
};

function createWorldData() {
	return {
		room : {},
		tile : {},
		sprite : {},
		item : {},
		dialog : {},
		end : {}, // pre-7.0 ending data for backwards compatibility
		palette : { // start off with a default palette
			"default" : {
				name : "default",
				colors : [[0,0,0],[255,255,255],[255,255,255]]
			}
		},
		variable : {},
		tune : {},
		blip : {},
		versionNumberFromComment : -1, // -1 indicates no version information found
		fontName : defaultFontName,
		textDirection : TextDirection.LeftToRight,
		flags : createDefaultFlags(),
		names : {},
		// source data for all drawings (todo: better name?)
		drawings : {},
	};
}

// creates a drawing data structure with default property values for the type
function createDrawingData(type, id) {
	// the avatar's drawing id still uses the sprite prefix (for back compat)
	var drwId = (type === "AVA" ? "SPR" : type) + "_" + id;

	var drawingData = {
		type : type,
		id : id,
		name : null,
		drw : drwId,
		col : (type === "TIL") ? 1 : 2, // foreground color
		bgc : 0, // background color
		animation : {
			isAnimated : false,
			frameIndex : 0,
			frameCount : 1,
		},
	};

	// add type specific properties
	if (type === "TIL") {
		// default null value indicates it can vary from room to room (original version)
		drawingData.isWall = null;
	}

	if (type === "AVA" || type === "SPR") {
		// default sprite location is "offstage"
		drawingData.room = null;
		drawingData.x = -1;
		drawingData.y = -1;
		drawingData.inventory = {};
	}

	if (type === "AVA" || type === "SPR" || type === "ITM") {
		drawingData.dlg = null;
		drawingData.blip = null;
	}

	return drawingData;
}

function createTuneData(id) {
	var tuneData = {
		id : id,
		name : null,
		melody : [],
		harmony : [],
		key: null, // a null key indicates a chromatic scale (all notes enabled)
		tempo: Tempo.MED,
		instrumentA : SquareWave.P2,
		instrumentB : SquareWave.P2,
		arpeggioPattern : ArpeggioPattern.OFF,
	};
	return tuneData;
}

function createTuneBarData() {
	var bar = [];
	for (var i = 0; i < barLength; i++) {
		bar.push({ beats: 0, note: Note.C, octave: Octave[4] });
	}
	return bar;
}

function createTuneKeyData() {
	var key = {
		notes: [], // mapping of the solfa scale degrees to chromatic notes
		scale: []  // list of solfa notes that are enabled for this key
	};

	// initialize notes
	for (var i = 0; i < Solfa.COUNT; i++) {
		key.notes.push(Note.NONE);
	}

	return key;
}

function createBlipData(id) {
	var blipData = {
		id: id,
		name: null,
		pitchA: { beats: 0, note: Note.C, octave: Octave[4] },
		pitchB: { beats: 0, note: Note.C, octave: Octave[4] },
		pitchC: { beats: 0, note: Note.C, octave: Octave[4] },
		envelope: {
			attack: 0, // attack time in ms
			decay: 0, // decay time in ms
			sustain: 0, // sustain volume
			length: 0, // sustain time in ms
			release: 0 // release time in ms
		},
		beat : {
			time: 0, // time in ms between pitch changes
			delay: 0 // time in ms *before* first pitch change
		},
		instrument: SquareWave.P2,
		doRepeat: false
		// TODO : consider for future update
		// doSlide: false,
	};

	return blipData;
}

function createDefaultFlags() {
	return {
		// version
		VER_MAJ: -1, // major version number (-1 = no version information found)
		VER_MIN: -1, // minor version number (-1 = no version information found)
		// compatibility
		ROOM_FORMAT: 0, // 0 = non-comma separated (original), 1 = comma separated (default)
		DLG_COMPAT: 0, // 0 = default dialog behavior, 1 = pre-7.0 dialog behavior
		// config
		TXT_MODE: 0 // 0 = HIREZ (2x - default), 1 = LOREZ (1x)
	};
}

function createDialogData(id) {
	return {
		src : "",
		name : null,
		id : id,
	};
}

function parseWorld(file) {
	bitsy.log("create world data");

	var world = createWorldData();

	bitsy.log("init parse state");

	var parseState = {
		lines : file.split("\n"),
		index : 0,
		spriteStartLocations : {}
	};

	bitsy.log("start reading lines");

	while (parseState.index < parseState.lines.length) {
		var i = parseState.index;
		var lines = parseState.lines;
		var curLine = lines[i];

		// bitsy.log("LN " + i + " xx " + curLine);

		if (i == 0) {
			i = parseTitle(parseState, world);
		}
		else if (curLine.length <= 0 || curLine.charAt(0) === "#") {
			// collect version number from a comment (hacky but required for pre-8.0 compatibility)
			if (curLine.indexOf("# BITSY VERSION ") != -1) {
				world.versionNumberFromComment = parseFloat(curLine.replace("# BITSY VERSION ", ""));
			}

			//skip blank lines & comments
			i++;
		}
		else if (getType(curLine) === "PAL") {
			i = parsePalette(parseState, world);
		}
		else if (getType(curLine) === "ROOM" || getType(curLine) === "SET") { // SET for back compat
			i = parseRoom(parseState, world);
		}
		else if (getType(curLine) === "TIL") {
			i = parseTile(parseState, world);
		}
		else if (getType(curLine) === "SPR") {
			i = parseSprite(parseState, world);
		}
		else if (getType(curLine) === "ITM") {
			i = parseItem(parseState, world);
		}
		else if (getType(curLine) === "DLG") {
			i = parseDialog(parseState, world);
		}
		else if (getType(curLine) === "END") {
			// parse endings for back compat
			i = parseEnding(parseState, world);
		}
		else if (getType(curLine) === "VAR") {
			i = parseVariable(parseState, world);
		}
		else if (getType(curLine) === "DEFAULT_FONT") {
			i = parseFontName(parseState, world);
		}
		else if (getType(curLine) === "TEXT_DIRECTION") {
			i = parseTextDirection(parseState, world);
		}
		else if (getType(curLine) === "FONT") {
			i = parseFontData(parseState, world);
		}
		else if (getType(curLine) === "TUNE") {
			i = parseTune(parseState, world);
		}
		else if (getType(curLine) === "BLIP") {
			i = parseBlip(parseState, world);
		}
		else if (getType(curLine) === "!") {
			i = parseFlag(parseState, world);
		}
		else {
			i++;
		}

		parseState.index = i;
	}

	world.names = createNameMapsForWorld(world);

	placeSprites(parseState, world);

	if ((world.flags.VER_MAJ <= -1 || world.flags.VER_MIN <= -1) && world.versionNumberFromComment > -1) {
		var versionNumberStr = "" + world.versionNumberFromComment;
		versionNumberStr = versionNumberStr.split(".");
		world.flags.VER_MAJ = parseFloat(versionNumberStr[0]);
		world.flags.VER_MIN = parseFloat(versionNumberStr[1]);
	}

	// starting in version v7.0, there were two major changes to dialog behavior:
	// 1) sprite dialog was no longer implicitly linked by the sprite and dialog IDs matching
	//    (see this commit: 5e1adb29faad4e50603c689d2dac143074117b4e)
	// 2) ending dialogs no longer had their own world data type ("END")
	// for the v7.x versions I tried to automatically convert old dialog to the new format,
	// however, that process can be unreliable and lead to weird bugs.
	// with v8.0 and above I will no longer attempt to convert old files, and instead will use
	// a flag to indicate files that need to use the backwards compatible behavior -
	// this is more reliable & configurable (at the cost of making pre-7.0 games a bit harder to edit)
	if (world.flags.VER_MAJ < 7) {
		world.flags.DLG_COMPAT = 1;
	}

	return world;
}

function parseTitle(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var results;
	if (scriptUtils) {
		results = scriptUtils.ReadDialogScript(lines,i);
	}
	else {
		results = { script: lines[i], index: (i + 1) };
	}

	world.dialog[titleDialogId] = createDialogData(titleDialogId);
	world.dialog[titleDialogId].src = results.script;

	i = results.index;
	i++;

	return i;
}

function parsePalette(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;
	var colors = [];
	var name = null;
	while (i < lines.length && lines[i].length > 0) { //look for empty line
		var args = lines[i].split(" ");
		if (args[0] === "NAME") {
			name = lines[i].split(/\s(.+)/)[1];
		}
		else {
			var col = [];
			lines[i].split(",").forEach(function(i) {
				col.push(parseInt(i));
			});
			colors.push(col);
		}
		i++;
	}
	world.palette[id] = {
		id : id,
		name : name,
		colors : colors
	};
	return i;
}

function createRoomData(id) {
	return {
		id: id,
		name: null,
		tilemap: [],
		walls: [],
		exits: [],
		endings: [],
		items: [],
		pal: null,
		ava: null,
		tune: "0"
	};
}

function parseRoom(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);

	var roomData = createRoomData(id);

	i++;

	// create tile map
	if (world.flags.ROOM_FORMAT === 0) {
		// old way: no commas, single char tile ids
		var end = i + bitsy.MAP_SIZE;
		var y = 0;
		for (; i < end; i++) {
			roomData.tilemap.push([]);
			for (x = 0; x < bitsy.MAP_SIZE; x++) {
				roomData.tilemap[y].push(lines[i].charAt(x));
			}
			y++;
		}
	}
	else if (world.flags.ROOM_FORMAT === 1) {
		// new way: comma separated, multiple char tile ids
		var end = i + bitsy.MAP_SIZE;
		var y = 0;
		for (; i < end; i++) {
			roomData.tilemap.push([]);
			var lineSep = lines[i].split(",");
			for (x = 0; x < bitsy.MAP_SIZE; x++) {
				roomData.tilemap[y].push(lineSep[x]);
			}
			y++;
		}
	}

	while (i < lines.length && lines[i].length > 0) { //look for empty line
		// bitsy.log(getType(lines[i]));
		if (getType(lines[i]) === "SPR") {
			/* NOTE SPRITE START LOCATIONS */
			var sprId = getId(lines[i]);
			if (sprId.indexOf(",") == -1 && lines[i].split(" ").length >= 3) { //second conditional checks for coords
				/* PLACE A SINGLE SPRITE */
				var sprCoord = lines[i].split(" ")[2].split(",");
				parseState.spriteStartLocations[sprId] = {
					room : id,
					x : parseInt(sprCoord[0]),
					y : parseInt(sprCoord[1])
				};
			}
			else if ( world.flags.ROOM_FORMAT == 0 ) { // TODO: right now this shortcut only works w/ the old comma separate format
				/* PLACE MULTIPLE SPRITES*/ 
				//Does find and replace in the tilemap (may be hacky, but its convenient)
				var sprList = sprId.split(",");
				for (row in roomData.tilemap) {
					for (s in sprList) {
						var col = roomData.tilemap[row].indexOf( sprList[s] );
						//if the sprite is in this row, replace it with the "null tile" and set its starting position
						if (col != -1) {
							roomData.tilemap[row][col] = "0";
							parseState.spriteStartLocations[ sprList[s] ] = {
								room : id,
								x : parseInt(col),
								y : parseInt(row)
							};
						}
					}
				}
			}
		}
		else if (getType(lines[i]) === "ITM") {
			var itmId = getId(lines[i]);
			var itmCoord = lines[i].split(" ")[2].split(",");
			var itm = {
				id: itmId,
				x : parseInt(itmCoord[0]),
				y : parseInt(itmCoord[1])
			};
			roomData.items.push( itm );
		}
		else if (getType(lines[i]) === "WAL") {
			/* DEFINE COLLISIONS (WALLS) */
			roomData.walls = getId(lines[i]).split(",");
		}
		else if (getType(lines[i]) === "EXT") {
			/* ADD EXIT */
			var exitArgs = lines[i].split(" ");
			//arg format: EXT 10,5 M 3,2 [AVA:7 LCK:a,9] [AVA 7 LCK a 9]
			var exitCoords = exitArgs[1].split(",");
			var destName = exitArgs[2];
			var destCoords = exitArgs[3].split(",");
			var ext = {
				x : parseInt(exitCoords[0]),
				y : parseInt(exitCoords[1]),
				dest : {
					room : destName,
					x : parseInt(destCoords[0]),
					y : parseInt(destCoords[1])
				},
				transition_effect : null,
				dlg: null,
			};

			// optional arguments
			var exitArgIndex = 4;
			while (exitArgIndex < exitArgs.length) {
				if (exitArgs[exitArgIndex] == "FX") {
					ext.transition_effect = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else if (exitArgs[exitArgIndex] == "DLG") {
					ext.dlg = exitArgs[exitArgIndex+1];
					exitArgIndex += 2;
				}
				else {
					exitArgIndex += 1;
				}
			}

			roomData.exits.push(ext);
		}
		else if (getType(lines[i]) === "END") {
			/* ADD ENDING */
			var endId = getId(lines[i]);

			var endCoords = getCoord(lines[i], 2);
			var end = {
				id : endId,
				x : parseInt(endCoords[0]),
				y : parseInt(endCoords[1])
			};

			roomData.endings.push(end);
		}
		else if (getType(lines[i]) === "PAL") {
			/* CHOOSE PALETTE (that's not default) */
			roomData.pal = getId(lines[i]);
		}
		else if (getType(lines[i]) === "AVA") {
			// change avatar appearance per room
			roomData.ava = getId(lines[i]);
		}
		else if (getType(lines[i]) === "TUNE") {
			roomData.tune = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			roomData.name = getNameArg(lines[i]);
		}

		i++;
	}

	world.room[id] = roomData;

	return i;
}

function parseTile(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var tileData = createDrawingData("TIL", id);

	i++;

	// read & store tile image source
	i = parseDrawingCore(lines, i, tileData.drw, world);

	// update animation info
	tileData.animation.frameCount = getDrawingFrameCount(world, tileData.drw);
	tileData.animation.isAnimated = tileData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			tileData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "BGC") {
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				tileData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				tileData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			tileData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) === "WAL") {
			var wallArg = getArg(lines[i], 1);
			if (wallArg === "true") {
				tileData.isWall = true;
			}
			else if (wallArg === "false") {
				tileData.isWall = false;
			}
		}

		i++;
	}

	// store tile data
	world.tile[id] = tileData;

	return i;
}

function parseSprite(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var type = (id === "A") ? "AVA" : "SPR";
	var spriteData = createDrawingData(type, id);

	// bitsy.log(spriteData);

	i++;

	// read & store sprite image source
	i = parseDrawingCore(lines, i, spriteData.drw, world);

	// update animation info
	spriteData.animation.frameCount = getDrawingFrameCount(world, spriteData.drw);
	spriteData.animation.isAnimated = spriteData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			spriteData.col = parseInt(getId(lines[i]));
		}
		else if (getType(lines[i]) === "BGC") {
			/* BACKGROUND COLOR */
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				spriteData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				spriteData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "POS") {
			/* STARTING POSITION */
			var posArgs = lines[i].split(" ");
			var roomId = posArgs[1];
			var coordArgs = posArgs[2].split(",");
			parseState.spriteStartLocations[id] = {
				room : roomId,
				x : parseInt(coordArgs[0]),
				y : parseInt(coordArgs[1])
			};
		}
		else if(getType(lines[i]) === "DLG") {
			spriteData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			spriteData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) === "ITM") {
			/* ITEM STARTING INVENTORY */
			var itemId = getId(lines[i]);
			var itemCount = parseFloat(getArg(lines[i], 2));
			spriteData.inventory[itemId] = itemCount;
		}
		else if (getType(lines[i]) == "BLIP") {
			var blipId = getId(lines[i]);
			spriteData.blip = blipId;
		}

		i++;
	}

	// store sprite data
	world.sprite[id] = spriteData;

	return i;
}

function parseItem(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	var itemData = createDrawingData("ITM", id);

	i++;

	// read & store item image source
	i = parseDrawingCore(lines, i, itemData.drw, world);

	// update animation info
	itemData.animation.frameCount = getDrawingFrameCount(world, itemData.drw);
	itemData.animation.isAnimated = itemData.animation.frameCount > 1;

	// read other properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "COL") {
			/* COLOR OFFSET INDEX */
			itemData.col = parseInt(getArg(lines[i], 1));
		}
		else if (getType(lines[i]) === "BGC") {
			/* BACKGROUND COLOR */
			var bgcId = getId(lines[i]);
			if (bgcId === "*") {
				// transparent background
				itemData.bgc = (-1 * tileColorStartIndex);
			}
			else {
				itemData.bgc = parseInt(bgcId);
			}
		}
		else if (getType(lines[i]) === "DLG") {
			itemData.dlg = getId(lines[i]);
		}
		else if (getType(lines[i]) === "NAME") {
			/* NAME */
			itemData.name = getNameArg(lines[i]);
		}
		else if (getType(lines[i]) == "BLIP") {
			var blipId = getId(lines[i]);
			itemData.blip = blipId;
		}

		i++;
	}

	// store item data
	world.item[id] = itemData;

	return i;
}

function parseDrawingCore(lines, i, drwId, world) {
	var frameList = []; //init list of frames
	frameList.push( [] ); //init first frame
	var frameIndex = 0;
	var y = 0;
	while (y < bitsy.TILE_SIZE) {
		var line = lines[i + y];
		var row = [];

		for (x = 0; x < bitsy.TILE_SIZE; x++) {
			row.push(parseInt(line.charAt(x)));
		}

		frameList[frameIndex].push(row);
		y++;

		if (y === bitsy.TILE_SIZE) {
			i = i + y;
			if (lines[i] != undefined && lines[i].charAt(0) === ">") {
				// start next frame!
				frameList.push([]);
				frameIndex++;

				//start the count over again for the next frame
				i++;
				y = 0;
			}
		}
	}

	storeDrawingData(world, drwId, frameList);

	return i;
}

function parseDialog(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	// hacky but I need to store this so I can set the name below
	var id = getId(lines[i]);

	i = parseScript(lines, i, world.dialog);

	if (i < lines.length && lines[i].length > 0 && getType(lines[i]) === "NAME") {
		world.dialog[id].name = getNameArg(lines[i]);
		i++;
	}

	return i;
}

// keeping this around to parse old files where endings were separate from dialogs
function parseEnding(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	return parseScript(lines, i, world.end);
}

function parseScript(lines, i, data) {
	var id = getId(lines[i]);
	i++;

	var results;
	if (scriptUtils) {
		results = scriptUtils.ReadDialogScript(lines,i);
	}
	else {
		results = { script: lines[i], index: (i + 1)};
	}

	data[id] = createDialogData(id);
	data[id].src = results.script;

	i = results.index;

	return i;
}

function parseVariable(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);
	i++;
	var value = lines[i];
	i++;
	world.variable[id] = value;
	return i;
}

function parseFontName(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	world.fontName = getArg(lines[i], 1);
	i++;
	return i;
}

function parseTextDirection(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	world.textDirection = getArg(lines[i], 1);
	i++;
	return i;
}

function parseFontData(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	// NOTE : we're not doing the actual parsing here --
	// just grabbing the block of text that represents the font
	// and giving it to the font manager to use later

	var localFontName = getId(lines[i]);
	var localFontData = lines[i];
	i++;

	while (i < lines.length && lines[i] != "") {
		localFontData += "\n" + lines[i];
		i++;
	}

	var localFontFilename = localFontName + fontManager.GetExtension();
	fontManager.AddResource( localFontFilename, localFontData );

	return i;
}

function parseTune(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;

	var tuneData = createTuneData(id);

	var barIndex = 0;
	while (barIndex < maxTuneLength) {
		// MELODY
		var melodyBar = createTuneBarData();
		var melodyNotes = lines[i].split(",");
		for (var j = 0; j < barLength; j++) {
			// default to a rest
			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };

			if (j < melodyNotes.length) {
				var pitchSplit = melodyNotes[j].split("~");
				var pitchStr = pitchSplit[0];
				pitch = parsePitch(melodyNotes[j]);

				// look for effect added to the note
				if (pitchSplit.length > 1) {
					var blipId = pitchSplit[1];
					pitch.blip = blipId;
				}
			}

			melodyBar[j] = pitch;
		}
		tuneData.melody.push(melodyBar);
		i++;

		// HARMONY
		var harmonyBar = createTuneBarData();
		var harmonyNotes = lines[i].split(",");
		for (var j = 0; j < barLength; j++) {
			// default to a rest
			var pitch = { beats: 0, note: Note.C, octave: Octave[4], };

			if (j < harmonyNotes.length) {
				var pitchSplit = harmonyNotes[j].split("~");
				var pitchStr = pitchSplit[0];
				pitch = parsePitch(harmonyNotes[j]);

				// look for effect added to the note
				if (pitchSplit.length > 1) {
					var blipId = pitchSplit[1];
					pitch.blip = blipId;
				}
			}

			harmonyBar[j] = pitch;
		}
		tuneData.harmony.push(harmonyBar);
		i++;

		// check if there's another bar after this one
		if (lines[i] === ">") {
			// there is! increment the index
			barIndex++;
			i++;
		}
		else {
			// we've reached the end of the tune!
			barIndex = maxTuneLength;
		}
	}

	// parse other tune properties
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "KEY") {
			tuneData.key = createTuneKeyData();

			var keyNotes = getArg(lines[i], 1);
			if (keyNotes) {
				keyNotes = keyNotes.split(",");
				for (var j = 0; j < keyNotes.length && j < tuneData.key.notes.length; j++) {
					var pitch = parsePitch(keyNotes[j]);
					tuneData.key.notes[j] = pitch.note;
				}
			}

			var keyScale = getArg(lines[i], 2);
			if (keyScale) {
				keyScale = keyScale.split(",");
				for (var j = 0; j < keyScale.length; j++) {
					var pitch = parsePitch(keyScale[j]);
					if (pitch.note > Solfa.NONE && pitch.note < Solfa.COUNT) {
						tuneData.key.scale.push(pitch.note);
					}
				}
			}
		}
		else if (getType(lines[i]) === "TMP") {
			var tempoId = getId(lines[i]);
			if (Tempo[tempoId] != undefined) {
				tuneData.tempo = Tempo[tempoId];
			}
		}
		else if (getType(lines[i]) === "SQR") {
			// square wave instrument settings
			var squareWaveIdA = getArg(lines[i], 1);
			if (SquareWave[squareWaveIdA] != undefined) {
				tuneData.instrumentA = SquareWave[squareWaveIdA];
			}

			var squareWaveIdB = getArg(lines[i], 2);
			if (SquareWave[squareWaveIdB] != undefined) {
				tuneData.instrumentB = SquareWave[squareWaveIdB];
			}
		}
		else if (getType(lines[i]) === "ARP") {
			var arp = getId(lines[i]);
			if (ArpeggioPattern[arp] != undefined) {
				tuneData.arpeggioPattern = ArpeggioPattern[arp];
			}
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			tuneData.name = name;
			// todo : add to map?
		}

		i++;
	}

	world.tune[id] = tuneData;

	return i;
}

function parseBlip(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;

	var id = getId(lines[i]);
	i++;

	var blipData = createBlipData(id);

	// blip pitches
	var notes = lines[i].split(",");
	if (notes.length >= 1) {
		blipData.pitchA = parsePitch(notes[0]);
	}
	if (notes.length >= 2) {
		blipData.pitchB = parsePitch(notes[1]);
	}
	if (notes.length >= 3) {
		blipData.pitchC = parsePitch(notes[2]);
	}
	i++;

	// blip parameters
	while (i < lines.length && lines[i].length > 0) { // look for empty line
		if (getType(lines[i]) === "ENV") {
			// envelope
			blipData.envelope.attack = parseInt(getArg(lines[i], 1));
			blipData.envelope.decay = parseInt(getArg(lines[i], 2));
			blipData.envelope.sustain = parseInt(getArg(lines[i], 3));
			blipData.envelope.length = parseInt(getArg(lines[i], 4));
			blipData.envelope.release = parseInt(getArg(lines[i], 5));
		}
		else if (getType(lines[i]) === "BEAT") {
			// pitch beat length
			blipData.beat.time = parseInt(getArg(lines[i], 1));
			blipData.beat.delay = parseInt(getArg(lines[i], 2));
		}
		else if (getType(lines[i]) === "SQR") {
			// square wave
			var squareWaveId = getArg(lines[i], 1);
			if (SquareWave[squareWaveId] != undefined) {
				blipData.instrument = SquareWave[squareWaveId];
			}
		}
		// TODO : consider for future update
		// else if (getType(lines[i]) === "SLD") {
		// 	// slide mode
		// 	if (parseInt(getArg(lines[i], 1)) === 1) {
		// 		blipData.doSlide = true;
		// 	}
		// }
		else if (getType(lines[i]) === "RPT") {
			// repeat mode
			if (parseInt(getArg(lines[i], 1)) === 1) {
				blipData.doRepeat = true;
			}
		}
		else if (getType(lines[i]) === "NAME") {
			var name = lines[i].split(/\s(.+)/)[1];
			blipData.name = name;
		}

		i++;
	}

	world.blip[id] = blipData;

	return i;
}

function parsePitch(pitchStr) {
	var pitch = { beats: 1, note: Note.C, octave: Octave[4], };
	var i;

	// beats
	var beatsToken = "";
	for (i = 0; i < pitchStr.length && ("0123456789".indexOf(pitchStr[i]) != -1); i++) {
		beatsToken += pitchStr[i];
	}
	if (beatsToken.length > 0) {
		pitch.beats = parseInt(beatsToken);
	}

	// note
	var noteType;
	var noteName = "";
	if (i < pitchStr.length) {
		if (pitchStr[i] === pitchStr[i].toUpperCase()) {
			// uppercase letters represent chromatic notes
			noteType = Note;
			noteName += pitchStr[i];
			i++;

			// check for sharp
			if (i < pitchStr.length && pitchStr[i] === "#") {
				noteName += "_SHARP";
				i++;
			}
		}
		else {
			// lowercase letters represent solfa notes
			noteType = Solfa;
			noteName += pitchStr[i].toUpperCase();
			i++;
		}
	}

	if (noteType != undefined && noteType[noteName] != undefined) {
		pitch.note = noteType[noteName];
	}

	// octave
	var octaveToken = "";
	if (i < pitchStr.length) {
		octaveToken += pitchStr[i];
	}

	if (Octave[octaveToken] != undefined) {
		pitch.octave = Octave[octaveToken];
	}

	return pitch;
}

function parseFlag(parseState, world) {
	var i = parseState.index;
	var lines = parseState.lines;
	var id = getId(lines[i]);
	var valStr = lines[i].split(" ")[2];
	world.flags[id] = parseInt( valStr );
	i++;
	return i;
}

function getDrawingFrameCount(world, drwId) {
	return world.drawings[drwId].length;
}

function storeDrawingData(world, drwId, drawingData) {
	world.drawings[drwId] = drawingData;
}

function placeSprites(parseState, world) {
	for (id in parseState.spriteStartLocations) {
		world.sprite[id].room = parseState.spriteStartLocations[id].room;
		world.sprite[id].x = parseState.spriteStartLocations[id].x;
		world.sprite[id].y = parseState.spriteStartLocations[id].y;
	}
}

function createNameMapsForWorld(world) {
	var nameMaps = {};

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	nameMaps.room = createNameMap(world.room);
	nameMaps.tile = createNameMap(world.tile);
	nameMaps.sprite = createNameMap(world.sprite);
	nameMaps.item = createNameMap(world.item);
	nameMaps.dialog = createNameMap(world.dialog);
	nameMaps.palette = createNameMap(world.palette);
	nameMaps.tune = createNameMap(world.tune);
	nameMaps.blip = createNameMap(world.blip);

	return nameMaps;
}

function getType(line) {
	return getArg(line,0);
}

function getId(line) {
	return getArg(line,1);
}

function getCoord(line,arg) {
	return getArg(line,arg).split(",");
}

function getArg(line,arg) {
	return line.split(" ")[arg];
}

function getNameArg(line) {
	var name = line.split(/\s(.+)/)[1];
	return name;
}
</script>

<script>
/* PITCH HELPER FUNCTIONS */
function pitchToSteps(pitch) {
	return (pitch.octave * Note.COUNT) + pitch.note;
}

function stepsToPitch(steps) {
	var pitch = { beats: 1, note: Note.C, octave: Octave[2], };

	while (steps >= Note.COUNT) {
		pitch.octave = (pitch.octave + 1) % Octave.COUNT;
		steps -= Note.COUNT;
	}

	pitch.note += steps;

	// make sure pitch isn't outside a valid range
	if (pitch.note <= Note.NONE) {
		pitch.note = Note.C;
	}
	else if (pitch.note >= Note.COUNT) {
		pitch.note = Note.B;
	}

	if (pitch.octave <= Octave.NONE) {
		pitch.octave = Octave[2];
	}
	else if (pitch.octave >= Octave.COUNT) {
		pitch.octave = Octave[5];
	}

	return pitch;
}

function adjustPitch(pitch, stepDelta) {
	return stepsToPitch(pitchToSteps(pitch) + stepDelta);
}

function pitchDistance(pitchA, pitchB) {
	return pitchToSteps(pitchB) - pitchToSteps(pitchA);
}

function isMinPitch(pitch) {
	return pitchToSteps(pitch) <= pitchToSteps({ note: Note.C, octave: Octave[2] });
}

function isMaxPitch(pitch) {
	return pitchToSteps(pitch) >= pitchToSteps({ note: Note.B, octave: Octave[5] });
}

function SoundPlayer() {
	// frequencies (in hertz) for octave 0 (or is it octave 4?)
	var frequencies = [
		261.7, // middle C
		277.2,
		293.7,
		311.2,
		329.7,
		349.3,
		370.0,
		392.0,
		415.3,
		440.0,
		466.2,
		493.9,
	];

	// tempos are calculated as the duration of a 16th note, rounded to the nearest millisecond
	var tempos = {};
	tempos[Tempo.SLW] = 250; // 60bpm (adagio)
	tempos[Tempo.MED] = 188; // ~80bpm (andante) [exact would be 187.5 ms]
	tempos[Tempo.FST] = 125; // 120bpm (moderato)
	tempos[Tempo.XFST] = 94; // ~160bpm (allegro) [exact would be 93.75 ms]

	// arpeggio patterns expressed in scale degrees
	var arpeggioPattern = {};
	arpeggioPattern[ArpeggioPattern.UP] = [0, 2, 4, 7];
	arpeggioPattern[ArpeggioPattern.DWN] = [7, 4, 2, 0];
	arpeggioPattern[ArpeggioPattern.INT5] = [0, 4];
	arpeggioPattern[ArpeggioPattern.INT8] = [0, 7];

	this.getArpeggioSteps = function(tune) { return arpeggioPattern[tune.arpeggioPattern]; };

	function isPitchPlayable(pitch, key) {
		if (pitch.beats <= 0) {
			return false;
		}

		if (key === undefined || key === null) {
			return true;
		}

		// test if note is in the scale
		return (key.scale.indexOf(pitch.note) > -1)
			&& (key.notes[pitch.note] > Note.NONE)
			&& (key.notes[pitch.note] < Note.COUNT);
	}

	function pitchToChromatic(pitch, key) {
		if (pitch === undefined || pitch === null) {
			return null;
		}

		if (key === undefined || key === null) {
			return pitch;
		}

		// convert from solfa
		var octaveOffset = (pitch.note >= Solfa.COUNT) ? 1 : 0;

		return {
			beats: pitch.beats,
			octave: pitch.octave + octaveOffset,
			// todo : what about the scale limits?
			note: key.notes[(pitch.note % Solfa.COUNT)],
			blip: pitch.blip
		};
	}

	function makePitchFrequency(pitch) {
		// todo : this clamp shouldn't be required.. there's a bug in the pitch shifting somewhere
		var note = Math.max(0, pitch.note);
		var octave = (pitch.octave != undefined ? pitch.octave : Octave[4]);

		var octaveMin = Octave[2];
		var octaveMax = Octave[5];

		// make sure octave is in valid range
		octave = Math.max(octaveMin, Math.min(octave, octaveMax));
		var distFromMiddleC = octave - 2;

		var freq = frequencies[note] * Math.pow(2, distFromMiddleC);

		if (isNaN(freq)) {
			bitsy.log("invalid frequency " + pitch, "sound");
		}

		return freq;
	}

	var maxVolume = 15; // todo : should this be a system constant?
	var noteVolume = 5;

	var curTune = null;
	var isTunePaused = false;
	var barIndex = -1;
	var curArpeggio = [];

	var beat16 = 0;
	var beat16Timer = 0;
	var beat16Index = 0;

	// special settings
	var isLooping = false;
	var isMelodyMuted = false;
	var maxBeatCount = null;
	var muteTimer = 0; // allow temporary muting of all notes

	function arpeggiateBar(bar, key, pattern) {
		var arpeggio = [];

		if (key != undefined && key != null && isPitchPlayable(bar[0], key)) {
			for (var i = 0; i < arpeggioPattern[pattern].length; i++) {
				var pitch = { beats: 1, note: bar[0].note + arpeggioPattern[pattern][i], octave: bar[0].octave };
				arpeggio.push(pitchToChromatic(pitch, key));
			}
		}

		for (var i = 0; i < arpeggio.length; i++) {
			bitsy.log(i + ": " + serializeNote(arpeggio[i].note));
		}

		return arpeggio;
	};

	function playNote(pitch, instrument, options) {
		if (pitch.beats <= 0) {
			return;
		}

		var channel = bitsy.SOUND1;
		if (options != undefined && options.channel != undefined) {
			channel = options.channel;
		}

		var key = null;
		if (options != undefined && options.key != undefined) {
			key = options.key;
		}

		var beatLen = beat16;
		if (options != undefined && options.beatLen != undefined) {
			beatLen = options.beatLen;
		}

		if (isPitchPlayable(pitch, key)) {
			var freq = makePitchFrequency(pitchToChromatic(pitch, key));
			bitsy.sound(channel, (pitch.beats * beatLen), freq * 100, noteVolume, instrument);
		}
	}

	function sfxFrequencyAtTime(sfx, time) {
		var beatDelay = sfx.blip.beat.delay;
		var beatTime = sfx.blip.beat.time;
		var delta = Math.max(0, time - beatDelay) / beatTime;

		var pitchDelta = sfx.blip.doRepeat
			? (delta % sfx.frequencies.length)
			: Math.min(delta, sfx.frequencies.length - 1);

		sfx.pitchIndex = Math.floor(pitchDelta);
		var curFreq = sfx.frequencies[sfx.pitchIndex];

		// TODO : consider for future update
		// if (sfx.blip.doSlide) {
		// 	var nextPitchIndex = (sfx.pitchIndex + 1) % sfx.frequencies.length;
		// 	var nextFreq = sfx.frequencies[nextPitchIndex];
		// 	var d = pitchDelta - sfx.pitchIndex;
		// 	curFreq = curFreq + ((nextFreq - curFreq) * d);
		// }

		return curFreq;
	}

	function sfxVolumeAtTime(sfx, time) {
		var volume = 0;

		// use envelope settings to calculate volume
		var attack = sfx.blip.envelope.attack;
		var decay = sfx.blip.envelope.decay;
		var length = sfx.blip.envelope.length;
		var release = sfx.blip.envelope.release;
		if (time < attack) {
			// attack
			var t = time / attack;
			volume = Math.floor(sfxPeakVolume * t);
		}
		else if (time < attack + decay) {
			// decay
			var t = (time - attack) / decay;
			var d = sfx.blip.envelope.sustain - sfxPeakVolume;
			volume = Math.floor(sfxPeakVolume + (d * t));
		}
		else if (time < attack + decay + length) {
			// sustain
			volume = sfx.blip.envelope.sustain;
		}
		else if (time < attack + decay + length + release) {
			// release
			var t = (time - (attack + decay + length)) / release;
			volume = Math.floor(sfx.blip.envelope.sustain * (1 - t));
		}
		else {
			volume = 0;
		}

		return volume;
	}

	function updateSfx(dt) {
		// try limiting the max change per frame
		dt = Math.min(dt, 32);
		var isAnyBlipPlaying = false;

		if (activeSfx != null) {
			isAnyBlipPlaying = true;
			var sfx = activeSfx;

			sfx.timer += dt;
			if (sfx.timer >= sfx.duration) {
				sfx.timer = sfx.duration;
			}

			if (sfx.frequencies.length > 0) {
				// update pitch
				var prevPitchIndex = sfx.pitchIndex;
				var freq = sfxFrequencyAtTime(sfx, sfx.timer);
				if (prevPitchIndex != sfx.pitchIndex) {
					// pitch changed!
					bitsy.frequency(bitsy.SOUND1, freq * 100);
				}

				// update volume envelope
				bitsy.volume(bitsy.SOUND1, sfxVolumeAtTime(sfx, sfx.timer));
			}

			if (sfx.timer >= sfx.duration) {
				// turn off sound
				bitsy.volume(bitsy.SOUND1, 0);
				activeSfx = null;
			}
		}

		if (isMusicPausedForBlip && !isAnyBlipPlaying) {
			isMusicPausedForBlip = false;
		}
	}

	function updateTune(dt) {
		if (curTune === undefined || curTune === null) {
			return;
		}

		beat16Timer += dt;

		if (muteTimer > 0) {
			muteTimer -= dt;
		}

		if (beat16Timer >= beat16) {
			beat16Timer = 0;
			beat16Index++;

			if (beat16Index >= 16) {
				beat16Index = 0;

				if (!isLooping) {
					barIndex = (barIndex + 1) % curTune.melody.length;

					if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {
						curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);
					}
				}
			}

			if (muteTimer <= 0) {
				if (!isMelodyMuted) {
					// melody note
					var pitchA = curTune.melody[barIndex][beat16Index];
					if (pitchA.beats > 0) {
						// since they're played on the same channel, any melody note will cancel a blip
						activeSfx = null;
					}

					if (pitchA.blip != undefined && pitchA.beats > 0) {
						playBlip(blip[pitchA.blip], { interruptMusic: false, pitch: pitchA, key: curTune.key });
					}
					else {
						playNote(pitchA, curTune.instrumentA, { channel: bitsy.SOUND1, key: curTune.key });
					}
				}

				if (curTune.arpeggioPattern === ArpeggioPattern.OFF) {
					// harmony note
					var pitchB = curTune.harmony[barIndex][beat16Index];
					if (pitchB.blip != undefined && pitchB.beats > 0) {
						playBlip(blip[pitchB.blip], { interruptMusic: false, pitch: pitchB, key: curTune.key });
					}
					else {
						playNote(pitchB, curTune.instrumentB, { channel: bitsy.SOUND2, key: curTune.key });
					}
				}
				else {
					var arpPitch = curArpeggio[beat16Index % curArpeggio.length];
					if (arpPitch != undefined && arpPitch.beats > 0) {
						playNote(arpPitch, curTune.instrumentB, { channel: bitsy.SOUND2, beatLen: beat16 });
					}
				}
			}

			if (maxBeatCount != null && beat16Index >= (maxBeatCount - 1)) {
				// stop playback early
				curTune = null;
			}
		}
	}

	this.update = function(dt) {
		updateSfx(dt);
		if (!isTunePaused && !isMusicPausedForBlip) {
			updateTune(dt);
		}
	};

	this.playTune = function(tune, options) {
		curTune = tune;
		beat16Timer = 0;
		beat16Index = -1;
		barIndex = 0;

		isLooping = false;
		isMelodyMuted = false;
		maxBeatCount = null;

		// special options for the editor
		if (options != undefined) {
			if (options.barIndex != undefined) {
				barIndex = options.barIndex;
			}

			if (options.loop != undefined) {
				isLooping = options.loop;
			}

			if (options.melody != undefined) {
				isMelodyMuted = !options.melody;
			}

			if (options.beatCount != undefined) {
				maxBeatCount = options.beatCount;
			}
		}

		// update tempo
		beat16 = tempos[curTune.tempo];

		if (curTune.arpeggioPattern != ArpeggioPattern.OFF && curTune.key != null) {
			curArpeggio = arpeggiateBar(curTune.harmony[barIndex], curTune.key, curTune.arpeggioPattern);
		}
	};

	this.isTunePlaying = function() {
		return curTune != null;
	};

	this.getCurTuneId = function() {
		if (curTune) {
			return curTune.id;
		}

		return null;
	};

	this.stopTune = function() {
		curTune = null;
	};

	this.pauseTune = function() {
		isTunePaused = true;
	};

	this.resumeTune = function() {
		isTunePaused = false;
	};

	this.getBeat = function() {
		if (curTune == null) {
			return null;
		}

		return {
			bar : barIndex,
			beat : beat16Index,
		};
	};

	this.getBlipState = function() {
		return activeSfx;
	};

	this.playNote = function(pitch, instrument, channel, key) {
		beat16 = tempos[Tempo.SLW];
		muteTimer = beat16;
		playNote(pitch, instrument, { channel: channel, key: key });
	};

	this.setTempo = function(tempo) {
		beat16 = tempos[tempo];
	};

	this.setLooping = function(looping) {
		isLooping = looping;
	};

	/* SOUND EFFECTS */
	var sfxPeakVolume = 10; // todo : is this a good value?
	var activeSfx = null;
	var isMusicPausedForBlip = false;

	function createSfxState(blip, pitch, isPitchRandomized) {
		// bitsy.log("init sfx blip: " + blip.id);

		var sfxState = {
			blip : blip,
			pitchIndex : -1,
			frequencies : [],
			timer : 0,
			duration : 0,
		};

		// is it weird to track this both in the system *AND* the engine?
		sfxState.duration = (blip.envelope.attack + blip.envelope.decay + blip.envelope.length + blip.envelope.release);

		// adjust starting pitch
		var step = 0;
		if (pitch != null) {
			step = pitchDistance(blip.pitchA, pitch);
		}
		else if (isPitchRandomized > 0) {
			step = Math.floor(Math.random() * 6);
		}

		if (blip.pitchA.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchA, step)));
		}
		if (blip.pitchB.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchB, step)));
		}
		if (blip.pitchC.beats > 0) {
			sfxState.frequencies.push(makePitchFrequency(adjustPitch(blip.pitchC, step)));
		}

		return sfxState;
	}

	function playBlip(blip, options) {
		// default to pausing music while the blip plays (except when playing a blip as *part* of music)
		isMusicPausedForBlip = (options === undefined || options.interruptMusic === undefined) ? true : options.interruptMusic;

		// always play blips on channel 1
		var channel = bitsy.SOUND1;

		// other options
		var pitch = (options === undefined || options.pitch === undefined) ? null : options.pitch;
		var isPitchRandomized = (options === undefined || options.isPitchRandomized === undefined) ? false : options.isPitchRandomized;
		var key = (options != undefined && options.key != undefined) ? options.key : null;

		activeSfx = createSfxState(blip, pitchToChromatic(pitch, key), isPitchRandomized);
		bitsy.log("play blip: " + activeSfx.frequencies);

		bitsy.sound(
			channel,
			activeSfx.duration * 10, // HACK : mult by 10 is to avoid accidentally turning off early
			activeSfx.frequencies.length > 0 ? (activeSfx.frequencies[0] * 100) : 0,
			0, // volume
			activeSfx.blip.instrument);
	};

	this.playBlip = playBlip;

	this.isBlipPlaying = function() {
		return isMusicPausedForBlip; // todo : rename this variable?
	};

	// todo : should any of this stuff be moved into the tool code?
	this.sampleBlip = function(blip, sampleCount) {
		var sfx = createSfxState(blip, null, false);

		var minFreq = makePitchFrequency({ note: Note.C, octave: Octave[2] });
		var maxFreq = makePitchFrequency({ note: Note.B, octave: Octave[5] });

		// sample the frequency of the sound
		var frequencySamples = [];
		for (var i = 0; i < sampleCount; i++) {
			if (sfx.frequencies.length > 0) {
				var t = Math.floor((i / sampleCount) * sfx.duration);
				// get frequency at time
				var freq = sfxFrequencyAtTime(sfx, t);
				// normalize the sample
				freq = freq / (maxFreq - minFreq);

				frequencySamples.push(freq);
			}
			else {
				frequencySamples.push(0);
			}
		}

		// sample the volume envelope
		var amplitudeSamples = [];
		for (var i = 0; i < sampleCount; i++) {
			var t = Math.floor((i / sampleCount) * sfx.duration);
			amplitudeSamples.push(sfxVolumeAtTime(sfx, t) / maxVolume);
		}

		return {
			frequencies: frequencySamples,
			amplitudes: amplitudeSamples
		};
	};
}
</script>

<script>
/*
TODO:
- can I simplify this more now that I've removed the external resources stuff?
*/

function FontManager(packagedFontNames) {

var self = this;

var fontExtension = ".bitsyfont";
this.GetExtension = function() {
	return fontExtension;
}

// place to store font data
var fontResources = {};

// load fonts from the editor
if (packagedFontNames != undefined && packagedFontNames != null && packagedFontNames.length > 0
		&& Resources != undefined && Resources != null) {

	for (var i = 0; i < packagedFontNames.length; i++) {
		var filename = packagedFontNames[i];
		fontResources[filename] = Resources[filename];
	}
}

// manually add resource
this.AddResource = function(filename, fontdata) {
	fontResources[filename] = fontdata;
}

this.ContainsResource = function(filename) {
	return fontResources[filename] != null;
}

function GetData(fontName) {
	return fontResources[fontName + fontExtension];
}
this.GetData = GetData;

function Create(fontData) {
	return new Font(fontData);
}
this.Create = Create;

this.Get = function(fontName) {
	var fontData = self.GetData(fontName);
	return self.Create(fontData);
}

function Font(fontData) {
	bitsy.log("create font");

	var name = "unknown";
	var width = 6; // default size so if you have NO font or an invalid font it displays boxes
	var height = 8;
	var chardata = {};

	// create invalid char data at default size in case the font is missing
	var invalidCharData = {};
	updateInvalidCharData();

	this.getName = function() {
		return name;
	}

	this.getData = function() {
		return chardata;
	}

	this.getWidth = function() {
		return width;
	}

	this.getHeight = function() {
		return height;
	}

	this.hasChar = function(char) {
		var codepoint = char.charCodeAt(0);
		return chardata[codepoint] != null;
	}

	this.getChar = function(char) {

		var codepoint = char.charCodeAt(0);

		if (chardata[codepoint] != null) {
			return chardata[codepoint];
		}
		else {
			return invalidCharData;
		}
	}

	this.allCharCodes = function() {
		var codeList = [];
		for (var code in chardata) {
			codeList.push(code);
		}
		return codeList;
	}

	function createCharData() {
		return { 
			width: width,
			height: height,
			offset: {
				x: 0,
				y: 0
			},
			spacing: width,
			data: [],
		};
	}

	function updateInvalidCharData() {
		invalidCharData = createCharData();
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				if (x < width-1 && y < height-1) {
					invalidCharData.data.push(1);
				}
				else {
					invalidCharData.data.push(0);
				}
			}
		}
	}

	function parseFont(fontData) {
		if (fontData == null) {
			return;
		}

		bitsy.log("split font lines");
		// NOTE: this is where we run out of memory - split creates a lot of memory issues
		// var lines = fontData.split("\n");
		bitsy.log("after split lines");

		var isReadingChar = false;
		var isReadingCharProperties = false;
		var curCharLineCount = 0;
		var curCharCode = 0;

		var lineStart = 0;
		var lineEnd = fontData.indexOf("\n", lineStart) != -1
			? fontData.indexOf("\n", lineStart)
			: fontData.length;

		// for (var i = 0; i < lines.length; i++) {
		// 	var line = lines[i];
		while (lineStart < fontData.length) {
			var line = fontData.substring(lineStart, lineEnd);
			// bitsy.log("parse font xx " + line);

			if (line[0] === "#") {
				// skip comment lines
			}
			else if (!isReadingChar) {
				// READING NON CHARACTER DATA LINE
				var args = line.split(" ");
				if (args[0] == "FONT") {
					name = args[1];
				}
				else if (args[0] == "SIZE") {
					width = parseInt(args[1]);
					height = parseInt(args[2]);
				}
				else if (args[0] == "CHAR") {
					isReadingChar = true;
					isReadingCharProperties = true;

					curCharLineCount = 0;
					curCharCode = parseInt(args[1]);
					chardata[curCharCode] = createCharData();
				}
			}
			else {
				// CHAR PROPERTIES
				if (isReadingCharProperties) {
					var args = line.split(" ");
					if (args[0].indexOf("CHAR_") == 0) { // Sub-properties start with "CHAR_"
						if (args[0] == "CHAR_SIZE") {
							// Custom character size - overrides the default character size for the font
							chardata[curCharCode].width = parseInt(args[1]);
							chardata[curCharCode].height = parseInt(args[2]);
							chardata[curCharCode].spacing = parseInt(args[1]); // HACK : assumes CHAR_SIZE is always declared first
						}
						else if (args[0] == "CHAR_OFFSET") {
							// Character offset - shift the origin of the character on the X or Y axis
							chardata[curCharCode].offset.x = parseInt(args[1]);
							chardata[curCharCode].offset.y = parseInt(args[2]);
						}
						else if (args[0] == "CHAR_SPACING") {
							// Character spacing:
							// specify total horizontal space taken up by the character
							// lets chars take up more or less space on a line than its bitmap does
							chardata[curCharCode].spacing = parseInt(args[1]);
						}
					}
					else {
						isReadingCharProperties = false;
					}
				}

				// CHAR DATA
				if (!isReadingCharProperties) {
					// READING CHARACTER DATA LINE
					for (var j = 0; j < chardata[curCharCode].width; j++)
					{
						chardata[curCharCode].data.push( parseInt(line[j]) );
					}

					curCharLineCount++;
					if (curCharLineCount >= chardata[curCharCode].height) {
						isReadingChar = false;
					}
				}
			}

			lineStart = lineEnd + 1;
			lineEnd = fontData.indexOf("\n", lineStart) != -1
				? fontData.indexOf("\n", lineStart)
				: fontData.length;
		}

		// re-init invalid character box at the actual font size once it's loaded
		updateInvalidCharData();
	}

	bitsy.log("parse font");
	parseFont(fontData);

	bitsy.log("create font");
}

} // FontManager

</script>

<script>
var TransitionManager = function() {
	var transitionStart = null;
	var transitionEnd = null;

	var isTransitioning = false;
	var transitionTime = 0; // milliseconds
	var minStepTime = 125; // cap the frame rate
	var curStep = 0;

	this.BeginTransition = function(startRoom, startX, startY, endRoom, endX, endY, effectName) {
		bitsy.log("--- START ROOM TRANSITION ---");

		curEffect = effectName;

		var tmpRoom = player().room;
		var tmpX = player().x;
		var tmpY = player().y;

		if (transitionEffects[curEffect].showPlayerStart) {
			player().room = startRoom;
			player().x = startX;
			player().y = startY;
		}
		else {
			player().room = "_transition_none"; // kind of hacky!!
		}

		var startRoomPixels = createRoomPixelBuffer(room[startRoom]);
		var startPalette = getPal(room[startRoom].pal);
		var startImage = new PostProcessImage(startRoomPixels);
		transitionStart = new TransitionInfo(startImage, startPalette, startX, startY);

		if (transitionEffects[curEffect].showPlayerEnd) {
			player().room = endRoom;
			player().x = endX;
			player().y = endY;
		}
		else {
			player().room = "_transition_none";
		}

		var endRoomPixels = createRoomPixelBuffer(room[endRoom]);
		var endPalette = getPal(room[endRoom].pal);
		var endImage = new PostProcessImage(endRoomPixels);
		transitionEnd = new TransitionInfo(endImage, endPalette, endX, endY);

		isTransitioning = true;
		transitionTime = 0;
		curStep = 0;

		player().room = endRoom;
		player().x = endX;
		player().y = endY;

		bitsy.graphicsMode(bitsy.GFX_VIDEO);
	}

	this.UpdateTransition = function(dt) {
		if (!isTransitioning) {
			return;
		}

		transitionTime += dt;

		var maxStep = transitionEffects[curEffect].stepCount;

		if (transitionTime >= minStepTime) {
			curStep++;

			var step = curStep;
			bitsy.log("transition step " + step);

			if (transitionEffects[curEffect].paletteEffectFunc) {
				var colors = transitionEffects[curEffect].paletteEffectFunc(transitionStart, transitionEnd, (step / maxStep));
				updatePaletteWithTileColors(colors);
			}

			bitsy.fill(bitsy.VIDEO, tileColorStartIndex);

			for (var y = 0; y < bitsy.VIDEO_SIZE; y++) {
				for (var x = 0; x < bitsy.VIDEO_SIZE; x++) {
					var color = transitionEffects[curEffect].pixelEffectFunc(transitionStart, transitionEnd, x, y, (step / maxStep));
					bitsy.set(bitsy.VIDEO, (y * bitsy.VIDEO_SIZE) + x, color);
				}
			}

			transitionTime = 0;
		}

		if (curStep >= (maxStep - 1)) {
			isTransitioning = false;
			transitionTime = 0;
			transitionStart = null;
			transitionEnd = null;
			curStep = 0;

			if (transitionCompleteCallback != null) {
				transitionCompleteCallback();
			}
			transitionCompleteCallback = null;

			bitsy.graphicsMode(bitsy.GFX_MAP);
		}
	}

	this.IsTransitionActive = function() {
		return isTransitioning;
	}

	// todo : should this be part of the constructor?
	var transitionCompleteCallback = null;
	this.OnTransitionComplete = function(callback) {
		if (isTransitioning) { // TODO : safety check necessary?
			transitionCompleteCallback = callback;
		}
	}

	var transitionEffects = {};
	var curEffect = "none";
	this.RegisterTransitionEffect = function(name, effect) {
		transitionEffects[name] = effect;
	}

	this.RegisterTransitionEffect("none", {
		showPlayerStart : false,
		showPlayerEnd : false,
		paletteEffectFunc : function() {},
		pixelEffectFunc : function() {},
	});

	this.RegisterTransitionEffect("fade_w", { // TODO : have it linger on full white briefly?
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [255, 255, 255], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([255, 255, 255], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("fade_b", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 6,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			return delta < 0.5 ? start.Image.GetPixel(pixelX, pixelY) : end.Image.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			var colors = [];

			if (delta < 0.5) {
				delta = delta / 0.5;

				for (var i = 0; i < start.Palette.length; i++) {
					colors.push(lerpColor(start.Palette[i], [0, 0, 0], delta));
				}
			}
			else {
				delta = ((delta - 0.5) / 0.5);

				for (var i = 0; i < end.Palette.length; i++) {
					colors.push(lerpColor([0, 0, 0], end.Palette[i], delta));
				}
			}

			return colors;
		},
	});

	this.RegisterTransitionEffect("wave", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var waveDelta = delta < 0.5 ? delta / 0.5 : 1 - ((delta - 0.5) / 0.5);

			var offset = (pixelY + (waveDelta * waveDelta * 0.2 * start.Image.Height));
			var freq = 4;
			var size = 2 + (14 * waveDelta);
			pixelX += Math.floor(Math.sin(offset / freq) * size);

			if (pixelX < 0) {
				pixelX += start.Image.Width;
			}
			else if (pixelX >= start.Image.Width) {
				pixelX -= start.Image.Width;
			}

			var curImage = delta < 0.5 ? start.Image : end.Image;
			return curImage.GetPixel(pixelX, pixelY);
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	this.RegisterTransitionEffect("tunnel", {
		showPlayerStart : true,
		showPlayerEnd : true,
		stepCount : 12,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			if (delta <= 0.4) {
				var tunnelDelta = 1 - (delta / 0.4);

				var xDist = start.PlayerCenter.x - pixelX;
				var yDist = start.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > start.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return start.Image.GetPixel(pixelX, pixelY);
				}
			}
			else if (delta <= 0.6) {
				return 0;
			}
			else {
				var tunnelDelta = (delta - 0.6) / 0.4;

				var xDist = end.PlayerCenter.x - pixelX;
				var yDist = end.PlayerCenter.y - pixelY;
				var dist = Math.sqrt((xDist * xDist) + (yDist * yDist));

				if (dist > end.Image.Width * tunnelDelta) {
					return 0;
				}
				else {
					return end.Image.GetPixel(pixelX, pixelY);
				}
			}
		},
		paletteEffectFunc : function(start, end, delta) {
			return delta < 0.5 ? start.Palette : end.Palette;
		},
	});

	function lerpPalettes(start, end, delta) {
		var colors = [];

		var maxLength = (start.Palette.length > end.Palette.length) ?
			start.Palette.length : end.Palette.length;

		for (var i = 0; i < maxLength; i++) {
			if (i < start.Palette.length && i < end.Palette.length) {
				colors.push(lerpColor(start.Palette[i], end.Palette[i], delta));
			}
			else if (i < start.Palette.length) {
				colors.push(lerpColor(
					start.Palette[i],
					end.Palette[end.Palette.length - 1],
					delta));
			}
			else if (i < end.Palette.length) {
				colors.push(lerpColor(
					start.Palette[start.Palette.length - 1],
					end.Palette[i],
					delta));
			}
		}

		return colors;
	}

	this.RegisterTransitionEffect("slide_u", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY >= 0) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY += start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_d", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Height * delta);
			var slidePixelY = pixelY + pixelOffset;

			if (slidePixelY < start.Image.Height) {
				return start.Image.GetPixel(pixelX, slidePixelY);
			}
			else {
				slidePixelY -= start.Image.Height;
				return end.Image.GetPixel(pixelX, slidePixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_l", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = -1 * Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX >= 0) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX += start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	this.RegisterTransitionEffect("slide_r", {
		showPlayerStart : false,
		showPlayerEnd : true,
		stepCount : 8,
		pixelEffectFunc : function(start, end, pixelX, pixelY, delta) {
			var pixelOffset = Math.floor(start.Image.Width * delta);
			var slidePixelX = pixelX + pixelOffset;

			if (slidePixelX < start.Image.Width) {
				return start.Image.GetPixel(slidePixelX, pixelY);
			}
			else {
				slidePixelX -= start.Image.Width;
				return end.Image.GetPixel(slidePixelX, pixelY);
			}
		},
		paletteEffectFunc : lerpPalettes,
	});

	// todo : move to Renderer()?
	function createRoomPixelBuffer(room) {
		var pixelBuffer = [];

		for (var i = 0; i < bitsy.VIDEO_SIZE * bitsy.VIDEO_SIZE; i++) {
			pixelBuffer.push(tileColorStartIndex);
		}

		var drawTileInPixelBuffer = function(sourceData, frameIndex, colorIndex, tx, ty, pixelBuffer) {
			var frameData = sourceData[frameIndex];

			for (var y = 0; y < bitsy.TILE_SIZE; y++) {
				for (var x = 0; x < bitsy.TILE_SIZE; x++) {
					var color = tileColorStartIndex + (frameData[y][x] === 1 ? colorIndex : 0);
					pixelBuffer[(((ty * bitsy.TILE_SIZE) + y) * bitsy.VIDEO_SIZE) + ((tx * bitsy.TILE_SIZE) + x)] = color;
				}
			}
		}

		//draw tiles
		for (i in room.tilemap) {
			for (j in room.tilemap[i]) {
				var id = room.tilemap[i][j];
				var x = parseInt(j);
				var y = parseInt(i);

				if (id != "0" && tile[id] != null) {
					drawTileInPixelBuffer(
						renderer.GetDrawingSource(tile[id].drw),
						tile[id].animation.frameIndex,
						tile[id].col,
						x,
						y,
						pixelBuffer);
				}
			}
		}

		//draw items
		for (var i = 0; i < room.items.length; i++) {
			var itm = room.items[i];
			drawTileInPixelBuffer(
				renderer.GetDrawingSource(item[itm.id].drw),
				item[itm.id].animation.frameIndex,
				item[itm.id].col,
				itm.x,
				itm.y,
				pixelBuffer);
		}

		//draw sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.room === room.id) {
				drawTileInPixelBuffer(
					renderer.GetDrawingSource(spr.drw),
					spr.animation.frameIndex,
					spr.col,
					spr.x,
					spr.y,
					pixelBuffer);
			}
		}

		return pixelBuffer;
	}

	function lerpColor(colorA, colorB, t) {
		return [
			colorA[0] + ((colorB[0] - colorA[0]) * t),
			colorA[1] + ((colorB[1] - colorA[1]) * t),
			colorA[2] + ((colorB[2] - colorA[2]) * t),
		];
	};
}; // TransitionManager()

// todo : is this wrapper still useful?
var PostProcessImage = function(imageData) {
	this.Width = bitsy.VIDEO_SIZE;
	this.Height = bitsy.VIDEO_SIZE;

	this.GetPixel = function(x, y) {
		return imageData[(y * bitsy.VIDEO_SIZE) + x];
	};

	this.GetData = function() {
		return imageData;
	};
};

var TransitionInfo = function(image, palette, playerX, playerY) {
	this.Image = image;

	this.Palette = palette;

	this.PlayerTilePos = {
		x: playerX,
		y: playerY
	};

	this.PlayerCenter = {
		x: Math.floor((playerX * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2)),
		y: Math.floor((playerY * bitsy.TILE_SIZE) + (bitsy.TILE_SIZE / 2))
	};
};
</script>

<script>
function Script() {

this.CreateInterpreter = function() {
	return new Interpreter();
};

this.CreateUtils = function() {
	return new Utils();
};

var Interpreter = function() {
	var env = new Environment();
	var parser = new Parser( env );

	this.SetDialogBuffer = function(buffer) { env.SetDialogBuffer( buffer ); };

	// TODO -- maybe this should return a string instead othe actual script??
	this.Compile = function(scriptName, scriptStr) {
		var script = parser.Parse(scriptStr, scriptName);
		env.SetScript(scriptName, script);
	}
	this.Run = function(scriptName, exitHandler, objectContext) { // Runs pre-compiled script
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = env.GetScript(scriptName);

		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.Interpret = function(scriptStr, exitHandler, objectContext) { // Compiles and runs code immediately
		// bitsy.log("INTERPRET");
		var localEnv = new LocalEnvironment(env);

		if (objectContext) {
			localEnv.SetObject(objectContext); // PROTO : should this be folded into the constructor?
		}

		var script = parser.Parse(scriptStr, "anonymous");
		script.Eval( localEnv, function(result) { OnScriptReturn(localEnv, exitHandler); } );
	}
	this.HasScript = function(name) { return env.HasScript(name); };

	this.ResetEnvironment = function() {
		env = new Environment();
		parser = new Parser( env );
	}

	this.Parse = function(scriptStr, rootId) { // parses a script but doesn't save it
		return parser.Parse(scriptStr, rootId);
	}

	this.Eval = function(scriptTree, exitHandler) { // runs a script stored externally
		var localEnv = new LocalEnvironment(env); // TODO : does this need an object context?
		scriptTree.Eval(
			localEnv,
			function(result) {
				OnScriptReturn(result, exitHandler);
			});
	}

	function OnScriptReturn(result, exitHandler) {
		if (exitHandler != null) {
			exitHandler(result);
		}
	}

	this.CreateExpression = function(expStr) {
		return parser.CreateExpression(expStr);
	}

	this.SetVariable = function(name,value,useHandler) {
		env.SetVariable(name,value,useHandler);
	}

	this.DeleteVariable = function(name,useHandler) {
		env.DeleteVariable(name,useHandler);
	}
	this.HasVariable = function(name) {
		return env.HasVariable(name);
	}

	this.SetOnVariableChangeHandler = function(onVariableChange) {
		env.SetOnVariableChangeHandler(onVariableChange);
	}
	this.GetVariableNames = function() {
		return env.GetVariableNames();
	}
	this.GetVariable = function(name) {
		return env.GetVariable(name);
	}

	function DebugVisualizeScriptTree(scriptTree) {
		var printVisitor = {
			Visit : function(node,depth) {
				bitsy.log("-".repeat(depth) + "- " + node.ToString());
			},
		};

		scriptTree.VisitAll( printVisitor );
	}

	this.DebugVisualizeScriptTree = DebugVisualizeScriptTree;

	this.DebugVisualizeScript = function(scriptName) {
		DebugVisualizeScriptTree(env.GetScript(scriptName));
	}
}


var Utils = function() {
	// for editor ui
	this.CreateDialogBlock = function(children,doIndentFirstLine) {
		if (doIndentFirstLine === undefined) {
			doIndentFirstLine = true;
		}

		var block = new DialogBlockNode(doIndentFirstLine);

		for (var i = 0; i < children.length; i++) {
			block.AddChild(children[i]);
		}
		return block;
	}

	this.CreateOptionBlock = function() {
		var block = new DialogBlockNode(false);
		block.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		return block;
	}

	this.CreateItemConditionPair = function() {
		var itemFunc = this.CreateFunctionBlock("item", ["0"]);
		var condition = new ExpNode("==", itemFunc, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateVariableConditionPair = function() {
		var varNode = this.CreateVariableNode("a");
		var condition = new ExpNode("==", varNode, new LiteralNode(1));
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateDefaultConditionPair = function() {
		var condition = this.CreateElseNode();
		var result = new DialogBlockNode(true);
		result.AddChild(new FuncNode("say", [new LiteralNode(" ")]));
		var conditionPair = new ConditionPairNode(condition, result);
		return conditionPair;
	}

	this.CreateEmptySayFunc = function() {
		return new FuncNode("say", [new LiteralNode("...")]);
	}

	this.CreateFunctionBlock = function(name, initParamValues) {
		var parameters = [];
		for (var i = 0; i < initParamValues.length; i++) {
			parameters.push(new LiteralNode(initParamValues[i]));
		}

		var node = new FuncNode(name, parameters);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	// TODO : rename ParseStringToLiteralNode?
	this.CreateLiteralNode = function(str) {
		if (str === "true") {
			return new LiteralNode(true);
		}
		else if (str === "false") {
			return new LiteralNode(false);
		}
		else if (!isNaN(parseFloat(str))) {
			return new LiteralNode(parseFloat(str));
		}
		else {
			return new LiteralNode(str);
		}
	}

	this.CreateVariableNode = function(variableName) {
		return new VarNode(variableName);
	}

	this.CreatePropertyNode = function(propertyName, literalValue) {
		var varNode = new VarNode(propertyName);
		var valNode = new LiteralNode(literalValue);
		var node = new FuncNode("property", [varNode, valNode]);
		var block = new CodeBlockNode();
		block.AddChild(node);
		return block;
	}

	this.CreateElseNode = function() {
		return new ElseNode();
	}

	this.CreateStringLiteralNode = function(str) {
		return new LiteralNode(str);
	}

	// TODO : need to split up code & dialog blocks :|
	this.CreateCodeBlock = function() {
		return new CodeBlockNode();
	}

	this.ChangeSequenceType = function(oldSequence, type) {
		if(type === "sequence") {
			return new SequenceNode(oldSequence.children);
		}
		else if(type === "cycle") {
			return new CycleNode(oldSequence.children);
		}
		else if(type === "shuffle") {
			return new ShuffleNode(oldSequence.children);
		}
		return oldSequence;
	}

	this.CreateSequenceBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new SequenceNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateCycleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new CycleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateShuffleBlock = function() {
		var option1 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var option2 = new DialogBlockNode( false /*doIndentFirstLine*/ );
		option2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var sequence = new ShuffleNode( [ option1, option2 ] );
		var block = new CodeBlockNode();
		block.AddChild( sequence );
		return block;
	}

	this.CreateIfBlock = function() {
		var leftNode = new CodeBlockNode();
		leftNode.AddChild( new FuncNode("item", [new LiteralNode("0")] ) );
		var rightNode = new LiteralNode( 1 );
		var condition1 = new ExpNode("==", leftNode, rightNode );

		var condition2 = new ElseNode();

		var result1 = new DialogBlockNode();
		result1.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var result2 = new DialogBlockNode();
		result2.AddChild(new FuncNode("say", [new LiteralNode("...")]));

		var ifNode = new IfNode( [ condition1, condition2 ], [ result1, result2 ] );
		var block = new CodeBlockNode();
		block.AddChild( ifNode );
		return block;
	}

	this.ReadDialogScript = function(lines, i) {
		var scriptStr = "";
		if (lines[i] === Sym.DialogOpen) {
			scriptStr += lines[i] + "\n";
			i++;
			while(lines[i] != Sym.DialogClose) {
				scriptStr += lines[i] + "\n";
				i++;
			}
			scriptStr += lines[i];
			i++;
		}
		else {
			scriptStr += lines[i];
			i++;
		}
		return { script:scriptStr, index:i };
	}

	// TODO this.ReadCodeScript (reads through code open and close symbols), and this.ReadScript

	this.EnsureDialogBlockFormat = function(dialogStr) {
		// TODO -- what if it's already enclosed in dialog symbols??
		if(dialogStr.indexOf('\n') > -1) {
			dialogStr = Sym.DialogOpen + "\n" + dialogStr + "\n" + Sym.DialogClose;
		}
		return dialogStr;
	}

	this.RemoveDialogBlockFormat = function(source) {
		var sourceLines = source.split("\n");
		var dialogStr = "";
		if(sourceLines[0] === Sym.DialogOpen) {
			// multi line
			var i = 1;
			while (i < sourceLines.length && sourceLines[i] != Sym.DialogClose) {
				dialogStr += sourceLines[i] + (sourceLines[i+1] != Sym.DialogClose ? '\n' : '');
				i++;
			}
		}
		else {
			// single line
			dialogStr = source;
		}
		return dialogStr;
	}

	this.SerializeDialogNodeList = function(nodeList) {
		var tempBlock = new DialogBlockNode(false);
		 // set children directly to avoid breaking the parenting chain for this temp operation
		tempBlock.children = nodeList;
		return tempBlock.Serialize();
	}

	this.GetOperatorList = function() {
		return [Sym.Set].concat(Sym.Operators);
	}

	this.IsInlineCode = function(node) {
		return isInlineCode(node);
	}
}


/* BUILT-IN FUNCTIONS */ // TODO: better way to encapsulate these?
function deprecatedFunc(environment,parameters,onReturn) {
	bitsy.log("BITSY SCRIPT WARNING: Tried to use deprecated function");
	onReturn(null);
}

function sayFunc(environment, parameters, onReturn) {
	if (parameters[0] != undefined && parameters[0] != null) {
		var textStr = "" + parameters[0];
		environment.GetDialogBuffer().AddText(textStr);
		environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
	}
	else {
		onReturn(null);
	}
}

function linebreakFunc(environment, parameters, onReturn) {
	// bitsy.log("LINEBREAK FUNC");
	environment.GetDialogBuffer().AddLinebreak();
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function pagebreakFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().AddPagebreak(function() { onReturn(null); });
}

function drawFunc(environment, parameters, onReturn) {
	var drawingId = parameters[0];
	environment.GetDialogBuffer().AddDrawing(drawingId);
	environment.GetDialogBuffer().AddScriptReturn(function() { onReturn(null); });
}

function drawSpriteFunc(environment, parameters, onReturn) {
	var spriteId = parameters[0];

	// check if id parameter is actually a name
	if (names.sprite[spriteId] != undefined) {
		spriteId = names.sprite[spriteId];
	}

	var drawingId = sprite[spriteId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function drawTileFunc(environment, parameters, onReturn) {
	var tileId = parameters[0];

	// check if id parameter is actually a name
	if (names.tile[tileId] != undefined) {
		tileId = names.tile[tileId];
	}

	var drawingId = tile[tileId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function drawItemFunc(environment, parameters, onReturn) {
	var itemId = parameters[0];

	// check if id parameter is actually a name
	if (names.item[itemId] != undefined) {
		itemId = names.item[itemId];
	}

	var drawingId = item[itemId].drw;
	drawFunc(environment, [drawingId], onReturn);
}

function printFontFunc(environment, parameters, onReturn) {
	var allCharacters = "";
	var font = fontManager.Get(fontName);
	var codeList = font.allCharCodes();
	for (var i = 0; i < codeList.length; i++) {
		allCharacters += String.fromCharCode(codeList[i]) + " ";
	}
	sayFunc(environment, [allCharacters], onReturn);
}

function itemFunc(environment,parameters,onReturn) {
	var itemId = parameters[0];

	if (names.item[itemId] != undefined) {
		// id is actually a name
		itemId = names.item[itemId];
	}

	var curItemCount = player().inventory[itemId] ? player().inventory[itemId] : 0;

	if (parameters.length > 1) {
		// TODO : is it a good idea to force inventory to be >= 0?
		player().inventory[itemId] = Math.max(0, parseInt(parameters[1]));
		curItemCount = player().inventory[itemId];

		if (onInventoryChanged != null) {
			onInventoryChanged(itemId);
		}
	}

	onReturn(curItemCount);
}

function toggleTextEffect(environment, name) {
	if (environment.GetDialogBuffer().hasTextEffect(name)) {
		environment.GetDialogBuffer().popTextEffect(name);
	}
	else {
		environment.GetDialogBuffer().pushTextEffect(name, []);
	}
}

function color1Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr1");
	onReturn(null);
}

function color2Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr2");
	onReturn(null);
}

function color3Func(environment, parameters, onReturn) {
	toggleTextEffect(environment, "clr3");
	onReturn(null);
}

function colorFunc(environment, parameters, onReturn) {
	environment.GetDialogBuffer().pushTextEffect("clr", parameters);
	onReturn(null);
}

function colorPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("clr")) {
		environment.GetDialogBuffer().popTextEffect("clr");
	}
	onReturn(null);
}

function rainbowFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "rbw");
	onReturn(null);
}

function rainbowPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("rbw")) {
		environment.GetDialogBuffer().popTextEffect("rbw");
	}
	onReturn(null);
}

function wavyFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "wvy");
	onReturn(null);
}

function wavyPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("wvy")) {
		environment.GetDialogBuffer().popTextEffect("wvy");
	}
	onReturn(null);
}

function shakyFunc(environment, parameters, onReturn) {
	toggleTextEffect(environment, "shk");
	onReturn(null);
}

function shakyPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("shk")) {
		environment.GetDialogBuffer().popTextEffect("shk");
	}
	onReturn(null);
}

function propertyFunc(environment, parameters, onReturn) {
	var outValue = null;

	if (parameters.length > 0 && parameters[0]) {
		var propertyName = parameters[0];

		if (environment.HasProperty(propertyName)) {
			// TODO : in a future update I can handle the case of initializing a new property
			// after which we can move this block outside the HasProperty check
			if (parameters.length > 1) {
				var inValue = parameters[1];
				environment.SetProperty(propertyName, inValue);
			}

			outValue = environment.GetProperty(propertyName);
		}
	}

	bitsy.log("PROPERTY! " + propertyName + " " + outValue);

	onReturn(outValue);
}

function endFunc(environment,parameters,onReturn) {
	isEnding = true;
	isNarrating = true;
	dialogRenderer.SetCentered(true);
	dialogRenderer.DrawTextbox();
	onReturn(null);
}

function exitFunc(environment, parameters, onReturn) {
	var destRoom;
	var destX;
	var destY;

	if (parameters.length >= 1) {
		destRoom = parameters[0];

		// is it a name?
		if (names.room[destRoom] != undefined) {
			destRoom = names.room[destRoom];
		}
	}

	if (parameters.length >= 3) {
		destX = parseInt(parameters[1]);
		destY = parseInt(parameters[2]);
	}

	if (parameters.length >= 4) {
		var transitionEffect = parameters[3];

		transition.BeginTransition(
			player().room,
			player().x,
			player().y,
			destRoom,
			destX,
			destY,
			transitionEffect);
		transition.UpdateTransition(0);
	}

	var movePlayerAndResumeScript = function() {
		if (destRoom != undefined && destX != undefined && destY != undefined) {
			// update world state
			player().room = destRoom;
			player().x = destX;
			player().y = destY;
			state.room = destRoom;

			// update game state
			initRoom(state.room);
		}

		if (dialogRenderer) {
			dialogRenderer.updateTextboxPosition();
		}

		// resume dialog script
		onReturn(state.room);
	};

	// TODO : this doesn't play nice with pagebreak because it thinks the dialog is finished!
	if (transition.IsTransitionActive()) {
		transition.OnTransitionComplete(movePlayerAndResumeScript);
	}
	else {
		movePlayerAndResumeScript();
	}
}

function tuneFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var tuneId = parameters[0];

		// check if id parameter is actually a name
		if (names.tune[tuneId] != undefined) {
			tuneId = names.tune[tuneId];
		}

		if (soundPlayer) {
			if (tuneId === "0") {
				soundPlayer.stopTune();
			}
			else if (state.tune != tuneId) {
				soundPlayer.playTune(tune[tuneId]);
			}
		}

		state.tune = tuneId;
	}

	onReturn(state.tune);
}

function blipFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var blipId = parameters[0];

		// check if id parameter is actually a name
		if (names.blip[blipId] != undefined) {
			blipId = names.blip[blipId];
		}

		soundPlayer.playBlip(blip[blipId]);
	}

	// if a dialog skip is happening, stop it and force a redraw of the textbox
	if (dialogBuffer) {
		if (dialogBuffer.tryInterruptSkip()) {
			dialogRenderer.Draw(dialogBuffer, 0, true /* disableOnPrint */);
		}
	}

	onReturn(null);
}

/*
// TODO : use later?
function yakFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var blipId = parameters[0];

		// check if id parameter is actually a name
		if (names.blip[blipId] != undefined) {
			blipId = names.blip[blipId];
		}

		environment.GetDialogBuffer().pushTextEffect("yak", [blipId]);
	}

	onReturn(null);
}

function yakPopFunc(environment, parameters, onReturn) {
	if (environment.GetDialogBuffer().hasTextEffect("yak")) {
		environment.GetDialogBuffer().popTextEffect("yak");
	}

	onReturn(null);
}
*/

function paletteFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var palId = parameters[0];

		// check if id parameter is actually a name
		if (names.palette[palId] != undefined) {
			palId = names.palette[palId];
		}

		updatePalette(palId);
	}

	onReturn(state.pal);
}

function avatarFunc(environment, parameters, onReturn) {
	if (parameters.length > 0) {
		var sprId = parameters[0];

		// check if id parameter is actually a name
		if (names.sprite[sprId] != undefined) {
			sprId = names.sprite[sprId];
		}

		// override the avatar's current appearance
		state.ava = sprId;

		// redraw the avatar with its new appearance
		drawRoom(room[state.room], { redrawAvatar: true });
	}

	onReturn(state.ava);
}

/* BUILT-IN OPERATORS */
function setExp(environment,left,right,onReturn) {
	// bitsy.log("SET " + left.name);

	if(left.type != "variable") {
		// not a variable! return null and hope for the best D:
		onReturn( null );
		return;
	}

	right.Eval(environment,function(rVal) {
		environment.SetVariable( left.name, rVal );
		// bitsy.log("VAL " + environment.GetVariable( left.name ) );
		left.Eval(environment,function(lVal) {
			onReturn( lVal );
		});
	});
}
function equalExp(environment,left,right,onReturn) {
	// bitsy.log("EVAL EQUAL");
	// bitsy.log(left);
	// bitsy.log(right);
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal === rVal );
		});
	});
}
function greaterExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal > rVal );
		});
	});
}
function lessExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal < rVal );
		});
	});
}
function greaterEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal >= rVal );
		});
	});
}
function lessEqExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal <= rVal );
		});
	});
}
function multExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal * rVal );
		});
	});
}
function divExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal / rVal );
		});
	});
}
function addExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal + rVal );
		});
	});
}
function subExp(environment,left,right,onReturn) {
	right.Eval(environment,function(rVal){
		left.Eval(environment,function(lVal){
			onReturn( lVal - rVal );
		});
	});
}

/* ENVIRONMENT */
var Environment = function() {
	var dialogBuffer = null;
	this.SetDialogBuffer = function(buffer) { dialogBuffer = buffer; };
	this.GetDialogBuffer = function() { return dialogBuffer; };

	var functionMap = {};

	// dialog
	functionMap["say"] = sayFunc;
	functionMap["br"] = linebreakFunc;
	functionMap["pg"] = pagebreakFunc;

	// text effects
	functionMap["wvy"] = wavyFunc;
	functionMap["/wvy"] = wavyPopFunc;
	functionMap["shk"] = shakyFunc;
	functionMap["/shk"] = shakyPopFunc;
	functionMap["rbw"] = rainbowFunc;
	functionMap["/rbw"] = rainbowPopFunc;
	functionMap["clr"] = colorFunc;
	functionMap["/clr"] = colorPopFunc;
	// drawing text effects
	functionMap["drwt"] = drawTileFunc;
	functionMap["drws"] = drawSpriteFunc;
	functionMap["drwi"] = drawItemFunc;

	// room
	functionMap["end"] = endFunc;
	functionMap["exit"] = exitFunc;
	functionMap["pal"] = paletteFunc;
	functionMap["ava"] = avatarFunc;

	// inventory & variables
	functionMap["item"] = itemFunc;
	functionMap["property"] = propertyFunc;

	// sound
	functionMap["tune"] = tuneFunc;
	functionMap["blip"] = blipFunc;

	// legacy
	functionMap["clr1"] = color1Func;
	functionMap["clr2"] = color2Func;
	functionMap["clr3"] = color3Func;
	functionMap["print"] = sayFunc;
	functionMap["printTile"] = drawTileFunc;
	functionMap["printSprite"] = drawSpriteFunc;
	functionMap["printItem"] = drawItemFunc;

	// DEBUG
	functionMap["_debugOnlyPrintFont"] = printFontFunc;

	// EXPERIMENTAL
	// functionMap["yak"] = yakFunc;
	// functionMap["/yak"] = yakPopFunc;

	this.HasFunction = function(name) { return functionMap[name] != undefined; };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		functionMap[name](env, parameters, onReturn);
	}

	var variableMap = {};

	this.HasVariable = function(name) { return variableMap[name] != undefined; };
	this.GetVariable = function(name) { return variableMap[name]; };
	this.SetVariable = function(name,value,useHandler) {
		// bitsy.log("SET VARIABLE " + name + " = " + value);
		if(useHandler === undefined) useHandler = true;
		variableMap[name] = value;
		if(onVariableChangeHandler != null && useHandler){
			onVariableChangeHandler(name);
		}
	};
	this.DeleteVariable = function(name,useHandler) {
		if(useHandler === undefined) useHandler = true;
		if(variableMap[name] != undefined) {
			variableMap.delete(name);
			if(onVariableChangeHandler != null && useHandler) {
				onVariableChangeHandler(name);
			}
		}
	};

	var operatorMap = {};
	operatorMap["="] = setExp;
	operatorMap["=="] = equalExp;
	operatorMap[">"] = greaterExp;
	operatorMap["<"] = lessExp;
	operatorMap[">="] = greaterEqExp;
	operatorMap["<="] = lessEqExp;
	operatorMap["*"] = multExp;
	operatorMap["/"] = divExp;
	operatorMap["+"] = addExp;
	operatorMap["-"] = subExp;

	this.HasOperator = function(sym) { return operatorMap[sym] != undefined; };
	this.EvalOperator = function(sym,left,right,onReturn) {
		operatorMap[ sym ]( this, left, right, onReturn );
	}

	var scriptMap = {};
	this.HasScript = function(name) { return scriptMap[name] != undefined; };
	this.GetScript = function(name) { return scriptMap[name]; };
	this.SetScript = function(name,script) { scriptMap[name] = script; };

	var onVariableChangeHandler = null;
	this.SetOnVariableChangeHandler = function(onVariableChange) {
		onVariableChangeHandler = onVariableChange;
	}
	this.GetVariableNames = function() {
		var variableNames = [];

		for (var key in variableMap) {
			variableNames.push(key);
		}

		return variableNames;
	}
}

// Local environment for a single run of a script: knows local context
var LocalEnvironment = function(parentEnvironment) {
	// this.SetDialogBuffer // not allowed in local environment?
	this.GetDialogBuffer = function() { return parentEnvironment.GetDialogBuffer(); };

	this.HasFunction = function(name) { return parentEnvironment.HasFunction(name); };
	this.EvalFunction = function(name,parameters,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalFunction(name,parameters,onReturn,env);
	}

	this.HasVariable = function(name) { return parentEnvironment.HasVariable(name); };
	this.GetVariable = function(name) { return parentEnvironment.GetVariable(name); };
	this.SetVariable = function(name,value,useHandler) { parentEnvironment.SetVariable(name,value,useHandler); };
	// this.DeleteVariable // not needed in local environment?

	this.HasOperator = function(sym) { return parentEnvironment.HasOperator(sym); };
	this.EvalOperator = function(sym,left,right,onReturn,env) {
		if (env == undefined || env == null) {
			env = this;
		}

		parentEnvironment.EvalOperator(sym,left,right,onReturn,env);
	};

	// TODO : I don't *think* any of this is required by the local environment
	// this.HasScript
	// this.GetScript
	// this.SetScript

	// TODO : pretty sure these debug methods aren't required by the local environment either
	// this.SetOnVariableChangeHandler
	// this.GetVariableNames

	/* Here's where specific local context data goes:
	 * this includes access to the object running the script
	 * and any properties it may have (so far only "locked")
	 */

	// The local environment knows what object called it -- currently only used to access properties
	var curObject = null;
	this.HasObject = function() { return curObject != undefined && curObject != null; }
	this.SetObject = function(object) { curObject = object; }
	this.GetObject = function() { return curObject; }

	// accessors for properties of the object that's running the script
	this.HasProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return true;
		}
		else {
			return false;
		}
	};
	this.GetProperty = function(name) {
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			return curObject.property[name]; // TODO : should these be getters and setters instead?
		}
		else {
			return null;
		}
	};
	this.SetProperty = function(name, value) {
		// NOTE : for now, we need to gaurd against creating new properties
		if (curObject && curObject.property && curObject.property.hasOwnProperty(name)) {
			curObject.property[name] = value;
		}
	};
}

function leadingWhitespace(depth) {
	var str = "";
	for(var i = 0; i < depth; i++) {
		str += "  "; // two spaces per indent
	}
	// bitsy.log("WHITESPACE " + depth + " ::" + str + "::");
	return str;
}

/* NODES */
var TreeRelationship = function() {
	this.parent = null;
	this.children = [];

	this.AddChild = function(node) {
		this.children.push(node);
		node.parent = this;
	};

	this.AddChildren = function(nodeList) {
		for (var i = 0; i < nodeList.length; i++) {
			this.AddChild(nodeList[i]);
		}
	};

	this.SetChildren = function(nodeList) {
		this.children = [];
		this.AddChildren(nodeList);
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.rootId = null; // for debugging
	this.GetId = function() {
		// bitsy.log(this);
		if (this.rootId != null) {
			return this.rootId;
		}
		else if (this.parent != null) {
			var parentId = this.parent.GetId();
			if (parentId != null) {
				return parentId + "_" + this.parent.children.indexOf(this);
			}
		}
		else {
			return null;
		}
	}
}

function DialogBlockNode(doIndentFirstLine) {
	TreeRelationship.call(this);

	this.type = "dialog_block";

	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsy.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsy.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	if (doIndentFirstLine === undefined) {
		doIndentFirstLine = true; // This is just for serialization
	}

	this.Serialize = function(depth) {
		if (depth === undefined) {
			depth = 0;
		}

		var str = "";
		var lastNode = null;

		for (var i = 0; i < this.children.length; i++) {

			var curNode = this.children[i];

			var shouldIndentFirstLine = (i == 0 && doIndentFirstLine);
			var shouldIndentAfterLinebreak = (lastNode && lastNode.type === "function" && lastNode.name === "br");

			if (shouldIndentFirstLine || shouldIndentAfterLinebreak) {
				str += leadingWhitespace(depth);
			}

			str += curNode.Serialize(depth);

			lastNode = curNode;
		}

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function CodeBlockNode() {
	TreeRelationship.call(this);

	this.type = "code_block";

	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL BLOCK " + this.children.length);

		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var lastVal = null;
		var i = 0;

		function evalChildren(children, done) {
			if (i < children.length) {
				// bitsy.log(">> CHILD " + i);
				children[i].Eval(environment, function(val) {
					// bitsy.log("<< CHILD " + i);
					lastVal = val;
					i++;
					evalChildren(children,done);
				});
			}
			else {
				done();
			}
		};

		var self = this;
		evalChildren(this.children, function() {
			if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
				events.Raise("script_node_exit", { id: self.GetId() });
			}

			onReturn(lastVal);
		});
	}

	this.Serialize = function(depth) {
		if(depth === undefined) {
			depth = 0;
		}

		// bitsy.log("SERIALIZE BLOCK!!!");
		// bitsy.log(depth);
		// bitsy.log(doIndentFirstLine);

		var str = "{"; // todo: increase scope of Sym?

		// TODO : do code blocks ever have more than one child anymore????
		for (var i = 0; i < this.children.length; i++) {
			var curNode = this.children[i];
			str += curNode.Serialize(depth);
		}

		str += "}";

		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function isInlineCode(node) {
	return isTextEffectBlock(node) || isUndefinedBlock(node) || isMultilineListBlock(node);
}

function isUndefinedBlock(node) {
	return node.type === "code_block" && node.children.length > 0 && node.children[0].type === "undefined";
}

var textEffectBlockNames = ["clr1", "clr2", "clr3", "wvy", "shk", "rbw", "printSprite", "printItem", "printTile", "print", "say", "br"];
function isTextEffectBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0 && node.children[0].type === "function") {
			var func = node.children[0];
			return textEffectBlockNames.indexOf(func.name) != -1;
		}
	}
	return false;
}

var listBlockTypes = ["sequence", "cycle", "shuffle", "if"];
function isMultilineListBlock(node) {
	if (node.type === "code_block") {
		if (node.children.length > 0) {
			var child = node.children[0];
			return listBlockTypes.indexOf(child.type) != -1;
		}
	}
	return false;
}

// for round-tripping undefined code through the parser (useful for hacks!)
function UndefinedNode(sourceStr) {
	TreeRelationship.call(this);

	this.type = "undefined";
	this.source = sourceStr;

	this.Eval = function(environment,onReturn) {
		toggleTextEffect(environment, "_debug_highlight");
		sayFunc(environment, ["{" + sourceStr + "}"], function() {
			onReturn(null);
		});
		toggleTextEffect(environment, "_debug_highlight");
	}

	this.Serialize = function(depth) {
		return this.source;
	}

	this.ToString = function() {
		return "undefined" + " " + this.GetId();
	}
}

function FuncNode(name, args) {
	TreeRelationship.call(this);

	this.type = "function";
	this.name = name;
	this.args = args;

	this.Eval = function(environment,onReturn) {
		if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
			events.Raise("script_node_enter", { id: this.GetId() });
		}

		var self = this; // hack to deal with scope (TODO : move up higher?)

		var argumentValues = [];
		var i = 0;

		function evalArgs(args, done) {
			// TODO : really hacky way to make we get the first
			// symbol's NAME instead of its variable value
			// if we are trying to do something with a property
			if (self.name === "property" && i === 0 && i < args.length) {
				if (args[i].type === "variable") {
					argumentValues.push(args[i].name);
					i++;
				}
				else {
					// first argument for a property MUST be a variable symbol
					// -- so skip everything if it's not!
					i = args.length;
				}
			}

			if (i < args.length) {
				// Evaluate each argument
				args[i].Eval(
					environment,
					function(val) {
						argumentValues.push(val);
						i++;
						evalArgs(args, done);
					});
			}
			else {
				done();
			}
		};

		evalArgs(
			this.args,
			function() {
				if (isPlayerEmbeddedInEditor && events != undefined && events != null) {
					events.Raise("script_node_exit", { id: self.GetId() });
				}

				environment.EvalFunction(self.name, argumentValues, onReturn);
			});
	}

	this.Serialize = function(depth) {
		var isDialogBlock = this.parent.type === "dialog_block";
		if (isDialogBlock && this.name === "say") {
			// TODO this could cause problems with "real" print functions
			return this.args[0].value; // first argument should be the text of the {print} func
		}
		else if (isDialogBlock && this.name === "br") {
			return "\n";
		}
		else {
			var str = "";
			str += this.name;
			for(var i = 0; i < this.args.length; i++) {
				str += " ";
				str += this.args[i].Serialize(depth);
			}
			return str;
		}
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

function LiteralNode(value) {
	TreeRelationship.call(this);

	this.type = "literal";
	this.value = value;

	this.Eval = function(environment,onReturn) {
		onReturn(this.value);
	};

	this.Serialize = function(depth) {
		var str = "";

		if (this.value === null) {
			return str;
		}

		if (typeof this.value === "string") {
			str += '"';
		}

		str += this.value;

		if (typeof this.value === "string") {
			str += '"';
		}

		return str;
	};

	this.ToString = function() {
		return this.type + " " + this.value + " " + this.GetId();
	};
}

function VarNode(name) {
	TreeRelationship.call(this);

	this.type = "variable";
	this.name = name;

	this.Eval = function(environment,onReturn) {
		// bitsy.log("EVAL " + this.name + " " + environment.HasVariable(this.name) + " " + environment.GetVariable(this.name));
		if( environment.HasVariable(this.name) )
			onReturn( environment.GetVariable( this.name ) );
		else
			onReturn(null); // not a valid variable -- return null and hope that's ok
	} // TODO: might want to store nodes in the variableMap instead of values???

	this.Serialize = function(depth) {
		var str = "" + this.name;
		return str;
	}

	this.ToString = function() {
		return this.type + " " + this.name + " " + this.GetId();
	};
}

function ExpNode(operator, left, right) {
	TreeRelationship.call(this);

	this.type = "operator";
	this.operator = operator;
	this.left = left;
	this.right = right;

	this.Eval = function(environment,onReturn) {
		// bitsy.log("EVAL " + this.operator);
		var self = this; // hack to deal with scope
		environment.EvalOperator( this.operator, this.left, this.right, 
			function(val){
				// bitsy.log("EVAL EXP " + self.operator + " " + val);
				onReturn(val);
			} );
		// NOTE : sadly this pushes a lot of complexity down onto the actual operator methods
	};

	this.Serialize = function(depth) {
		var isNegativeNumber = this.operator === "-" && this.left.type === "literal" && this.left.value === null;

		if (!isNegativeNumber) {
			var str = "";

			if (this.left != undefined && this.left != null) {
				str += this.left.Serialize(depth) + " ";
			}

			str += this.operator;

			if (this.right != undefined && this.right != null) {
				str += " " + this.right.Serialize(depth);
			}

			return str;
		}
		else {
			return this.operator + this.right.Serialize(depth); // hacky but seems to work
		}
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit( this, depth );
		if(this.left != null)
			this.left.VisitAll( visitor, depth + 1 );
		if(this.right != null)
			this.right.VisitAll( visitor, depth + 1 );
	};

	this.ToString = function() {
		return this.type + " " + this.operator + " " + this.GetId();
	};
}

function SequenceBase() {
	TreeRelationship.call(this);

	this.Serialize = function(depth) {
		var str = "";
		str += this.type + "\n";
		for (var i = 0; i < this.children.length; i++) {
			str += leadingWhitespace(depth + 1) + Sym.List + " ";
			str += this.children[i].Serialize(depth + 2);
			str += "\n";
		}
		str += leadingWhitespace(depth);
		return str;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);
		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll( visitor, depth + 1 );
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function SequenceNode(options) {
	SequenceBase.call(this);

	this.type = "sequence";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("SEQUENCE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
	}
}

function CycleNode(options) {
	SequenceBase.call(this);

	this.type = "cycle";
	this.AddChildren(options);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("CYCLE " + index);
		this.children[index].Eval(environment, onReturn);

		var next = index + 1;
		if (next < this.children.length) {
			index = next;
		}
		else {
			index = 0;
		}
	}
}

function ShuffleNode(options) {
	SequenceBase.call(this);

	this.type = "shuffle";
	this.AddChildren(options);

	var optionsShuffled = [];
	function shuffle(options) {
		optionsShuffled = [];
		var optionsUnshuffled = options.slice();
		while (optionsUnshuffled.length > 0) {
			var i = Math.floor(Math.random() * optionsUnshuffled.length);
			optionsShuffled.push(optionsUnshuffled.splice(i,1)[0]);
		}
	}
	shuffle(this.children);

	var index = 0;
	this.Eval = function(environment, onReturn) {
		optionsShuffled[index].Eval(environment, onReturn);
		
		index++;
		if (index >= this.children.length) {
			shuffle(this.children);
			index = 0;
		}
	}
}

// TODO : rename? ConditionalNode?
function IfNode(conditions, results, isSingleLine) {
	TreeRelationship.call(this);

	this.type = "if";

	for (var i = 0; i < conditions.length; i++) {
		this.AddChild(new ConditionPairNode(conditions[i], results[i]));
	}

	var self = this;
	this.Eval = function(environment, onReturn) {
		// bitsy.log("EVAL IF");
		var i = 0;
		function TestCondition() {
			self.children[i].Eval(environment, function(result) {
				if (result.conditionValue == true) {
					onReturn(result.resultValue);
				}
				else if (i+1 < self.children.length) {
					i++;
					TestCondition();
				}
				else {
					onReturn(null);
				}
			});
		};
		TestCondition();
	};

	if (isSingleLine === undefined) {
		isSingleLine = false; // This is just for serialization
	}

	this.Serialize = function(depth) {
		var str = "";
		if(isSingleLine) {
			// HACKY - should I even keep this mode???
			str += this.children[0].children[0].Serialize() + " ? " + this.children[0].children[1].Serialize();
			if (this.children.length > 1 && this.children[1].children[0].type === Sym.Else) {
				str += " " + Sym.ElseExp + " " + this.children[1].children[1].Serialize();
			}
		}
		else {
			str += "\n";
			for (var i = 0; i < this.children.length; i++) {
				str += this.children[i].Serialize(depth);
			}
			str += leadingWhitespace(depth);
		}
		return str;
	};

	this.IsSingleLine = function() {
		return isSingleLine;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

function ConditionPairNode(condition, result) {
	TreeRelationship.call(this);

	this.type = "condition_pair";

	this.AddChild(condition);
	this.AddChild(result);

	var self = this;

	this.Eval = function(environment, onReturn) {
		self.children[0].Eval(environment, function(conditionSuccess) {
			if (conditionSuccess) {
				self.children[1].Eval(environment, function(resultValue) {
					onReturn({ conditionValue:true, resultValue:resultValue });
				});
			}
			else {
				onReturn({ conditionValue:false });
			}
		});
	};

	this.Serialize = function(depth) {
		var str = "";
		str += leadingWhitespace(depth + 1);
		str += Sym.List + " " + this.children[0].Serialize(depth) + " " + Sym.ConditionEnd + Sym.Linebreak;
		str += this.children[1].Serialize(depth + 2) + Sym.Linebreak;
		return str;
	};

	this.VisitAll = function(visitor, depth) {
		if (depth == undefined || depth == null) {
			depth = 0;
		}

		visitor.Visit(this, depth);

		for (var i = 0; i < this.children.length; i++) {
			this.children[i].VisitAll(visitor, depth + 1);
		}
	};

	this.ToString = function() {
		return this.type + " " + this.GetId();
	};
}

function ElseNode() {
	TreeRelationship.call(this);

	this.type = Sym.Else;

	this.Eval = function(environment, onReturn) {
		onReturn(true);
	};

	this.Serialize = function() {
		return Sym.Else;
	};

	this.ToString = function() {
		return this.type + " " + this.mode + " " + this.GetId();
	};
}

var Sym = {
	DialogOpen : '"""',
	DialogClose : '"""',
	CodeOpen : "{",
	CodeClose : "}",
	Linebreak : "\n", // just call it "break" ?
	Separator : ":",
	List : "-",
	String : '"',
	ConditionEnd : "?",
	Else : "else",
	ElseExp : ":", // special shorthand for expressions (deprecate?)
	Set : "=",
	Operators : ["==", ">=", "<=", ">", "<", "-", "+", "/", "*"], // operators need to be in reverse order of precedence
};

var Parser = function(env) {
	var environment = env;

	this.Parse = function(scriptStr, rootId) {
		var rootNode = new DialogBlockNode();
		rootNode.rootId = rootId;
		var state = new ParserState(rootNode, scriptStr);

		if (state.MatchAhead(Sym.DialogOpen)) {
			// multi-line dialog block
			var dialogStr = state.ConsumeBlock(Sym.DialogOpen + Sym.Linebreak, Sym.Linebreak + Sym.DialogClose);
			rootNode = new DialogBlockNode();
			rootNode.rootId = rootId; // hacky!!
			state = new ParserState(rootNode, dialogStr);
			state = ParseDialog(state);
		}
		else {
			// single-line dialog block
			state = ParseDialog(state);
		}

		return state.rootNode;
	};

	var ParserState = function( rootNode, str ) {
		this.rootNode = rootNode;
		this.curNode = this.rootNode;

		var sourceStr = str;
		var i = 0;
		this.Index = function() { return i; };
		this.Count = function() { return sourceStr.length; };
		this.Done = function() { return i >= sourceStr.length; };
		this.Char = function() { return sourceStr[i]; };
		this.Step = function(n) { if(n===undefined) n=1; i += n; };
		this.MatchAhead = function(str) {
			// bitsy.log(str);
			str = "" + str; // hack to turn single chars into strings
			// bitsy.log(str);
			// bitsy.log(str.length);
			for (var j = 0; j < str.length; j++) {
				if (i + j >= sourceStr.length) {
					return false;
				}
				else if (str[j] != sourceStr[i+j]) {
					return false;
				}
			}
			return true;
		}
		this.Peak = function(end) {
			var str = "";
			var j = i;
			// bitsy.log(j);
			while (j < sourceStr.length && end.indexOf(sourceStr[j]) == -1) {
				str += sourceStr[j];
				j++;
			}
			// bitsy.log("PEAK ::" + str + "::");
			return str;
		}
		this.ConsumeBlock = function(open, close, includeSymbols) {
			if (includeSymbols === undefined || includeSymbols === null) {
				includeSymbols = false;
			}

			var startIndex = i;

			var matchCount = 0;
			if (this.MatchAhead(open)) {
				matchCount++;
				this.Step(open.length);
			}

			while (matchCount > 0 && !this.Done()) {
				if (this.MatchAhead(close)) {
					matchCount--;
					this.Step( close.length );
				}
				else if (this.MatchAhead(open)) {
					matchCount++;
					this.Step(open.length);
				}
				else {
					this.Step();
				}
			}

			if (includeSymbols) {
				return sourceStr.slice(startIndex, i);
			}
			else {
				return sourceStr.slice(startIndex + open.length, i - close.length);
			}
		}

		this.Print = function() { bitsy.log(sourceStr); };
		this.Source = function() { return sourceStr; };
	};

	/*
		ParseDialog():
		This function adds {print} nodes and linebreak {br} nodes to display text,
		interleaved with bracketed code nodes for functions and flow control,
		such as text effects {shk} {wvy} or sequences like {cycle} and {shuffle}.
		The parsing of those code blocks is handled by ParseCode.

		Note on parsing newline characters:
		- there should be an implicit linebreak {br} after each dialog line
		- a "dialog line" is defined as any line that either:
			- 1) contains dialog text (any text outside of a code block)
			- 2) is entirely empty (no text, no code)
			- *or* 3) contains a list block (sequence, cycle, shuffle, or conditional)
		- lines *only* containing {code} blocks are not dialog lines

		NOTE TO SELF: all the state I'm storing in here feels like
		evidence that the parsing system kind of broke down at this point :(
		Maybe it would feel better if I move into the "state" object
	*/
	function ParseDialog(state) {
		var curLineNodeList = [];
		var curText = "";
		var curLineIsEmpty = true;
		var curLineContainsDialogText = false;
		var prevLineIsDialogLine = false;

		var curLineIsDialogLine = function() {
			return curLineContainsDialogText || curLineIsEmpty;
		}

		var resetLineStateForNewLine = function() {
			prevLineIsDialogLine = curLineIsDialogLine();
			curLineContainsDialogText = false;
			curLineIsEmpty = true;
			curText = "";
			curLineNodeList = [];
		}

		var tryAddTextNodeToList = function() {
			if (curText.length > 0) {
				var sayNode = new FuncNode("say", [new LiteralNode(curText)]);
				curLineNodeList.push(sayNode);

				curText = "";
				curLineIsEmpty = false;
				curLineContainsDialogText = true;
			}
		}

		var addCodeNodeToList = function() {
			var codeSource = state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			var codeState = new ParserState(new CodeBlockNode(), codeSource);
			codeState = ParseCode(codeState);
			var codeBlockNode = codeState.rootNode;
			curLineNodeList.push(codeBlockNode);

			curLineIsEmpty = false;

			// lists count as dialog text, because they can contain it
			if (isMultilineListBlock(codeBlockNode)) {
				curLineContainsDialogText = true;
			}
		}

		var tryAddLinebreakNodeToList = function() {
			if (prevLineIsDialogLine) {
				var linebreakNode = new FuncNode("br", []);
				curLineNodeList.unshift(linebreakNode);
			}
		}

		var addLineNodesToParent = function() {
			for (var i = 0; i < curLineNodeList.length; i++) {
				state.curNode.AddChild(curLineNodeList[i]);
			}
		}

		while (!state.Done()) {
			if (state.MatchAhead(Sym.CodeOpen)) { // process code block
				// add any buffered text to a print node, and parse the code
				tryAddTextNodeToList();
				addCodeNodeToList();
			}
			else if (state.MatchAhead(Sym.Linebreak)) { // process new line
				// add any buffered text to a print node, 
				// and add a linebreak if we are between two dialog lines
				tryAddTextNodeToList();
				tryAddLinebreakNodeToList();

				// since we've reached the end of a line
				// add stored nodes for this line to the parent node we are building,
				// and reset state for the next line
				addLineNodesToParent();
				resetLineStateForNewLine();

				state.Step();
			}
			else {
				// continue adding text to the current text buffer
				curText += state.Char();
				state.Step();
			}
		}

		// to make sure we don't leave anything behind:
		// add buffered text to a print node and add all nodes
		// to the current parent node
		tryAddTextNodeToList();
		tryAddLinebreakNodeToList();
		addLineNodesToParent();

		return state;
	}

	function ParseDialogBlock(state) {
		var dialogStr = state.ConsumeBlock( Sym.DialogOpen, Sym.DialogClose );

		var dialogState = new ParserState(new DialogBlockNode(), dialogStr);
		dialogState = ParseDialog( dialogState );

		state.curNode.AddChild( dialogState.rootNode );

		return state;
	}

	/*
		ParseConditional():
		A conditional contains a list of conditions that can be
		evaluated to true or false, followed by more dialog
		that will be evaluated if the condition is true. The first
		true condition is the one that gets evaluated.
	*/
	function ParseConditional(state) {
		var conditionStrings = [];
		var resultStrings = [];
		var curIndex = -1;
		var requiredLeadingWhitespace = -1;

		// TODO : very similar to sequence parsing - can we share anything?
		function parseConditionalItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewCondition = false;
			var encounteredNonWhitespace = false;
			var encounteredConditionEnd = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewCondition = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// if this is the condition, we need to track whether we've
				// reached the end of the condition
				if (isNewCondition && !encounteredConditionEnd) {
					if (state.Char() === Sym.ConditionEnd) {
						encounteredConditionEnd = true;
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					if (!encounteredConditionEnd) { // skip all characters including & after the condition end
						lineText += state.Char();
					}
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewCondition:isNewCondition };
		}

		// TODO : this is copied from sequence parsing; share?
		function trimLeadingWhitespace(text, trimLength) {
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseConditionalItemLine(state);

			if (lineResults.isNewCondition) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curIndex++;
				conditionStrings[curIndex] = "";
				resultStrings[curIndex] = "";
			}

			// to avoid extra newlines in nested conditionals, only count lines
			// that at least match the whitespace count of the initial line
			// NOTE: see the comment in sequence parsing for more details
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);

				if (lineResults.isNewCondition) {
					conditionStrings[curIndex] += trimmedText;
				}
				else {
					resultStrings[curIndex] += trimmedText + Sym.Linebreak;
				}
			}
		}

		// hack: cut off the trailing newlines from all the result strings
		resultStrings = resultStrings.map(function(result) { return result.slice(0,-1); });

		var conditions = [];
		for (var i = 0; i < conditionStrings.length; i++) {
			var str = conditionStrings[i].trim();
			if (str === Sym.Else) {
				conditions.push(new ElseNode());
			}
			else {
				var exp = CreateExpression(str);
				conditions.push(exp);
			}
		}

		var results = [];
		for (var i = 0; i < resultStrings.length; i++) {
			var str = resultStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			results.push(dialogBlock);
		}

		state.curNode.AddChild(new IfNode(conditions, results));

		return state;
	}

	function IsSequence(str) {
		// bitsy.log("IsSequence? " + str);
		return str === "sequence" || str === "cycle" || str === "shuffle";
	}

	/*
		ParseSequence():
		Sequence nodes contain a list of dialog block nodes. The order those
		nodes are evaluated is determined by the type of sequence:
		- sequence: each child node evaluated once in order
		- cycle: repeats from the beginning after all nodes evaluate
		- shuffle: evaluate in a random order

		Each item in a sequence is sepearated by a "-" character.
		The seperator must come at the beginning of the line,
		but may be preceded by whitespace (in any amount).

		About whitespace: Whitespace at the start of a line
		is ignored if it less than or equal to the count of
		whitespace that preceded the list separator ("-") at
		the start of that item. (The count also includes the
		seperator and the extra space after the seperator.)
	 */
	function ParseSequence(state, sequenceType) {
		var itemStrings = [];
		var curItemIndex = -1; // -1 indicates not reading an item yet
		var requiredLeadingWhitespace = -1;

		function parseSequenceItemLine(state) {
			var lineText = "";
			var whitespaceCount = 0;
			var isNewListItem = false;
			var encounteredNonWhitespace = false;

			while (!state.Done() && !(state.Char() === Sym.Linebreak)) {
				// count whitespace until we hit the first non-whitespace character
				if (!encounteredNonWhitespace) {
					if (state.Char() === " " || state.Char() === "\t") {
						whitespaceCount++;
					}
					else {
						encounteredNonWhitespace = true;

						if (state.Char() === Sym.List) {
							isNewListItem = true;
							whitespaceCount += 2; // count the list seperator AND the following extra space
						}
					}
				}

				// add characters one at a time, unless it's a code block
				// since code blocks can contain additional sequences inside
				// them that will mess up our list item detection
				if (state.Char() === Sym.CodeOpen) {
					lineText += state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose, true /*includeSymbols*/);
				}
				else {
					lineText += state.Char();
					state.Step();
				}
			}

			if (state.Char() === Sym.Linebreak) {
				state.Step();
			}

			return { text:lineText, whitespace:whitespaceCount, isNewListItem:isNewListItem };
		}

		function trimLeadingWhitespace(text, trimLength) {
			// the split and join is necessary because a single "line"
			// can contain sequences that may contain newlines of their own
			// (we treat them all as one "line" for sequence parsing purposes)
			var textSplit = text.split(Sym.linebreak);
			textSplit = textSplit.map(function(line) { return line.slice(trimLength) });
			return textSplit.join(Sym.linebreak);
		}

		while (!state.Done()) {
			var lineResults = parseSequenceItemLine(state);

			if (lineResults.isNewListItem) {
				requiredLeadingWhitespace = lineResults.whitespace;
				curItemIndex++;
				itemStrings[curItemIndex] = "";
			}

			// to avoid double counting closing lines (empty ones ending in a curly brace)
			// we only allow lines that have at least as much whitespace as the start of the list item
			// TODO : I think right now this leads to a bug if the list item's indentation is less than
			// its parent code block... hopefully that won't be a big deal for now
			// (NOTE: I think the bug could be fixed by only applying this to the FINAL line of an item, but
			// that would require more consideration and testing)
			if (lineResults.whitespace >= requiredLeadingWhitespace) {
				var trimmedText = trimLeadingWhitespace(lineResults.text, requiredLeadingWhitespace);
				itemStrings[curItemIndex] += trimmedText + Sym.Linebreak;
			}
		}

		// a bit hacky: cut off the trailing newlines from all the items
		itemStrings = itemStrings.map(function(item) { return item.slice(0,-1); });

		var options = [];
		for (var i = 0; i < itemStrings.length; i++) {
			var str = itemStrings[i];
			var dialogBlockState = new ParserState(new DialogBlockNode(false /* doIndentFirstLine */), str);
			dialogBlockState = ParseDialog(dialogBlockState);
			var dialogBlock = dialogBlockState.rootNode;
			options.push(dialogBlock);
		}

		if (sequenceType === "sequence") {
			state.curNode.AddChild(new SequenceNode(options));
		}
		else if (sequenceType === "cycle") {
			state.curNode.AddChild(new CycleNode(options));
		}
		else if (sequenceType === "shuffle") {
			state.curNode.AddChild(new ShuffleNode(options));
		}

		return state;
	}

	function ParseFunction(state, funcName) {
		bitsy.log("~~~ PARSE FUNCTION " + funcName);

		var args = [];

		var curSymbol = "";
		function OnSymbolEnd() {
			curSymbol = curSymbol.trim();
			// bitsy.log("PARAMTER " + curSymbol);
			args.push( StringToValue(curSymbol) );
			// bitsy.log(args);
			curSymbol = "";
		}

		while( !( state.Char() === "\n" || state.Done() ) ) {
			if( state.MatchAhead(Sym.CodeOpen) ) {
				var codeBlockState = new ParserState(new CodeBlockNode(), state.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose));
				codeBlockState = ParseCode( codeBlockState );
				var codeBlock = codeBlockState.rootNode;
				args.push( codeBlock );
				curSymbol = "";
			}
			else if( state.MatchAhead(Sym.String) ) {
				/* STRING LITERAL */
				var str = state.ConsumeBlock(Sym.String, Sym.String);
				// bitsy.log("STRING " + str);
				args.push( new LiteralNode(str) );
				curSymbol = "";
			}
			else if(state.Char() === " " && curSymbol.length > 0) {
				OnSymbolEnd();
			}
			else {
				curSymbol += state.Char();
			}
			state.Step();
		}

		if(curSymbol.length > 0) {
			OnSymbolEnd();
		}

		state.curNode.AddChild( new FuncNode( funcName, args ) );

		return state;
	}

	function IsValidVariableName(str) {
		var reg = /^[a-zA-Z_$][a-zA-Z_$0-9]*$/;
		var isValid = reg.test(str);
		// bitsy.log("VALID variable??? " + isValid);
		return isValid;
	}

	function StringToValue(valStr) {
		if(valStr[0] === Sym.CodeOpen) {
			// CODE BLOCK!!!
			var codeStr = (new ParserState( null, valStr )).ConsumeBlock(Sym.CodeOpen, Sym.CodeClose); //hacky
			var codeBlockState = new ParserState(new CodeBlockNode(), codeStr);
			codeBlockState = ParseCode( codeBlockState );
			return codeBlockState.rootNode;
		}
		else if(valStr[0] === Sym.String) {
			// STRING!!
			// bitsy.log("STRING");
			var str = "";
			var i = 1;
			while (i < valStr.length && valStr[i] != Sym.String) {
				str += valStr[i];
				i++;
			}
			// bitsy.log(str);
			return new LiteralNode( str );
		}
		else if(valStr === "true") {
			// BOOL
			return new LiteralNode( true );
		}
		else if(valStr === "false") {
			// BOOL
			return new LiteralNode( false );
		}
		else if( !isNaN(parseFloat(valStr)) ) {
			// NUMBER!!
			// bitsy.log("NUMBER!!! " + valStr);
			return new LiteralNode( parseFloat(valStr) );
		}
		else if(IsValidVariableName(valStr)) {
			// VARIABLE!!
			// bitsy.log("VARIABLE");
			return new VarNode(valStr); // TODO : check for valid potential variables
		}
		else {
			// uh oh
			return new LiteralNode(null);
		}
	}

	function CreateExpression(expStr) {
		expStr = expStr.trim();

		function IsInsideString(index) {
			var inString = false;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.String)
					inString = !inString;

				if(index === i)
					return inString;
			}
			return false;
		}

		function IsInsideCode(index) {
			var count = 0;
			for(var i = 0; i < expStr.length; i++) {
				if(expStr[i] === Sym.CodeOpen)
					count++;
				else if(expStr[i] === Sym.CodeClose)
					count--;

				if(index === i)
					return count > 0;
			}
			return false;
		}

		var operator = null;

		// set is special because other operator can look like it, and it has to go first in the order of operations
		var setIndex = expStr.indexOf(Sym.Set);
		if( setIndex > -1 && !IsInsideString(setIndex) && !IsInsideCode(setIndex) ) { // it might be a set operator
			if( expStr[setIndex+1] != "=" && expStr[setIndex-1] != ">" && expStr[setIndex-1] != "<" ) {
				// ok it actually IS a set operator and not ==, >=, or <=
				operator = Sym.Set;
				var variableName = expStr.substring(0,setIndex).trim(); // TODO : valid variable name testing
				var left = IsValidVariableName(variableName) ? new VarNode( variableName ) : new LiteralNode(null);
				var right = CreateExpression( expStr.substring(setIndex+Sym.Set.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		// special if "expression" for single-line if statements
		var ifIndex = expStr.indexOf(Sym.ConditionEnd);
		if( ifIndex > -1 && !IsInsideString(ifIndex) && !IsInsideCode(ifIndex) ) {
			operator = Sym.ConditionEnd;
			var conditionStr = expStr.substring(0,ifIndex).trim();
			var conditions = [ CreateExpression(conditionStr) ];

			var resultStr = expStr.substring(ifIndex+Sym.ConditionEnd.length);
			var results = [];
			function AddResult(str) {
				var dialogBlockState = new ParserState(new DialogBlockNode(), str);
				dialogBlockState = ParseDialog( dialogBlockState );
				var dialogBlock = dialogBlockState.rootNode;
				results.push( dialogBlock );
			}

			var elseIndex = resultStr.indexOf(Sym.ElseExp); // does this need to test for strings?
			if(elseIndex > -1) {
				conditions.push( new ElseNode() );

				var elseStr = resultStr.substring(elseIndex+Sym.ElseExp.length);
				var resultStr = resultStr.substring(0,elseIndex);

				AddResult( resultStr.trim() );
				AddResult( elseStr.trim() );
			}
			else {
				AddResult( resultStr.trim() );
			}

			return new IfNode( conditions, results, true /*isSingleLine*/ );
		}

		for( var i = 0; (operator == null) && (i < Sym.Operators.length); i++ ) {
			var opSym = Sym.Operators[i];
			var opIndex = expStr.indexOf( opSym );
			if( opIndex > -1 && !IsInsideString(opIndex) && !IsInsideCode(opIndex) ) {
				operator = opSym;
				var left = CreateExpression( expStr.substring(0,opIndex) );
				var right = CreateExpression( expStr.substring(opIndex+opSym.length) );
				var exp = new ExpNode( operator, left, right );
				return exp;
			}
		}

		if( operator == null ) {
			return StringToValue(expStr);
		}
	}
	this.CreateExpression = CreateExpression;

	function IsWhitespace(str) {
		return ( str === " " || str === "\t" || str === "\n" );
	}

	function IsExpression(str) {
		var tempState = new ParserState(null, str); // hacky
		var textOutsideCodeBlocks = "";

		while (!tempState.Done()) {
			if (tempState.MatchAhead(Sym.CodeOpen)) {
				tempState.ConsumeBlock(Sym.CodeOpen, Sym.CodeClose);
			}
			else {
				textOutsideCodeBlocks += tempState.Char();
				tempState.Step();
			}
		}

		var containsAnyExpressionOperators = (textOutsideCodeBlocks.indexOf(Sym.ConditionEnd) != -1) ||
				(textOutsideCodeBlocks.indexOf(Sym.Set) != -1) ||
				(Sym.Operators.some(function(opSym) { return textOutsideCodeBlocks.indexOf(opSym) != -1; }));

		return containsAnyExpressionOperators;
	}

	function IsLiteral(str) {
		var isBool = str === "true" || str === "false";
		var isNum = !isNaN(parseFloat(str));
		var isStr = str[0] === '"' && str[str.length-1] === '"';
		var isVar = IsValidVariableName(str);
		var isEmpty = str.length === 0;
		return isBool || isNum || isStr || isVar || isEmpty;
	}

	function ParseExpression(state) {
		var line = state.Source(); // state.Peak( [Sym.Linebreak] ); // TODO : remove the linebreak thing
		// bitsy.log("EXPRESSION " + line);
		var exp = CreateExpression(line);
		// bitsy.log(exp);
		state.curNode.AddChild(exp);
		state.Step(line.length);
		return state;
	}

	function IsConditionalBlock(state) {
		var peakToFirstListSymbol = state.Peak([Sym.List]);

		var foundListSymbol = peakToFirstListSymbol < state.Source().length;

		var areAllCharsBeforeListWhitespace = true;
		for (var i = 0; i < peakToFirstListSymbol.length; i++) {
			if (!IsWhitespace(peakToFirstListSymbol[i])) {
				areAllCharsBeforeListWhitespace = false;
			}
		}

		var peakToFirstConditionSymbol = state.Peak([Sym.ConditionEnd]);
		peakToFirstConditionSymbol = peakToFirstConditionSymbol.slice(peakToFirstListSymbol.length);
		var hasNoLinebreakBetweenListAndConditionEnd = peakToFirstConditionSymbol.indexOf(Sym.Linebreak) == -1;

		return foundListSymbol && 
			areAllCharsBeforeListWhitespace && 
			hasNoLinebreakBetweenListAndConditionEnd;
	}

	function ParseCode(state) {
		if (IsConditionalBlock(state)) {
			state = ParseConditional(state);
		}
		else if (environment.HasFunction(state.Peak([" "]))) { // TODO --- what about newlines???
			var funcName = state.Peak([" "]);
			state.Step(funcName.length);
			state = ParseFunction(state, funcName);
		}
		else if (IsSequence(state.Peak([" ", Sym.Linebreak]))) {
			var sequenceType = state.Peak([" ", Sym.Linebreak]);
			state.Step(sequenceType.length);
			state = ParseSequence(state, sequenceType);
		}
		else if (IsLiteral(state.Source()) || IsExpression(state.Source())) {
			state = ParseExpression(state);
		}
		else {
			var undefinedSrc = state.Peak([]);
			var undefinedNode = new UndefinedNode(undefinedSrc);
			state.curNode.AddChild(undefinedNode);
		}

		// just go to the end now
		while (!state.Done()) {
			state.Step();
		}

		return state;
	}

	function ParseCodeBlock(state) {
		var codeStr = state.ConsumeBlock( Sym.CodeOpen, Sym.CodeClose );
		var codeState = new ParserState(new CodeBlockNode(), codeStr);
		codeState = ParseCode( codeState );
		state.curNode.AddChild( codeState.rootNode );
		return state;
	}

}

} // Script()
</script>

<script>
function Dialog() {

this.CreateRenderer = function() {
	return new DialogRenderer();
};

this.CreateBuffer = function() {
	return new DialogBuffer();
};

var DialogRenderer = function() {
	// TODO : refactor this eventually? remove everything from struct.. avoid the defaults?
	var textboxInfo = {
		width : 104,
		height : 8+4+2+5, //8 for text, 4 for top-bottom padding, 2 for line padding, 5 for arrow
		top : 12,
		left : 12,
		bottom : 12, //for drawing it from the bottom
		padding_vert : 2,
		padding_horz : 4,
		arrow_height : 5,
	};

	var font = null;
	this.SetFont = function(f) {
		font = f;
		textboxInfo.height = (textboxInfo.padding_vert * 3) + (relativeFontHeight() * 2) + textboxInfo.arrow_height;

		// todo : clean up all the scale stuff
		var textboxScaleW = textboxInfo.width * getTextScale();
		var textboxScaleH = textboxInfo.height * getTextScale();
		bitsy.textbox(false, 0, 0, textboxScaleW, textboxScaleH);
	}

	this.GetPixelsPerRow = function() {
		return (textboxInfo.width - (textboxInfo.padding_horz * 2)) * getTextScale();
	}

	// todo : cache this value? it shouldn't really change in the middle of a game
	function getTextScale() {
		return bitsy.textMode() === bitsy.TXT_LOREZ ? 1 : 2;
	}

	function relativeFontWidth() {
		return Math.ceil(font.getWidth() / getTextScale());
	}

	function relativeFontHeight() {
		return Math.ceil(font.getHeight() / getTextScale());
	}

	this.ClearTextbox = function() {
		bitsy.fill(bitsy.TEXTBOX, textBackgroundIndex);
	};

	var isCentered = false;
	this.SetCentered = function(centered) {
		isCentered = centered;
	};

	// todo : I can stop doing this every frame right?
	this.DrawTextbox = function() {
		if (isCentered) {
			// todo : will the height calculations always work?
			bitsy.textbox(true, textboxInfo.left, ((bitsy.VIDEO_SIZE / 2) - (textboxInfo.height / 2)));
		}
		else if (player().y < (bitsy.MAP_SIZE / 2)) {
			// bottom
			bitsy.textbox(true, textboxInfo.left, (bitsy.VIDEO_SIZE - textboxInfo.bottom - textboxInfo.height));
		}
		else {
			// top
			bitsy.textbox(true, textboxInfo.left, textboxInfo.top);
		}
	};

	var arrowdata = [
		1,1,1,1,1,
		0,1,1,1,0,
		0,0,1,0,0
	];

	this.DrawNextArrow = function() {
		// bitsy.log("draw arrow!");
		var text_scale = getTextScale();
		var textboxScaleW = textboxInfo.width * text_scale;
		var textboxScaleH = textboxInfo.height * text_scale;

		var top = (textboxInfo.height - 5) * text_scale;
		var left = (textboxInfo.width - (5 + 4)) * text_scale;
		if (textDirection === TextDirection.RightToLeft) { // RTL hack
			left = 4 * text_scale;
		}

		for (var y = 0; y < 3; y++) {
			for (var x = 0; x < 5; x++) {
				var i = (y * 5) + x;
				if (arrowdata[i] == 1) {
					//scaling nonsense
					for (var sy = 0; sy < text_scale; sy++) {
						for (var sx = 0; sx < text_scale; sx++) {
							var px = left + (x * text_scale) + sx;
							var py = top + (y * text_scale) + sy;
							bitsy.set(bitsy.TEXTBOX, (py * textboxScaleW) + px, textArrowIndex);
						}
					}
				}
			}
		}
	};

	function drawCharData(charData, textScale, top, left, width, height, color) {
		for (var y = 0; y < height; y++) {
			for (var x = 0; x < width; x++) {
				var i = (y * width) + x;
				if (charData[i] == 1) {
					bitsy.set(bitsy.TEXTBOX, ((top + y) * (textboxInfo.width * textScale)) + (left + x), color);
				}
			}
		}
	}

	this.DrawChar = function(char, row, col, leftPos) {
		// characters with effects need to be redrawn every frame
		if (char.effectList.length > 0) {
			char.redraw = true;
		}

		// skip characters that are already drawn and don't need to be updated
		if (!char.redraw) {
			return;
		}
		char.redraw = false;

		var text_scale = getTextScale();
		var charData = char.bitmap;
		var top;
		var left;

		if (char.effectList.length > 0) {
			// clear the pixels from the previous frame
			top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
			left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);
			drawCharData(charData, text_scale, top, left, char.width, char.height, textBackgroundIndex);
		}

		// compute render offset *every* frame
		char.offset = {
			x: char.base_offset.x,
			y: char.base_offset.y
		};
		char.SetPosition(row, col);
		char.ApplyEffects(effectTime);

		top = (4 * text_scale) + (row * 2 * text_scale) + (row * font.getHeight()) + Math.floor(char.offset.y);
		left = (4 * text_scale) + leftPos + Math.floor(char.offset.x);

		drawCharData(charData, text_scale, top, left, char.width, char.height, char.color);

		// TODO : consider for a future update?
		/*
		if (soundPlayer && char.blip && char.hasPlayedBlip != true) {
			soundPlayer.playBlip(blip[char.blip], { isPitchRandomized: true });
			char.hasPlayedBlip = true;
		}
		*/

		// call printHandler for character
		if (!disableOnPrintHandlers) {
			char.OnPrint();
		}
	};

	var effectTime = 0; // TODO this variable should live somewhere better

	var shouldUpdateTextboxSettings = true;
	var shouldClearTextbox = true;
	var shouldDrawArrow = true;

	var disableOnPrintHandlers = false;

	this.Draw = function(buffer, dt, disableOnPrint) {
		disableOnPrintHandlers = (disableOnPrint === true);

		// bitsy.log("draw dialog");
		if (buffer.DidFlipPageThisFrame()) {
			shouldClearTextbox = true;
			shouldDrawArrow = true;
		}

		effectTime += dt;

		if (shouldUpdateTextboxSettings) {
			bitsy.log("draw textbox");
			this.DrawTextbox(); // todo : rename to something more accurate
			shouldUpdateTextboxSettings = false;
		}

		if (shouldClearTextbox) {
			// bitsy.log("clear textbox");
			this.ClearTextbox();
			shouldClearTextbox = false;
		}

		// bitsy.log("draw chars");
		buffer.ForEachActiveChar(this.DrawChar);

		if (buffer.CanContinue() && shouldDrawArrow) {
			// bitsy.log("draw next arrow");
			this.DrawNextArrow();
			shouldDrawArrow = false;
		}

		if (buffer.DidPageFinishThisFrame() && onPageFinish != null) {
			bitsy.log("page finished");
			onPageFinish();
		}

		// bitsy.log("draw dialog end");
	};

	/* this is a hook for GIF rendering */
	var onPageFinish = null;
	this.SetPageFinishHandler = function(handler) {
		onPageFinish = handler;
	};

	this.Reset = function() {
		effectTime = 0;
		// TODO - anything else?

		shouldUpdateTextboxSettings = true;
		shouldClearTextbox = true;
		shouldDrawArrow = true;
	}

	this.updateTextboxPosition = function() {
		shouldUpdateTextboxSettings = true;
	};

	// this.CharsPerRow = function() {
	// 	return textboxInfo.charsPerRow;
	// }
}

var DialogBuffer = function() {
	var buffer = [[[]]]; // holds dialog in an array buffer
	var pageIndex = 0;
	var rowIndex = 0;
	var charIndex = 0;
	var nextCharTimer = 0;
	var nextCharMaxTime = 50; // in milliseconds
	var isDialogReadyToContinue = false;
	var activeTextEffects = [];
	var activeTextEffectParameters = [];
	var font = null;
	var arabicHandler = new ArabicHandler();
	var onDialogEndCallbacks = [];

	this.SetFont = function(f) {
		font = f;
	};

	this.SetPixelsPerRow = function(n) {
		pixelsPerRow = n;
	};

	this.CurPage = function() { return buffer[ pageIndex ]; };
	this.CurRow = function() { return this.CurPage()[ rowIndex ]; };
	this.CurChar = function() { return this.CurRow()[ charIndex ]; };
	this.CurPageCount = function() { return buffer.length; };
	this.CurRowCount = function() { return this.CurPage().length; };
	this.CurCharCount = function() { return this.CurRow().length; };

	this.ForEachActiveChar = function(handler) { // Iterates over visible characters on the active page
		var rowCount = rowIndex + 1;
		for (var i = 0; i < rowCount; i++) {
			var row = this.CurPage()[i];
			var charCount = (i == rowIndex) ? charIndex+1 : row.length;
			// bitsy.log(charCount);

			var leftPos = 0;
			if (textDirection === TextDirection.RightToLeft) {
				leftPos = 24 * 8; // hack -- I think this is correct?
			}

			for(var j = 0; j < charCount; j++) {
				var char = row[j];
				if(char) {
					if (textDirection === TextDirection.RightToLeft) {
						leftPos -= char.spacing;
					}
					// bitsy.log(j + " " + leftPos);

					// handler( char, i /*rowIndex*/, j /*colIndex*/ );
					handler(char, i /*rowIndex*/, j /*colIndex*/, leftPos)

					if (textDirection === TextDirection.LeftToRight) {
						leftPos += char.spacing;
					}
				}
			}
		}
	}

	this.Reset = function() {
		buffer = [[[]]];
		pageIndex = 0;
		rowIndex = 0;
		charIndex = 0;
		isDialogReadyToContinue = false;

		afterManualPagebreak = false;

		activeTextEffects = [];

		onDialogEndCallbacks = [];

		isActive = false;
	};

	this.DoNextChar = function() {
		nextCharTimer = 0; //reset timer

		//time to update characters
		if (charIndex + 1 < this.CurCharCount()) {
			//add char to current row
			charIndex++;
		}
		else if (rowIndex + 1 < this.CurRowCount()) {
			//start next row
			rowIndex++;
			charIndex = 0;
		}
		else {
			//the page is full!
			isDialogReadyToContinue = true;
			didPageFinishThisFrame = true;
		}

		if (this.CurChar() != null) {
			if (this.CurChar().isPageBreak) {
				// special case for page break marker character!
				isDialogReadyToContinue = true;
				didPageFinishThisFrame = true;
			}
			
			this.CurChar().OnPrint(); // make sure we hit the callback before we run out of text
		}
	};

	this.Update = function(dt) {
		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;
		// this.Draw(dt); // TODO move into a renderer object
		if (isDialogReadyToContinue) {
			return; //waiting for dialog to be advanced by player
		}

		nextCharTimer += dt; //tick timer

		if (nextCharTimer > nextCharMaxTime) {
			this.DoNextChar();
		}
	};

	var isSkipping = false;

	this.Skip = function() {
		bitsy.log("SKIPPP");
		isSkipping = true;

		didPageFinishThisFrame = false;
		didFlipPageThisFrame = false;

		// add new characters until you get to the end of the current line of dialog
		while (rowIndex < this.CurRowCount() && isSkipping) {
			this.DoNextChar();

			if (isDialogReadyToContinue) {
				//make sure to push the rowIndex past the end to break out of the loop
				rowIndex++;
				charIndex = 0;
			}
		}

		if (isSkipping) {
			rowIndex = this.CurRowCount() - 1;
			charIndex = this.CurCharCount() - 1;
		}

		isSkipping = false;
	};

	this.tryInterruptSkip = function() {
		if (isSkipping) {
			isSkipping = false;
			return true;
		}

		return false;
	};

	this.FlipPage = function() {
		didFlipPageThisFrame = true;
		isDialogReadyToContinue = false;
		pageIndex++;
		rowIndex = 0;
		charIndex = 0;
	}

	this.EndDialog = function() {
		isActive = false; // no more text to show... this should be a sign to stop rendering dialog

		for (var i = 0; i < onDialogEndCallbacks.length; i++) {
			onDialogEndCallbacks[i]();
		}
	}

	var afterManualPagebreak = false; // is it bad to track this state like this?

	this.Continue = function() {
		bitsy.log("CONTINUE");

		// if we used a page break character to continue we need
		// to run whatever is in the script afterwards! // TODO : make this comment better
		if (this.CurChar().isPageBreak) {
			// hacky: always treat a page break as the end of dialog
			// if there's more dialog later we re-activate the dialog buffer
			this.EndDialog();
			afterManualPagebreak = true;
			this.CurChar().OnContinue();
			return false;
		}
		if (pageIndex + 1 < this.CurPageCount()) {
			bitsy.log("FLIP PAGE!");
			//start next page
			this.FlipPage();
			return true; /* hasMoreDialog */
		}
		else {
			bitsy.log("END DIALOG!");
			bitsy.textbox(false);
			//end dialog mode
			this.EndDialog();
			return false; /* hasMoreDialog */
		}
	};

	var isActive = false;
	this.IsActive = function() { return isActive; };

	this.OnDialogEnd = function(callback) {
		if (!isActive) {
			callback();
		}
		else {
			onDialogEndCallbacks.push(callback);
		}
	}

	this.CanContinue = function() { return isDialogReadyToContinue; };

	function DialogChar() {
		this.redraw = true;

		this.effectList = [];
		this.effectParameterList = [];

		this.color = textColorIndex; // white
		this.offset = { x:0, y:0 }; // in pixels (screen pixels?)

		this.col = 0;
		this.row = 0;

		this.SetPosition = function(row,col) {
			// bitsy.log("SET POS");
			// bitsy.log(this);
			this.row = row;
			this.col = col;
		};

		this.ApplyEffects = function(time) {
			// bitsy.log("APPLY EFFECTS! " + time);
			for (var i = 0; i < this.effectList.length; i++) {
				var effectName = this.effectList[i];
				// bitsy.log("FX " + effectName);
				TextEffects[effectName].doEffect(this, time, this.effectParameterList[i]);
			}
		};

		var printHandler = null; // optional function to be called once on printing character
		this.SetPrintHandler = function(handler) {
			printHandler = handler;
		};
		this.OnPrint = function() {
			if (printHandler != null) {
				// bitsy.log("PRINT HANDLER ---- DIALOG BUFFER");
				printHandler();
				printHandler = null; // only call handler once (hacky)
			}
		};

		this.bitmap = [];
		this.width = 0;
		this.height = 0;
		this.base_offset = { // hacky name
 			x: 0,
			y: 0
		};
		this.spacing = 0;
	}

	function DialogFontChar(font, char, effectList, effectParameterList) {
		DialogChar.call(this);

		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)
		this.effectParameterList = effectParameterList.slice();

		var charData = font.getChar(char);
		this.char = char;
		this.bitmap = charData.data;
		this.width = charData.width;
		this.height = charData.height;
		this.base_offset.x = charData.offset.x;
		this.base_offset.y = charData.offset.y;
		this.spacing = charData.spacing;
		this.blip = null;
		this.hasPlayedBlip = false;
	}

	function DialogDrawingChar(drawingId, effectList, effectParameterList) {
		DialogChar.call(this);

		this.effectList = effectList.slice(); // clone effect list (since it can change between chars)
		this.effectParameterList = effectParameterList.slice();

		// get the first frame of the drawing and flatten it
		var drawingData = renderer.GetDrawingSource(drawingId)[0];
		var drawingDataFlat = [];
		for (var i = 0; i < drawingData.length; i++) {
			drawingDataFlat = drawingDataFlat.concat(drawingData[i]);
		}

		this.bitmap = drawingDataFlat;
		this.width = 8;
		this.height = 8;
		this.spacing = 8;
	}

	function DialogScriptControlChar() {
		DialogChar.call(this);

		this.width = 0;
		this.height = 0;
		this.spacing = 0;
	}

	// is a control character really the best way to handle page breaks?
	function DialogPageBreakChar() {
		DialogChar.call(this);

		this.width = 0;
		this.height = 0;
		this.spacing = 0;

		this.isPageBreak = true;

		var continueHandler = null;

		this.SetContinueHandler = function(handler) {
			continueHandler = handler;
		};

		this.OnContinue = function() {
			if (continueHandler) {
				continueHandler();
			}
		};
	}

	function AddWordToCharArray(charArray, word, effectList, effectParameterList) {
		// bitsy.log("add char array");
		for (var i = 0; i < word.length; i++) {
			charArray.push(new DialogFontChar(font, word[i], effectList, effectParameterList));
		}
		// bitsy.log("add char array end");
		return charArray;
	}

	function GetCharArrayWidth(charArray) {
		var width = 0;
		for(var i = 0; i < charArray.length; i++) {
			width += charArray[i].spacing;
		}
		return width;
	}

	function GetStringWidth(str) {
		var width = 0;
		for (var i = 0; i < str.length; i++) {
			var charData = font.getChar(str[i]);
			width += charData.spacing;
		}
		return width;
	}

	var pixelsPerRow = 192; // hard-coded fun times!!!

	this.AddScriptReturn = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var controlChar = new DialogScriptControlChar();
		controlChar.SetPrintHandler(onReturnHandler);

		curRowArr.push(controlChar);

		isActive = true;
	}

	this.AddDrawing = function(drawingId) {
		// bitsy.log("DRAWING ID " + drawingId);

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		var drawingChar = new DialogDrawingChar(drawingId, activeTextEffects, activeTextEffectParameters);

		var rowLength = GetCharArrayWidth(curRowArr);

		// TODO : clean up copy-pasted code here :/
		if (afterManualPagebreak) {
			this.FlipPage(); // hacky

			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);

			afterManualPagebreak = false;
		}
		else if (rowLength + drawingChar.spacing  <= pixelsPerRow || rowLength <= 0) {
			//stay on same row
			curRowArr.push(drawingChar);
		}
		else if (curRowIndex == 0) {
			//start next row
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer[curPageIndex].push([]);
			curRowIndex++;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}
		else {
			//start next page
			buffer[curPageIndex][curRowIndex] = curRowArr;
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
			curRowArr.push(drawingChar);
		}

		isActive = true; // this feels like a bad way to do this???
	}

	// TODO : convert this into something that takes DialogChar arrays
	this.AddText = function(textStr) {
		bitsy.log("ADD TEXT " + textStr);

		//process dialog so it's easier to display
		var words = textStr.split(" ");

		// var curPageIndex = this.CurPageCount() - 1;
		// var curRowIndex = this.CurRowCount() - 1;
		// var curRowArr = this.CurRow();

		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		for (var i = 0; i < words.length; i++) {
			var word = words[i];
			if (arabicHandler.ContainsArabicCharacters(word)) {
				word = arabicHandler.ShapeArabicCharacters(word);
			}

			var wordWithPrecedingSpace = ((i == 0) ? "" : " ") + word;
			var wordLength = GetStringWidth(wordWithPrecedingSpace);

			var rowLength = GetCharArrayWidth(curRowArr);

			if (afterManualPagebreak) {
				this.FlipPage();

				// hacky copied bit for page breaks
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);

				afterManualPagebreak = false;
			}
			else if (rowLength + wordLength <= pixelsPerRow || rowLength <= 0) {
				//stay on same row
				curRowArr = AddWordToCharArray(curRowArr, wordWithPrecedingSpace, activeTextEffects, activeTextEffectParameters);
			}
			else if (curRowIndex == 0) {
				//start next row
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer[curPageIndex].push([]);
				curRowIndex++;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);
			}
			else {
				//start next page
				buffer[curPageIndex][curRowIndex] = curRowArr;
				buffer.push([]);
				curPageIndex++;
				buffer[curPageIndex].push([]);
				curRowIndex = 0;
				curRowArr = buffer[curPageIndex][curRowIndex];
				curRowArr = AddWordToCharArray(curRowArr, word, activeTextEffects, activeTextEffectParameters);
			}
		}

		//destroy any empty stuff
		var lastPage = buffer[buffer.length-1];
		var lastRow = lastPage[lastPage.length-1];
		if (lastRow.length == 0) {
			lastPage.splice(lastPage.length-1, 1);
		}
		if (lastPage.length == 0) {
			buffer.splice(buffer.length-1, 1);
		}

		//finish up 
		lastPage = buffer[buffer.length-1];
		lastRow = lastPage[lastPage.length-1];
		if (lastRow.length > 0) {
			var lastChar = lastRow[lastRow.length-1];
		}

		// bitsy.log(buffer);

		bitsy.log("add text finished");

		isActive = true;
	};

	this.AddLinebreak = function() {
		var lastPage = buffer[buffer.length-1];
		if (lastPage.length <= 1) {
			// bitsy.log("LINEBREAK - NEW ROW ");
			// add new row
			lastPage.push([]);
		}
		else {
			// add new page
			buffer.push([[]]);
		}
		// bitsy.log(buffer);

		isActive = true;
	}

	this.AddPagebreak = function(onReturnHandler) {
		var curPageIndex = buffer.length - 1;
		var curRowIndex = buffer[curPageIndex].length - 1;
		var curRowArr = buffer[curPageIndex][curRowIndex];

		// need to actually create a whole new page if following another pagebreak character
		if (this.CurChar() && this.CurChar().isPageBreak) {
			buffer.push([]);
			curPageIndex++;
			buffer[curPageIndex].push([]);
			curRowIndex = 0;
			curRowArr = buffer[curPageIndex][curRowIndex];
		}

		var pagebreakChar = new DialogPageBreakChar();
		pagebreakChar.SetContinueHandler(onReturnHandler);

		curRowArr.push(pagebreakChar);

		isActive = true;		
	}

	this.hasTextEffect = function(name) {
		return activeTextEffects.indexOf(name) != -1;
	};

	this.pushTextEffect = function(name, parameters) {
		activeTextEffects.push(name);
		activeTextEffectParameters.push(parameters);
	};

	this.popTextEffect = function(name) {
		var i = activeTextEffects.lastIndexOf(name);
		activeTextEffects.splice(i, 1);
		activeTextEffectParameters.splice(i, 1);
	};

	/* this is a hook for GIF rendering */
	var didPageFinishThisFrame = false;
	this.DidPageFinishThisFrame = function(){ return didPageFinishThisFrame; };

	var didFlipPageThisFrame = false;
	this.DidFlipPageThisFrame = function(){ return didFlipPageThisFrame; };

	// this.SetCharsPerRow = function(num){ charsPerRow = num; }; // hacky
};

/* ARABIC */
var ArabicHandler = function() {

	var arabicCharStart = 0x0621;
	var arabicCharEnd = 0x064E;

	var CharacterForm = {
		Isolated : 0,
		Final : 1,
		Initial : 2,
		Middle : 3
	};

	// map glyphs to their character forms
	var glyphForms = {
		/*		 Isolated, Final, Initial, Middle Forms	*/
		0x0621: [0xFE80,0xFE80,0xFE80,0xFE80], /*  HAMZA  */ 
		0x0622: [0xFE81,0xFE82,0xFE81,0xFE82], /*  ALEF WITH MADDA ABOVE  */ 
		0x0623: [0xFE83,0xFE84,0xFE83,0xFE84], /*  ALEF WITH HAMZA ABOVE  */ 
		0x0624: [0xFE85,0xFE86,0xFE85,0xFE86], /*  WAW WITH HAMZA ABOVE  */ 
		0x0625: [0xFE87,0xFE88,0xFE87,0xFE88], /*  ALEF WITH HAMZA BELOW  */ 
		0x0626: [0xFE89,0xFE8A,0xFE8B,0xFE8C], /*  YEH WITH HAMZA ABOVE  */ 
		0x0627: [0xFE8D,0xFE8E,0xFE8D,0xFE8E], /*  ALEF  */ 
		0x0628: [0xFE8F,0xFE90,0xFE91,0xFE92], /*  BEH  */ 
		0x0629: [0xFE93,0xFE94,0xFE93,0xFE94], /*  TEH MARBUTA  */ 
		0x062A: [0xFE95,0xFE96,0xFE97,0xFE98], /*  TEH  */ 
		0x062B: [0xFE99,0xFE9A,0xFE9B,0xFE9C], /*  THEH  */ 
		0x062C: [0xFE9D,0xFE9E,0xFE9F,0xFEA0], /*  JEEM  */ 
		0x062D: [0xFEA1,0xFEA2,0xFEA3,0xFEA4], /*  HAH  */ 
		0x062E: [0xFEA5,0xFEA6,0xFEA7,0xFEA8], /*  KHAH  */ 
		0x062F: [0xFEA9,0xFEAA,0xFEA9,0xFEAA], /*  DAL  */ 
		0x0630: [0xFEAB,0xFEAC,0xFEAB,0xFEAC], /*  THAL */ 
		0x0631: [0xFEAD,0xFEAE,0xFEAD,0xFEAE], /*  RAA  */ 
		0x0632: [0xFEAF,0xFEB0,0xFEAF,0xFEB0], /*  ZAIN  */ 
		0x0633: [0xFEB1,0xFEB2,0xFEB3,0xFEB4], /*  SEEN  */ 
		0x0634: [0xFEB5,0xFEB6,0xFEB7,0xFEB8], /*  SHEEN  */ 
		0x0635: [0xFEB9,0xFEBA,0xFEBB,0xFEBC], /*  SAD  */ 
		0x0636: [0xFEBD,0xFEBE,0xFEBF,0xFEC0], /*  DAD  */ 
		0x0637: [0xFEC1,0xFEC2,0xFEC3,0xFEC4], /*  TAH  */ 
		0x0638: [0xFEC5,0xFEC6,0xFEC7,0xFEC8], /*  ZAH  */ 
		0x0639: [0xFEC9,0xFECA,0xFECB,0xFECC], /*  AIN  */ 
		0x063A: [0xFECD,0xFECE,0xFECF,0xFED0], /*  GHAIN  */ 
		0x063B: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063C: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063D: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063E: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x063F: [0x0000,0x0000,0x0000,0x0000], /*  space */
		0x0640: [0x0640,0x0640,0x0640,0x0640], /*  TATWEEL  */ 
		0x0641: [0xFED1,0xFED2,0xFED3,0xFED4], /*  FAA  */ 
		0x0642: [0xFED5,0xFED6,0xFED7,0xFED8], /*  QAF  */ 
		0x0643: [0xFED9,0xFEDA,0xFEDB,0xFEDC], /*  KAF  */ 
		0x0644: [0xFEDD,0xFEDE,0xFEDF,0xFEE0], /*  LAM  */ 
		0x0645: [0xFEE1,0xFEE2,0xFEE3,0xFEE4], /*  MEEM  */ 
		0x0646: [0xFEE5,0xFEE6,0xFEE7,0xFEE8], /*  NOON  */ 
		0x0647: [0xFEE9,0xFEEA,0xFEEB,0xFEEC], /*  HEH  */ 
		0x0648: [0xFEED,0xFEEE,0xFEED,0xFEEE], /*  WAW  */ 
		0x0649: [0xFEEF,0xFEF0,0xFBE8,0xFBE9], /*  ALEF MAKSURA  */ 
		0x064A: [0xFEF1,0xFEF2,0xFEF3,0xFEF4], /*  YEH  */ 
		0x064B: [0xFEF5,0xFEF6,0xFEF5,0xFEF6], /*  LAM ALEF MADD*/
		0x064C: [0xFEF7,0xFEF8,0xFEF7,0xFEF8], /*  LAM ALEF HAMZA ABOVE*/
		0x064D: [0xFEF9,0xFEFa,0xFEF9,0xFEFa], /*  LAM ALEF HAMZA BELOW*/
		0x064E: [0xFEFb,0xFEFc,0xFEFb,0xFEFc], /*  LAM ALEF */
	};

	var disconnectedCharacters = [0x0621,0x0622,0x0623,0x0624,0x0625,0x0627,0x062f,0x0630,0x0631,0x0632,0x0648,0x0649,0x064b,0x064c,0x064d,0x064e];

	function IsArabicCharacter(char) {
		var code = char.charCodeAt(0);
		return (code >= arabicCharStart && code <= arabicCharEnd);
	}

	function ContainsArabicCharacters(word) {
		for (var i = 0; i < word.length; i++) {
			if (IsArabicCharacter(word[i])) {
				return true;
			}
		}
		return false;
	}

	function IsDisconnectedCharacter(char) {
		var code = char.charCodeAt(0);
		return disconnectedCharacters.indexOf(code) != -1;
	}

	function ShapeArabicCharacters(word) {
		var shapedWord = "";

		for (var i = 0; i < word.length; i++) {
			if (!IsArabicCharacter(word[i])) {
				shapedWord += word[i];
				continue;
			}

			var connectedToPreviousChar = i-1 >= 0 && IsArabicCharacter(word[i-1]) && !IsDisconnectedCharacter(word[i-1]);

			var connectedToNextChar = i+1 < word.length && IsArabicCharacter(word[i+1]) && !IsDisconnectedCharacter(word[i]);

			var form;
			if (!connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Isolated;
			}
			else if (connectedToPreviousChar && !connectedToNextChar) {
				form = CharacterForm.Final;
			}
			else if (!connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Initial;
			}
			else if (connectedToPreviousChar && connectedToNextChar) {
				form = CharacterForm.Middle;
			}

			var code = word[i].charCodeAt(0);

			// handle lam alef special case
			if (code == 0x0644 && connectedToNextChar) {
				var nextCode = word[i+1].charCodeAt(0);
				var specialCode = null;
				if (nextCode == 0x0622) {
					// alef madd
					specialCode = glyphForms[0x064b][form];
				}
				else if (nextCode == 0x0623) {
					// hamza above
					specialCode = glyphForms[0x064c][form];
				}
				else if (nextCode == 0x0625) {
					// hamza below
					specialCode = glyphForms[0x064d][form];
				}
				else if (nextCode == 0x0627) {
					// alef
					specialCode = glyphForms[0x064e][form];
				}

				if (specialCode != null) {
					shapedWord += String.fromCharCode(specialCode);
					i++; // skip a step
					continue;
				}
			}

			// hacky?
			if (form === CharacterForm.Isolated) {
				shapedWord += word[i];
				continue;
			}

			var shapedCode = glyphForms[code][form];
			shapedWord += String.fromCharCode(shapedCode);
		}

		return shapedWord;
	}

	this.ContainsArabicCharacters = ContainsArabicCharacters;
	this.ShapeArabicCharacters = ShapeArabicCharacters;
}

/* TEXT EFFECTS */
var TextEffects = {};

function RainbowEffect() {
	function positiveModulo(number, divisor) {
		return ((number % divisor) + divisor) % divisor;
	}

	this.doEffect = function(char, time, parameters) {
		char.color = rainbowColorStartIndex + Math.floor(positiveModulo((time / 100) - char.col * 0.5, rainbowColorCount));
	};
}

TextEffects["rbw"] = new RainbowEffect();

function ColorEffect(index) {
	this.doEffect = function(char, time, parameters) {
		if (parameters && parameters.length > 0) {
			char.color = tileColorStartIndex + parameters[0];
		}
		else {
			char.color = tileColorStartIndex + index;
		}
	};
}

TextEffects["clr"] = new ColorEffect();
TextEffects["clr1"] = new ColorEffect(0);
TextEffects["clr2"] = new ColorEffect(1);
TextEffects["clr3"] = new ColorEffect(2);

function WavyEffect() {
	this.doEffect = function(char, time, parameters) {
		char.offset.y += Math.sin((time / 250) - (char.col / 2)) * 2;
	};
}

TextEffects["wvy"] = new WavyEffect();

function ShakyEffect() {
	function disturb(func, time, offset, mult1, mult2) {
		return func((time * mult1) - (offset * mult2));
	}

	this.doEffect = function(char, time, parameters) {
		char.offset.y += 1.5
						* disturb(Math.sin, time, char.col, 0.1, 0.5)
						* disturb(Math.cos, time, char.col, 0.3, 0.2)
						* disturb(Math.sin, time, char.row, 2.0, 1.0);
		char.offset.x += 1.5
						* disturb(Math.cos, time, char.row, 0.1, 1.0)
						* disturb(Math.sin, time, char.col, 3.0, 0.7)
						* disturb(Math.cos, time, char.col, 0.2, 0.3);
	};
}

TextEffects["shk"] = new ShakyEffect();

/*
// TODO : maybe use this in a future update?
function YakEffect() {
	this.doEffect = function(char, time, parameters) {
		if (char.char != " ") {
			char.blip = parameters[0];
		}
	};
}

TextEffects["yak"] = new YakEffect();
*/

var DebugHighlightEffect = function() {
	this.doEffect = function(char, time, parameters) {
		char.color = tileColorStartIndex;
	};
}

TextEffects["_debug_highlight"] = new DebugHighlightEffect();

} // Dialog()
</script>

<script>
function TileRenderer() {
bitsy.log("!!!!! NEW TILE RENDERER");

var drawingCache = {
	source: {},
	render: {},
};

// var debugRenderCount = 0;

function createRenderCacheId(drawingId, colorIndex) {
	return drawingId + "_" + colorIndex;
}

function renderDrawing(drawing) {
	// debugRenderCount++;
	// bitsy.log("RENDER COUNT " + debugRenderCount);

	var col = drawing.col;
	var bgc = drawing.bgc;
	var drwId = drawing.drw;
	var drawingFrames = drawingCache.source[drwId];

	// initialize render cache entry
	var cacheId = createRenderCacheId(drwId, col);
	if (drawingCache.render[cacheId] === undefined) {
		// initialize array of frames for drawing
		drawingCache.render[cacheId] = [];
	}

	for (var i = 0; i < drawingFrames.length; i++) {
		var frameData = drawingFrames[i];
		var frameTileId = renderTileFromDrawingData(frameData, col, bgc);
		drawingCache.render[cacheId].push(frameTileId);
	}
}

function renderTileFromDrawingData(drawingData, col, bgc) {
	var tileId = bitsy.tile();

	var backgroundColor = tileColorStartIndex + bgc;
	var foregroundColor = tileColorStartIndex + col;

	bitsy.fill(tileId, backgroundColor);

	for (var y = 0; y < bitsy.TILE_SIZE; y++) {
		for (var x = 0; x < bitsy.TILE_SIZE; x++) {
			var px = drawingData[y][x];
			if (px === 1) {
				bitsy.set(tileId, (y * bitsy.TILE_SIZE) + x, foregroundColor);
			}
		}
	}

	return tileId;
}

// TODO : move into core
function undefinedOrNull(x) {
	return x === undefined || x === null;
}

function isDrawingRendered(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId] != undefined;
}

function getRenderedDrawingFrames(drawing) {
	var cacheId = createRenderCacheId(drawing.drw, drawing.col);
	return drawingCache.render[cacheId];
}

function getDrawingFrameTileId(drawing, frameOverride) {
	var frameIndex = 0;

	if (drawing != null && drawing.animation.isAnimated) {
		if (frameOverride != undefined && frameOverride != null) {
			frameIndex = frameOverride;
		}
		else {
			frameIndex = drawing.animation.frameIndex;
		}
	}

	return getRenderedDrawingFrames(drawing)[frameIndex];
}

function getOrRenderDrawingFrame(drawing, frameOverride) {
	// bitsy.log("frame render: " + drawing.type + " " + drawing.id + " f:" + frameOverride);

	if (!isDrawingRendered(drawing)) {
		bitsy.log("frame render: doesn't exist " + drawing.id);
		renderDrawing(drawing);
	}

	return getDrawingFrameTileId(drawing, frameOverride);
}

function deleteRenders(drawingId) {
	for (var cacheId in drawingCache.render) {
		if (cacheId.indexOf(drawingId) === 0) {
			var tiles = drawingCache.render[cacheId];
			for (var i = 0; i < tiles.length; i++) {
				bitsy.delete(tiles[i]);
			}
			delete drawingCache.render[cacheId];
		}
	}
}

/* PUBLIC INTERFACE */
this.GetDrawingFrame = getOrRenderDrawingFrame;

// todo : leave individual get and set stuff for now - should I remove later?
// todo : better name for function?
this.SetDrawings = function(drawingSource) {
	drawingCache.source = drawingSource;
	// need to reset entire render cache when all the drawings are changed
	drawingCache.render = {};
};

this.SetDrawingSource = function(drawingId, drawingData) {
	deleteRenders(drawingId);
	drawingCache.source[drawingId] = drawingData;
};

this.GetDrawingSource = function(drawingId) {
	return drawingCache.source[drawingId];
};

this.GetFrameCount = function(drawingId) {
	return drawingCache.source[drawingId].length;
};

// todo : forceReset option is hacky?
this.ClearCache = function(forceReset) {
	if (forceReset === undefined || forceReset === true) {
		for (var cacheId in drawingCache.render) {
			var tiles = drawingCache.render[cacheId];
			for (var i = 0; i < tiles.length; i++) {
				bitsy.delete(tiles[i]);
			}
		}
	}

	drawingCache.render = {};
};

this.deleteDrawing = deleteRenders;

} // Renderer()
</script>

<script>
/* WORLD DATA */
var room = {};
var tile = {};
var sprite = {};
var item = {};
var dialog = {};
var end = {}; // for backwards compatibility
var palette = { // start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
var variable = {}; // these are starting variable values -- they don't update (or I don't think they will)
var tune = {};
var blip = {};
var playerId = "A";
var fontName = defaultFontName;
var textDirection = TextDirection.LeftToRight;

/* NAME-TO-ID MAPS */
var names = {
	room : {},
	tile : {},
	sprite : {},
	item : {},
	dialog : {},
	palette : {},
	tune : {},
	blip : {},
};

// todo : this is basically a copy of the one in world.js - can I remove it?
function updateNamesFromCurData() {

	function createNameMap(objectStore) {
		var map = {};

		for (id in objectStore) {
			if (objectStore[id].name != undefined && objectStore[id].name != null) {
				map[objectStore[id].name] = id;
			}
		}

		return map;
	}

	names.room = createNameMap(room);
	names.tile = createNameMap(tile);
	names.sprite = createNameMap(sprite);
	names.item = createNameMap(item);
	names.dialog = createNameMap(dialog);
	names.palette = createNameMap(palette);
	names.tune = createNameMap(tune);
	names.blip = createNameMap(blip);
}

/* GAME STATE */
var state = {}
function resetGameState() {
	state.room = "0";
	state.ava = playerId; // avatar appearance override
	state.pal = "0"; // current palette id
	state.tune = "0"; // current tune id ("0" === off)
}

// title helper functions
function getTitle() {
	return dialog[titleDialogId].src;
}
function setTitle(titleSrc) {
	dialog[titleDialogId] = { src:titleSrc, name:null };
}

/* FLAGS */
var flags = createDefaultFlags();

// feature flags for testing purposes
var engineFeatureFlags = {
	isSoundEnabled : true,
	isFontEnabled : true,
	isTransitionEnabled : true,
	isScriptEnabled : true,
	isDialogEnabled : true,
	isRendererEnabled : true,
};

function clearGameData() {
	room = {};
	tile = {};
	sprite = {};
	item = {};
	dialog = {};
	palette = { //start off with a default palette
		"default" : {
			name : "default",
			colors : [[0,0,0],[255,255,255],[255,255,255]]
		}
	};
	isEnding = false; //todo - correct place for this?
	variable = {};

	updateNamesFromCurData();

	fontName = defaultFontName; // TODO : reset font manager too?
	textDirection = TextDirection.LeftToRight;

	resetGameState();

	isGameLoaded = false;
	isGameOver = false;
}

// engine event hooks for the editor
var onInventoryChanged = null;
var onVariableChanged = null;
var onGameReset = null;
var onInitRoom = null;

var isPlayerEmbeddedInEditor = false;

var renderer;
if (engineFeatureFlags.isRendererEnabled) {
	renderer = new TileRenderer();
}

var curGameData = null;
var curDefaultFontData = null;

var isGameLoaded = false;
var isGameOver = false;

function load_game(gameData, defaultFontData, startWithTitle) {
	// bitsy.log("game data in: \n" + gameData);

	curGameData = gameData; //remember the current game (used to reset the game)

	if (dialogBuffer) {
		dialogBuffer.Reset();
	}

	if (scriptInterpreter) {
		scriptInterpreter.ResetEnvironment(); // ensures variables are reset -- is this the best way?
	}

	loadWorldFromGameData(gameData);

	bitsy.log("world loaded");

	if (fontManager && !isPlayerEmbeddedInEditor && defaultFontData) {
		bitsy.log("load font");

		curDefaultFontData = defaultFontData; // store for resetting game

		// todo : consider replacing this with a more general system for requesting resources from the system?
		// hack to ensure default font is available
		fontManager.AddResource(defaultFontName + fontManager.GetExtension(), defaultFontData);

		bitsy.log("load font end");
	}

	// request text mode
	if (flags.TXT_MODE === 1) {
		bitsy.textMode(bitsy.TXT_LOREZ);
	}
	else {
		// default to 2x scale for text rendering
		bitsy.textMode(bitsy.TXT_HIREZ);
	}

	if (fontManager && dialogBuffer) {
		bitsy.log("get font");

		var font = fontManager.Get( fontName );
		dialogBuffer.SetFont(font);
		dialogRenderer.SetFont(font);

		bitsy.log("get font end");
	}

	if (dialogBuffer) {
		// this feels a little silly to me - oh well??
		dialogBuffer.SetPixelsPerRow(dialogRenderer.GetPixelsPerRow());
	}

	setInitialVariables();

	bitsy.log("ready");

	onready(startWithTitle);

	isGameLoaded = true;
}

function loadWorldFromGameData(gameData) {
	bitsy.log("load world from game data");

	var world = parseWorld(gameData);

	bitsy.log("parse world done");

	// move world data into global scope
	palette = world.palette;
	room = world.room;
	tile = world.tile;
	sprite = world.sprite;
	item = world.item;
	dialog = world.dialog;
	end = world.end; // back compat endings
	variable = world.variable;
	fontName = world.fontName;
	textDirection = world.textDirection;
	tune = world.tune;
	blip = world.blip;
	flags = world.flags;
	names = world.names;

	if (renderer) {
		renderer.SetDrawings(world.drawings);
	}

	// find starting room and initialize it
	var roomIds = Object.keys(room);

	if (player() != undefined && player().room != null && roomIds.indexOf(player().room) != -1) {
		// player has valid room
		state.room = player().room;
	}
	else if (roomIds.length > 0) {
		// player not in any room! what the heck
		state.room = roomIds[0];
	}
	else {
		// uh oh there are no rooms I guess???
		state.room = null;
	}

	if (state.room != null) {
		bitsy.log("INIT ROOM " + state.room);
		initRoom(state.room);
	}
}

function reset_cur_game() {
	if (curGameData == null) {
		return; //can't reset if we don't have the game data
	}

	stopGame();
	clearGameData();

	if (isPlayerEmbeddedInEditor && onGameReset != null) {
		onGameReset();
	}
}

function onready(startWithTitle) {
	bitsy.log("game ready!");

	if (startWithTitle === undefined || startWithTitle === null) {
		startWithTitle = true;
	}

	if (startWithTitle) { // used by editor 
		startNarrating(getTitle());
	}
}

function setInitialVariables() {
	if (!scriptInterpreter) {
		return;
	}

	for(id in variable) {
		var value = variable[id]; // default to string
		if(value === "true") {
			value = true;
		}
		else if(value === "false") {
			value = false;
		}
		else if(!isNaN(parseFloat(value))) {
			value = parseFloat(value);
		}
		scriptInterpreter.SetVariable(id,value);
	}
	scriptInterpreter.SetOnVariableChangeHandler( onVariableChanged );
}

function getOffset(evt) {
	var offset = { x:0, y:0 };

	var el = evt.target;
	var rect = el.getBoundingClientRect();

	offset.x += rect.left + el.scrollLeft;
	offset.y += rect.top + el.scrollTop;

	offset.x = evt.clientX - offset.x;
	offset.y = evt.clientY - offset.y;

	return offset;
}

function stopGame() {
	if (soundPlayer) {
		soundPlayer.stopTune();
	}
	bitsy.log("stop GAME!");
}

function update(dt) {
	if (!isGameLoaded) {
		load_game(bitsy.getGameData(), bitsy.getFontData());
	}

	if (state.room == null) {
		// in the special case where there is no valid room, end the game
		startNarrating( "", true /*isEnding*/ );
	}

	if (!transition || !transition.IsTransitionActive()) {
		updateInput();
	}

	if (transition && transition.IsTransitionActive()) {
		// transition animation takes over everything!
		transition.UpdateTransition(dt);
	}
	else {
		if (bitsy.graphicsMode() != bitsy.GFX_MAP) {
			bitsy.graphicsMode(bitsy.GFX_MAP);
		}

		if (soundPlayer) {
			soundPlayer.update(dt);
		}

		if (!isNarrating && !isEnding) {
			// draw world if game has begun
			var didAnimate = updateAnimation(dt);

			// test whether player moved so we can redraw just the avatar
			playerCurX = player().x;
			playerCurY = player().y;
			var didPlayerMove = (playerPrevX != playerCurX) || (playerPrevY != playerCurY);

			drawRoom(room[state.room], { redrawAnimated: didAnimate, redrawAvatar: didPlayerMove });

			// store player's position for next frame
			playerPrevX = playerCurX;
			playerPrevY = playerCurY;
		}
		else {
			clearRoom();
		}

		if (dialogBuffer && dialogBuffer.IsActive() && !(soundPlayer && soundPlayer.isBlipPlaying())) {
			// bitsy.log("update dialog");
			// bitsy.log("renderer");
			dialogRenderer.Draw(dialogBuffer, dt);
			// bitsy.log("buffer");
			dialogBuffer.Update(dt);
			// bitsy.log("update dialog end");
		}

		// keep moving avatar if player holds down button
		if ((!dialogBuffer || !dialogBuffer.IsActive()) && !isEnding) {
			if (curPlayerDirection != Direction.None) {
				playerHoldToMoveTimer -= dt;

				if (playerHoldToMoveTimer <= 0) {
					movePlayer(curPlayerDirection, false /* isFirstMove */);
					playerHoldToMoveTimer = 150;
					// playerHoldToMoveTimer = 16; // PERF TEST
				}
			}
		}
	}

	// clean up state if the game is ending
	if (isGameOver) {
		bitsy.log("game over");
		reset_cur_game();
	}

	return true;
}

var isAnyButtonHeld = false;
var isIgnoringInput = false;

function isAnyButtonDown() {
	return bitsy.button(bitsy.BTN_UP) ||
		bitsy.button(bitsy.BTN_DOWN) ||
		bitsy.button(bitsy.BTN_LEFT) ||
		bitsy.button(bitsy.BTN_RIGHT) ||
		bitsy.button(bitsy.BTN_OK);
}

function updateInput() {
	if (dialogBuffer && dialogBuffer.IsActive()) {
		if (!(soundPlayer && soundPlayer.isBlipPlaying())) {
			if (!isAnyButtonHeld && isAnyButtonDown()) {
				/* CONTINUE DIALOG */
				if (dialogBuffer.CanContinue()) {
					var hasMoreDialog = dialogBuffer.Continue();
					if (!hasMoreDialog) {
						// ignore currently held keys UNTIL they are released (stops player from insta-moving)
						isIgnoringInput = true;
						curPlayerDirection = Direction.None;
					}
				}
				else {
					dialogBuffer.Skip();
				}
			}
		}
	}
	else if (isEnding) {
		if (!isAnyButtonHeld && isAnyButtonDown()) {
			// tell game to restart
			isGameOver = true;
		}
	}
	else if (!isIgnoringInput) {
		/* WALK */
		var prevPlayerDirection = curPlayerDirection;

		if (bitsy.button(bitsy.BTN_UP)) {
			curPlayerDirection = Direction.Up;
		}
		else if (bitsy.button(bitsy.BTN_DOWN)) {
			curPlayerDirection = Direction.Down;
		}
		else if (bitsy.button(bitsy.BTN_LEFT)) {
			curPlayerDirection = Direction.Left;
		}
		else if (bitsy.button(bitsy.BTN_RIGHT)) {
			curPlayerDirection = Direction.Right;
		}
		else {
			curPlayerDirection = Direction.None;
		}

		if (curPlayerDirection != Direction.None && curPlayerDirection != prevPlayerDirection) {
			movePlayer(curPlayerDirection, true /* isFirstMove */);
			playerHoldToMoveTimer = 500;
			// playerHoldToMoveTimer = 32; // PERF TEST
		}
	}

	if (!isAnyButtonDown()) {
		isIgnoringInput = false;
	}

	// quit if the user ever presses the restart button
	// todo : should I rename it bitsy.BTN_RESTART or bitsy.BTN_QUIT or bitsy.BTN_OFF?
	if (bitsy.button(bitsy.BTN_MENU)) {
		isGameOver = true;
	}

	isAnyButtonHeld = isAnyButtonDown();
}

var animationCounter = 0;
var animationTime = 400;
function updateAnimation(dt) {
	animationCounter += dt;
	// bitsy.log("anim " + animationCounter);
	if (animationCounter >= animationTime) {
		// animate sprites
		for (id in sprite) {
			var spr = sprite[id];
			if (spr.animation.isAnimated) {
				spr.animation.frameIndex = (spr.animation.frameIndex + 1) % spr.animation.frameCount;
			}
		}

		// animate tiles
		for (id in tile) {
			var til = tile[id];
			if (til.animation.isAnimated) {
				til.animation.frameIndex = (til.animation.frameIndex + 1) % til.animation.frameCount;
			}
		}

		// animate items
		for (id in item) {
			var itm = item[id];
			if (itm.animation.isAnimated) {
				itm.animation.frameIndex = (itm.animation.frameIndex + 1) % itm.animation.frameCount;
			}
		}

		// reset counter
		animationCounter = 0;

		// updated animations this frame
		return true;
	}

	// did *not* update animations this frame
	return false;
}

function resetAllAnimations() {
	for (id in sprite) {
		var spr = sprite[id];
		if (spr.animation.isAnimated) {
			spr.animation.frameIndex = 0;
		}
	}

	for (id in tile) {
		var til = tile[id];
		if (til.animation.isAnimated) {
			til.animation.frameIndex = 0;
		}
	}

	for (id in item) {
		var itm = item[id];
		if (itm.animation.isAnimated) {
			itm.animation.frameIndex = 0;
		}
	}
}

function getSpriteAt(x, y, roomId) {
	if (roomId === undefined) {
		roomId = state.room;
	}

	for (id in sprite) {
		var spr = sprite[id];
		if (spr.room === roomId) {
			if (spr.x == x && spr.y == y) {
				return id;
			}
		}
	}

	return null;
}

var Direction = {
	None : -1,
	Up : 0,
	Down : 1,
	Left : 2,
	Right : 3
};

var curPlayerDirection = Direction.None;
var playerHoldToMoveTimer = 0;
var playerPrevX = 0;
var playerPrevY = 0;

function movePlayer(direction, isFirstMove) {
	didPlayerMove = false;
	var roomIds = Object.keys(room);

	if (player().room == null || roomIds.indexOf(player().room) < 0) {
		return; // player room is missing or invalid.. can't move them!
	}

	var spr = null;

	if (direction == Direction.Left && !(spr = getSpriteLeft()) && !isWallLeft()) {
		player().x -= 1;
	}
	else if (direction == Direction.Right && !(spr = getSpriteRight()) && !isWallRight()) {
		player().x += 1;
	}
	else if (direction == Direction.Up && !(spr = getSpriteUp()) && !isWallUp()) {
		player().y -= 1;
	}
	else if (direction == Direction.Down && !(spr = getSpriteDown()) && !isWallDown()) {
		player().y += 1;
	}

	var ext = getExit( player().room, player().x, player().y );
	var end = getEnding( player().room, player().x, player().y );
	var itmIndex = getItemIndex( player().room, player().x, player().y );

	// only play one sound effect per "turn"
	var blipId = null;

	// do items first, because you can pick up an item AND go through a door
	if (itmIndex > -1) {
		var itm = room[player().room].items[itmIndex];
		var itemRoom = player().room;

		// play sound on pitck up item
		if (item[itm.id].blip != null) {
			blipId = item[itm.id].blip;
		}

		startItemDialog(itm.id, function() {
			// remove item from room
			room[itemRoom].items.splice(itmIndex, 1);

			// update player inventory
			if (player().inventory[itm.id]) {
				player().inventory[itm.id] += 1;
			}
			else {
				player().inventory[itm.id] = 1;
			}

			// show inventory change in UI
			if (onInventoryChanged != null) {
				onInventoryChanged(itm.id);
			}
		});
	}

	if (end) {
		startEndingDialog(end);
	}
	else if (ext) {
		movePlayerThroughExit(ext);
	}
	else if (spr) {
		// play sound on greet sprite
		if (sprite[spr].blip != null) {
			blipId = sprite[spr].blip;
		}

		startSpriteDialog(spr /*spriteId*/);
	}

	// TODO : maybe add in a future update?
	/*
	// play sound when player moves (if no other sound selected)
	if (isFirstMove && blipId === null && sprite[state.ava].blip != null) {
		blipId = sprite[state.ava].blip;
		randomizeBlip = true;
		blipChannel = bitsy.SOUND2; // play walking sfx *under* the tune melody
	}
	*/

	if (soundPlayer && blipId != null && blip[blipId]) {
		soundPlayer.playBlip(blip[blipId]);
	}
}

var transition;
if (engineFeatureFlags.isTransitionEnabled) {
	transition = new TransitionManager();
}

function movePlayerThroughExit(ext) {
	var GoToDest = function() {
		if (transition && ext.transition_effect != null) {
			transition.BeginTransition(
				player().room,
				player().x,
				player().y,
				ext.dest.room,
				ext.dest.x,
				ext.dest.y,
				ext.transition_effect);

			transition.UpdateTransition(0);

			transition.OnTransitionComplete(function() {
				player().room = ext.dest.room;
				player().x = ext.dest.x;
				player().y = ext.dest.y;
				state.room = ext.dest.room;
				initRoom(state.room);
			});
		}
		else {
			player().room = ext.dest.room;
			player().x = ext.dest.x;
			player().y = ext.dest.y;
			state.room = ext.dest.room;

			initRoom(state.room);
		}
	};

	if (ext.dlg != undefined && ext.dlg != null) {
		// TODO : I need to simplify dialog code,
		// so I don't have to get the ID and the source str
		// every time!
		startDialog(
			dialog[ext.dlg].src,
			ext.dlg,
			function(result) {
				var isLocked = ext.property && ext.property.locked === true;
				if (!isLocked) {
					GoToDest();
				}
			},
			ext);
	}
	else {
		GoToDest();
	}
}

/* PALETTE INDICES */
var backgroundIndex = 0;
var textBackgroundIndex = 1;
var textArrowIndex = 2;
var textColorIndex = 3;

// precalculated rainbow colors
var rainbowColorStartIndex = 4;
var rainbowColorCount = 10;
var rainbowColors = [
	[255,0,0],
	[255,217,0],
	[78,255,0],
	[0,255,125],
	[0,192,255],
	[0,18,255],
	[136,0,255],
	[255,0,242],
	[255,0,138],
	[255,0,61],
];

function updatePaletteWithTileColors(tileColors) {
	// the screen background color should match the first tile color
	if (tileColors.length > 0) {
		var color = tileColors[0];
		bitsy.color(backgroundIndex, color[0], color[1], color[2]);
	}
	else {
		// as a fallback, use black as the background
		bitsy.log("no tile colors!");
		bitsy.color(backgroundIndex, 0, 0, 0);
	}

	// textbox colors
	bitsy.color(textBackgroundIndex, 0, 0, 0); // black
	bitsy.color(textArrowIndex, 255, 255, 255); // white
	bitsy.color(textColorIndex, 255, 255, 255); // white

	// rainbow colors
	for (var i = 0; i < rainbowColorCount; i++) {
		var color = rainbowColors[i];
		bitsy.color(rainbowColorStartIndex + i, color[0], color[1], color[2]);
	}

	// tile colors
	for (var i = 0; i < tileColors.length; i++) {
		var color = tileColors[i];
		bitsy.color(tileColorStartIndex + i, color[0], color[1], color[2]);
	}
}

function updatePalette(palId) {
	state.pal = palId;
	var pal = palette[state.pal];
	updatePaletteWithTileColors(pal.colors);
}

function initRoom(roomId) {
	bitsy.log("init room " + roomId);

	updatePalette(getRoomPal(roomId));

	// update avatar appearance
	state.ava = (room[roomId].ava != null) ? room[roomId].ava : playerId;

	if (renderer) {
		renderer.ClearCache();
	}

	// init exit properties
	for (var i = 0; i < room[roomId].exits.length; i++) {
		room[roomId].exits[i].property = { locked:false };
	}

	// init ending properties
	for (var i = 0; i < room[roomId].endings.length; i++) {
		room[roomId].endings[i].property = { locked:false };
	}

	if (soundPlayer) {
		if (!room[roomId].tune || room[roomId].tune === "0" || !tune[room[roomId].tune]) {
			// stop music
			state.tune = "0";
			soundPlayer.stopTune();
		}
		else if (room[roomId].tune != state.tune) {
			// start music
			state.tune = room[roomId].tune;
			soundPlayer.playTune(tune[state.tune]);
		}
	}

	var drawArgs = { redrawAll: true };
	drawRoom(room[roomId], drawArgs);

	if (onInitRoom) {
		onInitRoom(roomId);
	}
}

function getItemIndex( roomId, x, y ) {
	for( var i = 0; i < room[roomId].items.length; i++ ) {
		var itm = room[roomId].items[i];
		if ( itm.x == x && itm.y == y)
			return i;
	}
	return -1;
}

function getSpriteLeft() { //repetitive?
	return getSpriteAt( player().x - 1, player().y );
}

function getSpriteRight() {
	return getSpriteAt( player().x + 1, player().y );
}

function getSpriteUp() {
	return getSpriteAt( player().x, player().y - 1 );
}

function getSpriteDown() {
	return getSpriteAt( player().x, player().y + 1 );
}

function isWallLeft() {
	return (player().x - 1 < 0) || isWall( player().x - 1, player().y );
}

function isWallRight() {
	return (player().x + 1 >= bitsy.MAP_SIZE) || isWall(player().x + 1, player().y);
}

function isWallUp() {
	return (player().y - 1 < 0) || isWall( player().x, player().y - 1 );
}

function isWallDown() {
	return (player().y + 1 >= bitsy.MAP_SIZE) || isWall(player().x, player().y + 1);
}

function isWall(x, y, roomId) {
	if (roomId == undefined || roomId == null) {
		roomId = state.room;
	}

	var tileId = getTile(x, y, roomId);
	if (tileId === '0') {
		return false; // Blank spaces aren't walls, ya doofus
	}

	if (tile[tileId].isWall === undefined || tile[tileId].isWall === null) {
		// No wall-state defined: check room-specific walls
		var i = room[roomId].walls.indexOf(getTile(x, y, roomId));
		return (i > -1);
	}

	// Otherwise, use the tile's own wall-state
	return tile[tileId].isWall;
}

function getItem(roomId,x,y) {
	for (i in room[roomId].items) {
		var item = room[roomId].items[i];
		if (x == item.x && y == item.y) {
			return item;
		}
	}
	return null;
}

function getExit(roomId,x,y) {
	for (i in room[roomId].exits) {
		var e = room[roomId].exits[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getEnding(roomId,x,y) {
	for (i in room[roomId].endings) {
		var e = room[roomId].endings[i];
		if (x == e.x && y == e.y) {
			return e;
		}
	}
	return null;
}

function getTile(x, y, roomId) {
	// bitsy.log(x + " " + y);
	var t = getRoom(roomId).tilemap[y][x];
	return t;
}

function player() {
	return sprite[playerId];
}

// Sort of a hack for legacy palette code (when it was just an array)
function getPal(id) {
	if (palette[id] === undefined) {
		id = "default";
	}

	return palette[ id ].colors;
}

function getRoom(id) {
	return room[id === undefined ? state.room : id];
}

function isSpriteOffstage(id) {
	return sprite[id].room == null;
}

function serializeNote(note, key, useFriendlyName) {
	var isSolfa = (key != undefined && key != null);
	var noteType = (isSolfa === true) ? Solfa : Note;

	if (isSolfa && key.scale.indexOf(note) === -1) {
		// no matching note in key
		return null;
	}

	if (isSolfa && useFriendlyName != true) {
		for (var name in Solfa) {
			if (Solfa[name] === note) {
				return name.toLowerCase();
			}
		}

		// no solfa note found
		return null;
	}

	// for a solfa note's "friendly name" convert to the chromatic equivalent
	if (isSolfa && useFriendlyName === true) {
		note = key.notes[note];
	}

	// from this point on, we know the note we're looking for is chromatic
	for (var name in Note) {
		if (Note[name] === note) {
			name = name.replace("_SHARP", "#");
			if (useFriendlyName === true && name === "H") {
				name = "C";
			}
			return name;
		}
	}

	// no note found
	return symbol;
}

function serializeOctave(octave) {
	for (var symbol in Octave) {
		if (Octave[symbol] === octave) {
			return symbol;
		}
	}

	// default to middle octave
	return "4";
}

//TODO this is in progress and doesn't support all features
function serializeWorld(skipFonts) {
	if (skipFonts === undefined || skipFonts === null) {
		skipFonts = false;
	}

	// update version flags
	flags.VER_MAJ = version.major;
	flags.VER_MIN = version.minor;

	var worldStr = "";
	/* TITLE */
	worldStr += getTitle() + "\n";
	worldStr += "\n";
	/* VERSION */
	worldStr += "# BITSY VERSION " + getEngineVersion() + "\n"; // add version as a comment for debugging purposes
	if (version.devBuildPhase != "RELEASE") {
		worldStr += "# DEVELOPMENT BUILD -- " + version.devBuildPhase;
	}
	worldStr += "\n";
	/* FLAGS */
	for (f in flags) {
		worldStr += "! " + f + " " + flags[f] + "\n";
	}
	worldStr += "\n"
	/* FONT */
	if (fontName != defaultFontName) {
		worldStr += "DEFAULT_FONT " + fontName + "\n";
		worldStr += "\n"
	}
	if (textDirection != TextDirection.LeftToRight) {
		worldStr += "TEXT_DIRECTION " + textDirection + "\n";
		worldStr += "\n"
	}
	/* PALETTE */
	for (id in palette) {
		if (id != "default") {
			worldStr += "PAL " + id + "\n";
			for (i in getPal(id)) {
				for (j in getPal(id)[i]) {
					worldStr += getPal(id)[i][j];
					if (j < 2) worldStr += ",";
				}
				worldStr += "\n";
			}
			if (palette[id].name != null) {
				worldStr += "NAME " + palette[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* ROOM */
	for (id in room) {
		worldStr += "ROOM " + id + "\n";
		if ( flags.ROOM_FORMAT == 0 ) {
			// old non-comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];	
				}
				worldStr += "\n";
			}
		}
		else if ( flags.ROOM_FORMAT == 1 ) {
			// new comma separated format
			for (i in room[id].tilemap) {
				for (j in room[id].tilemap[i]) {
					worldStr += room[id].tilemap[i][j];
					if (j < room[id].tilemap[i].length-1) worldStr += ","
				}
				worldStr += "\n";
			}
		}
		if (room[id].name != null) {
			/* NAME */
			worldStr += "NAME " + room[id].name + "\n";
		}
		if (room[id].walls.length > 0) {
			/* WALLS */
			worldStr += "WAL ";
			for (j in room[id].walls) {
				worldStr += room[id].walls[j];
				if (j < room[id].walls.length-1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		if (room[id].items.length > 0) {
			/* ITEMS */
			for (j in room[id].items) {
				var itm = room[id].items[j];
				worldStr += "ITM " + itm.id + " " + itm.x + "," + itm.y;
				worldStr += "\n";
			}
		}
		if (room[id].exits.length > 0) {
			/* EXITS */
			for (j in room[id].exits) {
				var e = room[id].exits[j];
				if ( isExitValid(e) ) {
					worldStr += "EXT " + e.x + "," + e.y + " " + e.dest.room + " " + e.dest.x + "," + e.dest.y;
					if (e.transition_effect != undefined && e.transition_effect != null) {
						worldStr += " FX " + e.transition_effect;
					}
					if (e.dlg != undefined && e.dlg != null) {
						worldStr += " DLG " + e.dlg;
					}
					worldStr += "\n";
				}
			}
		}
		if (room[id].endings.length > 0) {
			/* ENDINGS */
			for (j in room[id].endings) {
				var e = room[id].endings[j];
				// todo isEndingValid
				worldStr += "END " + e.id + " " + e.x + "," + e.y;
				worldStr += "\n";
			}
		}
		if (room[id].pal != null && room[id].pal != "default") {
			/* PALETTE */
			worldStr += "PAL " + room[id].pal + "\n";
		}
		if (room[id].ava != null) {
			/* AVATAR SPRITE */
			worldStr += "AVA " + room[id].ava + "\n";
		}
		if (room[id].tune != null && room[id].tune != "0") {
			/* TUNE */
			worldStr += "TUNE " + room[id].tune + "\n";
		}
		worldStr += "\n";
	}
	/* TILES */
	for (id in tile) {
		worldStr += "TIL " + id + "\n";
		worldStr += serializeDrawing( "TIL_" + id );
		if (tile[id].name != null && tile[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + tile[id].name + "\n";
		}
		if (tile[id].isWall != null && tile[id].isWall != undefined) {
			/* WALL */
			worldStr += "WAL " + tile[id].isWall + "\n";
		}
		if (tile[id].col != null && tile[id].col != undefined && tile[id].col != 1) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + tile[id].col + "\n";
		}
		if (tile[id].bgc != null && tile[id].bgc != undefined && tile[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (tile[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + tile[id].bgc + "\n";
			}
		}
		worldStr += "\n";
	}
	/* SPRITES */
	for (id in sprite) {
		worldStr += "SPR " + id + "\n";
		worldStr += serializeDrawing( "SPR_" + id );
		if (sprite[id].name != null && sprite[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + sprite[id].name + "\n";
		}
		if (sprite[id].dlg != null) {
			worldStr += "DLG " + sprite[id].dlg + "\n";
		}
		if (sprite[id].room != null) {
			/* SPRITE POSITION */
			worldStr += "POS " + sprite[id].room + " " + sprite[id].x + "," + sprite[id].y + "\n";
		}
		if (sprite[id].inventory != null) {
			for(itemId in sprite[id].inventory) {
				worldStr += "ITM " + itemId + " " + sprite[id].inventory[itemId] + "\n";
			}
		}
		if (sprite[id].col != null && sprite[id].col != undefined && sprite[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + sprite[id].col + "\n";
		}
		if (sprite[id].bgc != null && sprite[id].bgc != undefined && sprite[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (sprite[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + sprite[id].bgc + "\n";
			}
		}
		if (sprite[id].blip != null && sprite[id].blip != undefined) {
			/* BLIP */
			worldStr += "BLIP " + sprite[id].blip + "\n";
		}
		worldStr += "\n";
	}
	/* ITEMS */
	for (id in item) {
		worldStr += "ITM " + id + "\n";
		worldStr += serializeDrawing( "ITM_" + id );
		if (item[id].name != null && item[id].name != undefined) {
			/* NAME */
			worldStr += "NAME " + item[id].name + "\n";
		}
		if (item[id].dlg != null) {
			worldStr += "DLG " + item[id].dlg + "\n";
		}
		if (item[id].col != null && item[id].col != undefined && item[id].col != 2) {
			/* COLOR OVERRIDE */
			worldStr += "COL " + item[id].col + "\n";
		}
		if (item[id].bgc != null && item[id].bgc != undefined && item[id].bgc != 0) {
			/* BACKGROUND COLOR OVERRIDE */
			if (item[id].bgc < 0) {
				// transparent background
				worldStr += "BGC *\n";
			}
			else {
				worldStr += "BGC " + item[id].bgc + "\n";
			}
		}
		if (item[id].blip != null && item[id].blip != undefined) {
			/* BLIP */
			worldStr += "BLIP " + item[id].blip + "\n";
		}
		worldStr += "\n";
	}
	/* DIALOG */
	for (id in dialog) {
		if (id != titleDialogId) {
			worldStr += "DLG " + id + "\n";
			worldStr += dialog[id].src + "\n";
			if (dialog[id].name != null) {
				worldStr += "NAME " + dialog[id].name + "\n";
			}
			worldStr += "\n";
		}
	}
	/* ENDINGS (for backwards compability only) */
	for (id in end) {
		worldStr += "END " + id + "\n";
		worldStr += end[id].src + "\n";
		worldStr += "\n";
	}
	/* VARIABLES */
	for (id in variable) {
		worldStr += "VAR " + id + "\n";
		worldStr += variable[id] + "\n";
		worldStr += "\n";
	}
	/* TUNES */
	for (id in tune) {
		if (id === "0") {
			continue;
		}

		worldStr += "TUNE " + id + "\n";
		for (var i = 0; i < maxTuneLength && i < tune[id].melody.length; i++) {
			// MELODY
			for (var j = 0; j < barLength; j++) {
				var noteStr = serializeNote(tune[id].melody[i][j].note, tune[id].key);
				if (noteStr === null) {
					tune[id].melody[i][j].beats = 0;
				}
				if (tune[id].melody[i][j].beats != 1) {
					worldStr += tune[id].melody[i][j].beats;
				}
				if (tune[id].melody[i][j].beats > 0) {
					worldStr += noteStr;
				}
				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].octave != Octave[4]) {
					worldStr += serializeOctave(tune[id].melody[i][j].octave);
				}
				if (tune[id].melody[i][j].beats > 0 && tune[id].melody[i][j].blip != undefined) {
					// todo : create constant for the blip separator?
					worldStr += "~" + tune[id].melody[i][j].blip;
				}
				if (j < 15) {
					worldStr += ",";
				}
			}
			worldStr += "\n";

			// HARMONY
			// todo : lots of copy-pasting - I could probably make some helper functions to simplify this
			for (var j = 0; j < barLength; j++) {
				var noteStr = serializeNote(tune[id].harmony[i][j].note, tune[id].key);
				if (noteStr === null) {
					tune[id].harmony[i][j].beats = 0;
				}
				if (tune[id].harmony[i][j].beats != 1) {
					worldStr += tune[id].harmony[i][j].beats;
				}
				if (tune[id].harmony[i][j].beats > 0) {
					worldStr += noteStr;
				}
				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].octave != Octave[4]) {
					worldStr += serializeOctave(tune[id].harmony[i][j].octave);
				}
				if (tune[id].harmony[i][j].beats > 0 && tune[id].harmony[i][j].blip != undefined) {
					worldStr += "~" + tune[id].harmony[i][j].blip;
				}
				if (j < 15) {
					worldStr += ",";
				}
			}
			worldStr += "\n";

			if (i < (tune[id].melody.length - 1)) {
				worldStr += ">";
				worldStr += "\n";
			}
		}
		if (tune[id].name != null) {
			/* NAME */
			worldStr += "NAME " + tune[id].name + "\n";
		}
		if (tune[id].key != undefined && tune[id].key != null) {
			worldStr += "KEY ";
			for (var i = 0; i < Solfa.COUNT; i++) {
				worldStr += serializeNote(tune[id].key.notes[i]);
				if (i < Solfa.COUNT - 1) {
					worldStr += ",";
				}
			}
			worldStr += " ";
			for (var i = 0; i < tune[id].key.scale.length; i++) {
				worldStr += serializeNote(tune[id].key.scale[i], tune[id].key);
				if (i < tune[id].key.scale.length - 1) {
					worldStr += ",";
				}
			}
			worldStr += "\n";
		}
		worldStr += "TMP ";
		switch (tune[id].tempo) {
			case Tempo.SLW:
				worldStr += "SLW";
				break;
			case Tempo.MED:
				worldStr += "MED";
				break;
			case Tempo.FST:
				worldStr += "FST";
				break;
			case Tempo.XFST:
				worldStr += "XFST";
				break;
		}
		worldStr += "\n";
		worldStr += "SQR ";
		switch (tune[id].instrumentA) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += " ";
		switch (tune[id].instrumentB) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += "\n";
		if (tune[id].key != undefined && tune[id].key != null && tune[id].arpeggioPattern != ArpeggioPattern.OFF) {
			switch (tune[id].arpeggioPattern) {
				case ArpeggioPattern.UP:
					worldStr += "ARP UP\n";
					break;
				case ArpeggioPattern.DWN:
					worldStr += "ARP DWN\n";
					break;
				case ArpeggioPattern.INT5:
					worldStr += "ARP INT5\n";
					break;
				case ArpeggioPattern.INT8:
					worldStr += "ARP INT8\n";
					break;
			}
		}
		worldStr += "\n";
	}
	/* BLIP */
	for (id in blip) {
		if (id === "0") {
			continue;
		}

		worldStr += "BLIP " + id + "\n";
		// pitches
		if (blip[id].pitchA.beats > 0) {
			worldStr += serializeNote(blip[id].pitchA.note);
			if (blip[id].pitchA.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchA.octave);
			}
		}
		else {
			worldStr += blip[id].pitchA.beats;
		}
		worldStr += ",";
		if (blip[id].pitchB.beats > 0) {
			worldStr += serializeNote(blip[id].pitchB.note);
			if (blip[id].pitchB.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchB.octave);
			}
		}
		else {
			worldStr += blip[id].pitchB.beats;
		}
		worldStr += ",";
		if (blip[id].pitchC.beats > 0) {
			worldStr += serializeNote(blip[id].pitchC.note);
			if (blip[id].pitchC.octave != Octave[4]) {
				worldStr += serializeOctave(blip[id].pitchC.octave);
			}
		}
		else {
			worldStr += blip[id].pitchC.beats;
		}
		worldStr += "\n";
		if (blip[id].name != null) {
			/* NAME */
			worldStr += "NAME " + blip[id].name + "\n";
		}
		// envelope
		worldStr += "ENV " + blip[id].envelope.attack
			+ " " + blip[id].envelope.decay
			+ " " + blip[id].envelope.sustain
			+ " " + blip[id].envelope.length
			+ " " + blip[id].envelope.release + "\n";
		// beat
		worldStr += "BEAT " + blip[id].beat.time
			+ " " + blip[id].beat.delay + "\n";
		// instrument (square wave type)
		worldStr += "SQR ";
		switch (blip[id].instrument) {
			case SquareWave.P8:
				worldStr += "P8";
				break;
			case SquareWave.P4:
				worldStr += "P4";
				break;
			case SquareWave.P2:
				worldStr += "P2";
				break;
		}
		worldStr += "\n";
		// other parameters
		if (blip[id].doRepeat === true) {
			worldStr += "RPT 1\n";
		}
		// TODO : consider for future update
		// if (blip[id].doSlide === true) {
		// 	worldStr += "SLD 1\n";
		// }
		worldStr += "\n";
	}
	/* FONT */
	// TODO : support multiple fonts
	if (fontManager && fontName != defaultFontName && !skipFonts) {
		worldStr += fontManager.GetData(fontName);
	}

	return worldStr;
}

function serializeDrawing(drwId) {
	if (!renderer) {
		return "";
	}

	var drawingData = renderer.GetDrawingSource(drwId);
	var drwStr = "";
	for (f in drawingData) {
		for (y in drawingData[f]) {
			var rowStr = "";
			for (x in drawingData[f][y]) {
				rowStr += drawingData[f][y][x];
			}
			drwStr += rowStr + "\n";
		}
		if (f < (drawingData.length-1)) drwStr += ">\n";
	}
	return drwStr;
}

function isExitValid(e) {
	var hasValidStartPos = e.x >= 0 && e.x < bitsy.MAP_SIZE && e.y >= 0 && e.y < bitsy.MAP_SIZE;
	var hasDest = e.dest != null;
	var hasValidRoomDest = (e.dest.room != null && e.dest.x >= 0 && e.dest.x < bitsy.MAP_SIZE && e.dest.y >= 0 && e.dest.y < bitsy.MAP_SIZE);
	return hasValidStartPos && hasDest && hasValidRoomDest;
}

function setTile(mapId, x, y, tileId) {
	bitsy.set(mapId, (y * bitsy.MAP_SIZE) + x, tileId);
}

function drawTile(tileId, x, y) {
	setTile(bitsy.MAP1, x, y, tileId);
}

function drawSprite(tileId, x, y) {
	setTile(bitsy.MAP2, x, y, tileId);
}

function drawItem(tileId, x, y) {
	setTile(bitsy.MAP2, x, y, tileId);
}

// var debugLastRoomDrawn = "0";

function clearRoom() {
	var paletteId = "default";

	if (room === undefined) {
		// protect against invalid rooms
		return;
	}

	if (room.pal != null && palette[paletteId] != undefined) {
		paletteId = room.pal;
	}

	// clear background & foreground
	bitsy.fill(bitsy.MAP1, 0);
	bitsy.fill(bitsy.MAP2, 0);
}

function drawRoomBackground(room, frameIndex, redrawAnimatedOnly) {
	if (!redrawAnimatedOnly) {
		// clear background map
		bitsy.fill(bitsy.MAP1, 0);
	}

	// NOTE: interestingly the slowest part of this is iterating over all the tiles, not actually drawing them
	for (var y = 0; y < bitsy.MAP_SIZE; y++) {
		for (var x = 0; x < bitsy.MAP_SIZE; x++) {
			var id = room.tilemap[y][x];

			if (id != "0" && tile[id] == null) { // hack-around to avoid corrupting files (not a solution though!)
				id = "0";
				room.tilemap[y][x] = id;
			}

			if (id != "0" && (!redrawAnimatedOnly || tile[id].animation.isAnimated)) {
				drawTile(getTileFrame(tile[id], frameIndex), x, y);
			}
		}
	}
}

function drawRoomForeground(room, frameIndex, redrawAnimatedOnly) {
	if (!redrawAnimatedOnly) {
		// clear foreground map
		bitsy.fill(bitsy.MAP2, 0);
	}

	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		if (!redrawAnimatedOnly || item[itm.id].animation.isAnimated) {
			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
		}
	}

	// draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (id != playerId && spr.room === room.id && (!redrawAnimatedOnly || spr.animation.isAnimated)) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

function drawRoomForegroundTile(room, frameIndex, x, y) {
	// draw items
	for (var i = 0; i < room.items.length; i++) {
		var itm = room.items[i];
		if (itm.x === x && itm.y === y) {
			drawItem(getItemFrame(item[itm.id], frameIndex), itm.x, itm.y);
		}
	}

	// draw sprites
	for (id in sprite) {
		var spr = sprite[id];
		if (id != playerId && spr.room === room.id && spr.x === x && spr.y === y) {
			drawSprite(getSpriteFrame(spr, frameIndex), spr.x, spr.y);
		}
	}
}

function drawRoom(room, args) {
	if (room === undefined || isNarrating) {
		// protect against invalid rooms
		return;
	}

	var redrawAll = args && (args.redrawAll === true);
	var redrawAnimated = args && (args.redrawAnimated === true);
	var redrawAvatar = args && (args.redrawAvatar === true);
	var frameIndex = args ? args.frameIndex : undefined;

	// if *only* redrawing the avatar, first clear its previous position
	if (redrawAvatar) {
		setTile(bitsy.MAP2, playerPrevX, playerPrevY, 0);
		// also redraw any sprite or item that might be "under" the player (todo: possible perf issue?)
		drawRoomForegroundTile(room, frameIndex, playerPrevX, playerPrevY);
	}

	// draw background & foreground tiles
	if (redrawAll || redrawAnimated) {
		// draw tiles
		drawRoomBackground(room, frameIndex, redrawAnimated);
		// draw sprites & items
		drawRoomForeground(room, frameIndex, redrawAnimated);
	}

	// draw the player's avatar at its current position
	if ((redrawAll || redrawAnimated || redrawAvatar) && sprite[playerId] && sprite[playerId].room === room.id) {
		var spr = sprite[playerId];
		var x = spr.x;
		var y = spr.y;

		// get the avatar override sprite (if there is one)
		if (state.ava && state.ava != playerId && sprite[state.ava]) {
			spr = sprite[state.ava];
		}

		drawSprite(getSpriteFrame(spr, frameIndex), x, y);
	}
}

// TODO : remove these get*Image methods
function getTileFrame(t, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(t, frameIndex);
}

function getSpriteFrame(s, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(s, frameIndex);
}

function getItemFrame(itm, frameIndex) {
	if (!renderer) {
		return null;
	}
	return renderer.GetDrawingFrame(itm, frameIndex);
}

function curDefaultPal() {
	return getRoomPal(state.room);
}

function getRoomPal(roomId) {
	var defaultId = "default";

	if (roomId == null) {
		return defaultId;
	}
	else if (room[roomId].pal != null) {
		//a specific palette was chosen
		return room[roomId].pal;
	}
	else {
		if (roomId in palette) {
			//there is a palette matching the name of the room
			return roomId;
		}
		else {
			//use the default palette
			return defaultId;
		}
	}
	return defaultId;
}

var isDialogMode = false;
var isNarrating = false;
var isEnding = false;

var dialogModule;
var dialogRenderer;
var dialogBuffer;
if (engineFeatureFlags.isDialogEnabled) {
	dialogModule = new Dialog();
	dialogRenderer = dialogModule.CreateRenderer();
	dialogBuffer = dialogModule.CreateBuffer();
}

var fontManager;
if (engineFeatureFlags.isFontEnabled) {
	fontManager = new FontManager();
}

// TODO : is this scriptResult thing being used anywhere???
function onExitDialog(scriptResult, dialogCallback) {
	isDialogMode = false;
	bitsy.textbox(false);

	if (isNarrating) {
		isNarrating = false;

		// redraw the room
		drawRoom(room[state.room], { redrawAll: true });
	}

	if (isDialogPreview) {
		isDialogPreview = false;

		if (onDialogPreviewEnd != null) {
			onDialogPreviewEnd();
		}
	}

	if (dialogCallback != undefined && dialogCallback != null) {
		dialogCallback(scriptResult);
	}

	if (soundPlayer) {
		soundPlayer.resumeTune();
	}
}

/*
TODO
- titles and endings should also take advantage of the script pre-compilation if possible??
- could there be a namespace collision?
- what about dialog NAMEs vs IDs?
- what about a special script block separate from DLG?
*/
function startNarrating(dialogStr, end) {
	bitsy.log("NARRATE " + dialogStr);

	if(end === undefined) {
		end = false;
	}

	isNarrating = true;
	isEnding = end;

	if (isEnding && soundPlayer) {
		soundPlayer.stopTune();
	}

	// clear the room tiles before narrating
	bitsy.fill(bitsy.MAP1, 0);
	bitsy.fill(bitsy.MAP2, 0);

	startDialog(dialogStr);
}

function startEndingDialog(ending) {
	isNarrating = true;
	isEnding = true;

	var endingScriptId = ending.id;
	var endingDialogStr = dialog[ending.id].src;

	// compatibility with pre-7.0 endings
	if (flags.DLG_COMPAT === 1 && end[ending.id]) {
		endingScriptId = "end_compat_" + ending.id;
		endingDialogStr = end[ending.id].src;
	}

	var tmpTuneId = null;
	if (isEnding && soundPlayer) {
		tmpTuneId = soundPlayer.getCurTuneId();
		soundPlayer.stopTune();
	}

	startDialog(
		endingDialogStr,
		endingScriptId,
		function() {
			var isLocked = ending.property && ending.property.locked === true;
			if (isLocked) {
				isEnding = false;

				// if the ending was cancelled, restart the music
				// todo : should it resume from where it started? (right now it starts over)
				if (tmpTuneId && soundPlayer && !soundPlayer.isTunePlaying()) {
					soundPlayer.playTune(tune[tmpTuneId]);
				}
			}
		},
		ending);
}

function startItemDialog(itemId, dialogCallback) {
	var dialogId = item[itemId].dlg;
	// bitsy.log("START ITEM DIALOG " + dialogId);
	if (dialog[dialogId]) {
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId, dialogCallback);
	}
	else {
		dialogCallback();
	}
}

function startSpriteDialog(spriteId) {
	var spr = sprite[spriteId];
	var dialogId = spr.dlg;

	// back compat for when dialog IDs were implicitly the same as sprite IDs
	if (flags.DLG_COMPAT === 1 && (dialogId === undefined || dialogId === null)) {
		dialogId = spr.id;
	}

	// bitsy.log("START SPRITE DIALOG " + dialogId);
	if (dialog[dialogId]){
		var dialogStr = dialog[dialogId].src;
		startDialog(dialogStr, dialogId);
	}
}

function startDialog(dialogStr, scriptId, dialogCallback, objectContext) {
	bitsy.log("START DIALOG");

	if (soundPlayer) {
		soundPlayer.pauseTune();
	}

	if (dialogStr.length <= 0) {
		onExitDialog(null, dialogCallback);
		return;
	}

	if (!dialogBuffer) {
		bitsy.log(dialogStr);
		onExitDialog(null, dialogCallback);
		return;
	}

	if (!scriptInterpreter) {
		dialogRenderer.Reset();
		dialogRenderer.SetCentered(isNarrating /*centered*/);
		dialogBuffer.Reset();
		dialogBuffer.AddText(dialogStr);
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(null, dialogCallback);
		});
		bitsy.log("dialog start end");
		return;
	};

	isDialogMode = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(isNarrating /*centered*/);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	var onScriptEnd = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, dialogCallback);
		});
	};

	if (scriptId === undefined) { // TODO : what's this for again?
		scriptInterpreter.Interpret(dialogStr, onScriptEnd);
	}
	else {
		if (!scriptInterpreter.HasScript(scriptId)) {
			scriptInterpreter.Compile(scriptId, dialogStr);
		}
		// scriptInterpreter.DebugVisualizeScript(scriptId);
		scriptInterpreter.Run(scriptId, onScriptEnd, objectContext);
	}

}

var isDialogPreview = false;
function startPreviewDialog(script, dialogCallback) {
	if (!scriptInterpreter || !dialogBuffer) {
		return;
	}

	isNarrating = true;

	isDialogMode = true;

	isDialogPreview = true;

	dialogRenderer.Reset();
	dialogRenderer.SetCentered(true);
	dialogBuffer.Reset();
	scriptInterpreter.SetDialogBuffer(dialogBuffer);

	// TODO : do I really need a seperate callback for this debug mode??
	onDialogPreviewEnd = dialogCallback;

	var onScriptEndCallback = function(scriptResult) {
		dialogBuffer.OnDialogEnd(function() {
			onExitDialog(scriptResult, null);
		});
	};

	scriptInterpreter.Eval(script, onScriptEndCallback);
}

/* NEW SCRIPT STUFF */
var scriptModule;
var scriptInterpreter;
var scriptUtils;
// scriptInterpreter.SetDialogBuffer( dialogBuffer );
if (engineFeatureFlags.isScriptEnabled) {
	bitsy.log("init script module");
	scriptModule = new Script();
	bitsy.log("init interpreter");
	scriptInterpreter = scriptModule.CreateInterpreter();
	bitsy.log("init utils");
	scriptUtils = scriptModule.CreateUtils(); // TODO: move to editor.js?
	bitsy.log("init script module end");
}

/* SOUND */
var soundPlayer;
if (engineFeatureFlags.isSoundEnabled) {
	soundPlayer = new SoundPlayer();
}

/* EVENTS */
bitsy.loop(update);
</script>

<!-- store default font in separate script tag for back compat-->
<script type="text/bitsyFontData" id="ascii_small">
FONT ascii_small
SIZE 6 8
CHAR 0
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 32
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 33
000100
001110
001110
000100
000100
000000
000100
000000
CHAR 34
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 8220
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 8221
011011
011011
010010
000000
000000
000000
000000
000000
CHAR 35
000000
001010
011111
001010
001010
011111
001010
000000
CHAR 36
001000
001110
010000
001100
000010
011100
000100
000000
CHAR 37
011001
011001
000010
000100
001000
010011
010011
000000
CHAR 38
001000
010100
010100
001000
010101
010010
001101
000000
CHAR 39
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 8216
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 8217
001100
001100
001000
000000
000000
000000
000000
000000
CHAR 40
000100
001000
001000
001000
001000
001000
000100
000000
CHAR 41
001000
000100
000100
000100
000100
000100
001000
000000
CHAR 42
000000
001010
001110
011111
001110
001010
000000
000000
CHAR 43
000000
000100
000100
011111
000100
000100
000000
000000
CHAR 44
000000
000000
000000
000000
000000
001100
001100
001000
CHAR 45
000000
000000
000000
011111
000000
000000
000000
000000
CHAR 46
000000
000000
000000
000000
000000
001100
001100
000000
CHAR 47
000000
000001
000010
000100
001000
010000
000000
000000
CHAR 48
001110
010001
010011
010101
011001
010001
001110
000000
CHAR 49
000100
001100
000100
000100
000100
000100
001110
000000
CHAR 50
001110
010001
000001
000110
001000
010000
011111
000000
CHAR 51
001110
010001
000001
001110
000001
010001
001110
000000
CHAR 52
000010
000110
001010
010010
011111
000010
000010
000000
CHAR 53
011111
010000
010000
011110
000001
010001
001110
000000
CHAR 54
000110
001000
010000
011110
010001
010001
001110
000000
CHAR 55
011111
000001
000010
000100
001000
001000
001000
000000
CHAR 56
001110
010001
010001
001110
010001
010001
001110
000000
CHAR 57
001110
010001
010001
001111
000001
000010
001100
000000
CHAR 58
000000
000000
001100
001100
000000
001100
001100
000000
CHAR 59
000000
000000
001100
001100
000000
001100
001100
001000
CHAR 60
000010
000100
001000
010000
001000
000100
000010
000000
CHAR 61
000000
000000
011111
000000
000000
011111
000000
000000
CHAR 62
001000
000100
000010
000001
000010
000100
001000
000000
CHAR 63
001110
010001
000001
000110
000100
000000
000100
000000
CHAR 64
001110
010001
010111
010101
010111
010000
001110
000000
CHAR 65
001110
010001
010001
010001
011111
010001
010001
000000
CHAR 66
011110
010001
010001
011110
010001
010001
011110
000000
CHAR 67
001110
010001
010000
010000
010000
010001
001110
000000
CHAR 68
011110
010001
010001
010001
010001
010001
011110
000000
CHAR 69
011111
010000
010000
011110
010000
010000
011111
000000
CHAR 70
011111
010000
010000
011110
010000
010000
010000
000000
CHAR 71
001110
010001
010000
010111
010001
010001
001111
000000
CHAR 72
010001
010001
010001
011111
010001
010001
010001
000000
CHAR 73
001110
000100
000100
000100
000100
000100
001110
000000
CHAR 74
000001
000001
000001
000001
010001
010001
001110
000000
CHAR 75
010001
010010
010100
011000
010100
010010
010001
000000
CHAR 76
010000
010000
010000
010000
010000
010000
011111
000000
CHAR 77
010001
011011
010101
010001
010001
010001
010001
000000
CHAR 78
010001
011001
010101
010011
010001
010001
010001
000000
CHAR 79
001110
010001
010001
010001
010001
010001
001110
000000
CHAR 80
011110
010001
010001
011110
010000
010000
010000
000000
CHAR 81
001110
010001
010001
010001
010101
010010
001101
000000
CHAR 82
011110
010001
010001
011110
010010
010001
010001
000000
CHAR 83
001110
010001
010000
001110
000001
010001
001110
000000
CHAR 84
011111
000100
000100
000100
000100
000100
000100
000000
CHAR 85
010001
010001
010001
010001
010001
010001
001110
000000
CHAR 86
010001
010001
010001
010001
010001
001010
000100
000000
CHAR 87
010001
010001
010101
010101
010101
010101
001010
000000
CHAR 88
010001
010001
001010
000100
001010
010001
010001
000000
CHAR 89
010001
010001
010001
001010
000100
000100
000100
000000
CHAR 90
011110
000010
000100
001000
010000
010000
011110
000000
CHAR 91
001110
001000
001000
001000
001000
001000
001110
000000
CHAR 92
000000
010000
001000
000100
000010
000001
000000
000000
CHAR 93
001110
000010
000010
000010
000010
000010
001110
000000
CHAR 94
000100
001010
010001
000000
000000
000000
000000
000000
CHAR 95
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 96
001100
001100
000100
000000
000000
000000
000000
000000
CHAR 97
000000
000000
001110
000001
001111
010001
001111
000000
CHAR 98
010000
010000
011110
010001
010001
010001
011110
000000
CHAR 99
000000
000000
001110
010001
010000
010001
001110
000000
CHAR 100
000001
000001
001111
010001
010001
010001
001111
000000
CHAR 101
000000
000000
001110
010001
011110
010000
001110
000000
CHAR 102
000110
001000
001000
011110
001000
001000
001000
000000
CHAR 103
000000
000000
001111
010001
010001
001111
000001
001110
CHAR 104
010000
010000
011100
010010
010010
010010
010010
000000
CHAR 105
000100
000000
000100
000100
000100
000100
000110
000000
CHAR 106
000010
000000
000110
000010
000010
000010
010010
001100
CHAR 107
010000
010000
010010
010100
011000
010100
010010
000000
CHAR 108
000100
000100
000100
000100
000100
000100
000110
000000
CHAR 109
000000
000000
011010
010101
010101
010001
010001
000000
CHAR 110
000000
000000
011100
010010
010010
010010
010010
000000
CHAR 111
000000
000000
001110
010001
010001
010001
001110
000000
CHAR 112
000000
000000
011110
010001
010001
010001
011110
010000
CHAR 113
000000
000000
001111
010001
010001
010001
001111
000001
CHAR 114
000000
000000
010110
001001
001000
001000
011100
000000
CHAR 115
000000
000000
001110
010000
001110
000001
001110
000000
CHAR 116
000000
001000
011110
001000
001000
001010
000100
000000
CHAR 117
000000
000000
010010
010010
010010
010110
001010
000000
CHAR 118
000000
000000
010001
010001
010001
001010
000100
000000
CHAR 119
000000
000000
010001
010001
010101
011111
001010
000000
CHAR 120
000000
000000
010010
010010
001100
010010
010010
000000
CHAR 121
000000
000000
010010
010010
010010
001110
000100
011000
CHAR 122
000000
000000
011110
000010
001100
010000
011110
000000
CHAR 123
000110
001000
001000
011000
001000
001000
000110
000000
CHAR 124
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 125
001100
000010
000010
000011
000010
000010
001100
000000
CHAR 126
000000
000000
000000
001010
010100
000000
000000
000000
CHAR 160
000000
000000
000000
000000
000000
000000
000000
000000
CHAR 161
000100
000000
000100
000100
001110
001110
000100
000000
CHAR 162
000000
000100
001110
010000
010000
001110
000100
000000
CHAR 163
000110
001001
001000
011110
001000
001001
010111
000000
CHAR 165
010001
001010
000100
011111
000100
011111
000100
000000
CHAR 167
001110
010001
001100
001010
000110
010001
001110
000000
CHAR 171
000000
000000
001001
010010
001001
000000
000000
000000
CHAR 172
000000
000000
111111
000001
000001
000000
000000
000000
CHAR 177
000000
000100
001110
000100
000000
001110
000000
000000
CHAR 178
011000
000100
001000
011100
000000
000000
000000
000000
CHAR 181
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 182
001111
010101
010101
001101
000101
000101
000101
000000
CHAR 187
000000
000000
010010
001001
010010
000000
000000
000000
CHAR 188
010000
010010
010100
001011
010101
000111
000001
000000
CHAR 189
010000
010010
010100
001110
010001
000010
000111
000000
CHAR 191
000100
000000
000100
001100
010000
010001
001110
000000
CHAR 196
001010
000000
000100
001010
010001
011111
010001
000000
CHAR 197
001110
001010
001110
011011
010001
011111
010001
000000
CHAR 198
001111
010100
010100
011111
010100
010100
010111
000000
CHAR 199
001110
010001
010000
010000
010001
001110
000100
001100
CHAR 201
000011
000000
011111
010000
011110
010000
011111
000000
CHAR 209
001010
010100
000000
010010
011010
010110
010010
000000
CHAR 214
010010
001100
010010
010010
010010
010010
001100
000000
CHAR 220
001010
000000
010010
010010
010010
010010
001100
000000
CHAR 223
000000
011100
010010
011100
010010
010010
011100
010000
CHAR 224
001100
000000
001110
000001
001111
010001
001111
000000
CHAR 225
000110
000000
001110
000001
001111
010001
001111
000000
CHAR 226
001110
000000
001110
000001
001111
010001
001111
000000
CHAR 228
001010
000000
001110
000001
001111
010001
001111
000000
CHAR 229
001110
001010
001110
000001
001111
010001
001111
000000
CHAR 230
000000
000000
011110
000101
011111
010100
001111
000000
CHAR 231
000000
001110
010001
010000
010001
001110
000100
001100
CHAR 232
001100
000000
001110
010001
011110
010000
001110
000000
CHAR 233
000011
000000
001110
010001
011110
010000
001110
000000
CHAR 234
001110
000000
001110
010001
011110
010000
001110
000000
CHAR 235
001010
000000
001110
010001
011110
010000
001110
000000
CHAR 236
001000
000000
000100
000100
000100
000100
000110
000000
CHAR 237
000110
000000
000100
000100
000100
000100
000110
000000
CHAR 238
000100
001010
000000
000100
000100
000100
000110
000000
CHAR 239
001010
000000
000100
000100
000100
000100
000110
000000
CHAR 241
001010
010100
000000
011100
010010
010010
010010
000000
CHAR 242
011000
000000
001100
010010
010010
010010
001100
000000
CHAR 243
000110
000000
001100
010010
010010
010010
001100
000000
CHAR 244
001110
000000
001100
010010
010010
010010
001100
000000
CHAR 246
001010
000000
001100
010010
010010
010010
001100
000000
CHAR 247
001010
000000
001110
010001
010001
010001
001110
000000
CHAR 249
011000
000000
010010
010010
010010
010110
001010
000000
CHAR 250
000110
000000
010010
010010
010010
010110
001010
000000
CHAR 251
001110
000000
010010
010010
010010
010110
001010
000000
CHAR 252
010010
000000
010010
010010
010010
010110
001010
000000
CHAR 255
001010
000000
010010
010010
010010
001110
000100
011000
CHAR 402
000010
000101
000100
001110
000100
000100
010100
001000
CHAR 915
011110
010010
010000
010000
010000
010000
010000
000000
CHAR 920
001100
010010
010010
011110
010010
010010
001100
000000
CHAR 931
011111
010000
001000
000100
001000
010000
011111
000000
CHAR 934
001110
000100
001110
010001
001110
000100
001110
000000
CHAR 937
000000
001110
010001
010001
001010
001010
011011
000000
CHAR 948
001100
010000
001000
000100
001110
010010
001100
000000
CHAR 949
000000
001110
010000
011110
010000
001110
000000
000000
CHAR 960
000000
011111
001010
001010
001010
001010
001010
000000
CHAR 963
000000
000000
001111
010010
010010
001100
000000
000000
CHAR 964
000000
000000
001010
010100
000100
000100
000100
000000
CHAR 966
000000
000100
001110
010101
010101
001110
000100
000000
CHAR 8226
000000
000000
000000
001100
001100
000000
000000
000000
CHAR 8252
001010
001010
001010
001010
001010
000000
001010
000000
CHAR 8592
000000
000100
001100
011111
001100
000100
000000
000000
CHAR 8593
000100
001110
011111
000100
000100
000100
000100
000000
CHAR 8594
000000
000100
000110
011111
000110
000100
000000
000000
CHAR 8595
000100
000100
000100
000100
011111
001110
000100
000000
CHAR 8734
000000
000000
001010
010101
010101
001010
000000
000000
CHAR 8735
000000
000000
000000
010000
010000
010000
011111
000000
CHAR 8801
000000
011110
000000
011110
000000
011110
000000
000000
CHAR 8804
000010
001100
010000
001100
000010
000000
011110
000000
CHAR 8805
010000
001100
000010
001100
010000
000000
011110
000000
CHAR 8962
000100
001110
011011
010001
010001
011111
000000
000000
CHAR 8976
000000
000000
011111
010000
010000
010000
000000
000000
CHAR 9472
000000
000000
000000
111111
000000
000000
000000
000000
CHAR 9474
000100
000100
000100
000100
000100
000100
000100
000100
CHAR 9488
000000
000000
000000
111100
000100
000100
000100
000100
CHAR 9492
000100
000100
000100
000111
000000
000000
000000
000000
CHAR 9500
000100
000100
000100
000111
000100
000100
000100
000100
CHAR 9508
000100
000100
000100
111100
000100
000100
000100
000100
CHAR 9516
000000
000000
000000
111111
000100
000100
000100
000100
CHAR 9524
000100
000100
000100
111111
000000
000000
000000
000000
CHAR 9532
000100
000100
000100
111111
000100
000100
000100
000100
CHAR 9552
000000
111111
000000
111111
000000
000000
000000
000000
CHAR 9553
010100
010100
010100
010100
010100
010100
010100
010100
CHAR 9556
000000
011111
010000
010111
010100
010100
010100
010100
CHAR 9557
000000
111100
000100
111100
000100
000100
000100
000100
CHAR 9558
000000
000000
000000
111100
010100
010100
010100
010100
CHAR 9559
000000
111100
000100
110100
010100
010100
010100
010100
CHAR 9561
010100
010100
010100
011111
000000
000000
000000
000000
CHAR 9562
010100
010111
010000
011111
000000
000000
000000
000000
CHAR 9563
000100
111100
000100
111100
000000
000000
000000
000000
CHAR 9564
010100
010100
010100
111100
000000
000000
000000
000000
CHAR 9565
010100
110100
000100
111100
000000
000000
000000
000000
CHAR 9566
000100
000111
000100
000111
000100
000100
000100
000100
CHAR 9567
010100
010100
010100
010111
010100
010100
010100
010100
CHAR 9568
010100
010111
010000
010111
010100
010100
010100
010100
CHAR 9569
000000
000000
010010
010010
010010
011100
010000
010000
CHAR 9570
010100
010100
010100
110100
010100
010100
010100
010100
CHAR 9571
010100
110100
000100
110100
010100
010100
010100
010100
CHAR 9572
000000
111111
000000
111111
000100
000100
000100
000100
CHAR 9573
000000
000000
000000
111111
010100
010100
010100
010100
CHAR 9574
000000
111111
000000
110111
010100
010100
010100
010100
CHAR 9575
000100
111111
000000
111111
000000
000000
000000
000000
CHAR 9576
010100
010100
010100
111111
000000
000000
000000
000000
CHAR 9577
010100
110111
000000
111111
000000
000000
000000
000000
CHAR 9580
010100
110111
000000
110111
010100
010100
010100
010100
CHAR 9601
000000
000000
000000
000000
000000
000000
000000
111111
CHAR 9602
000000
000000
000000
000000
000000
000000
111111
111111
CHAR 9603
000000
000000
000000
000000
000000
111111
111111
111111
CHAR 9604
000000
000000
000000
000000
111111
111111
111111
111111
CHAR 9605
000000
000000
000000
111111
111111
111111
111111
111111
CHAR 9606
000000
000000
111111
111111
111111
111111
111111
111111
CHAR 9607
000000
111111
111111
111111
111111
111111
111111
111111
CHAR 9608
111111
111111
111111
111111
111111
111111
111111
111111
CHAR 9609
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9610
111100
111100
111100
111100
111100
111100
111100
111100
CHAR 9611
111000
111000
111000
111000
111000
111000
111000
111000
CHAR 9613
110000
110000
110000
110000
110000
110000
110000
110000
CHAR 9615
100000
100000
100000
100000
100000
100000
100000
100000
CHAR 9617
010101
000000
101010
000000
010101
000000
101010
000000
CHAR 9618
010101
101010
010101
101010
010101
101010
010101
101010
CHAR 9619
101010
111111
010101
111111
101010
111111
010101
111111
CHAR 9644
000000
000000
000000
000000
000000
011110
011110
000000
CHAR 9650
000100
000100
001110
001110
011111
011111
000000
000000
CHAR 9658
001000
001100
001110
001111
001110
001100
001000
000000
CHAR 9660
011111
011111
001110
001110
000100
000100
000000
000000
CHAR 9668
000010
000110
001110
011110
001110
000110
000010
000000
CHAR 9675
000000
000000
011110
010010
010010
011110
000000
000000
CHAR 9688
111111
111111
111111
110011
110011
111111
111111
111111
CHAR 9689
111111
111111
100001
101101
101101
100001
111111
111111
CHAR 9786
001110
010001
011011
010001
010101
010001
001110
000000
CHAR 9787
001110
011111
010101
011111
010001
011111
001110
000000
CHAR 9788
000000
010101
001110
011011
001110
010101
000000
000000
CHAR 9792
001110
010001
010001
001110
000100
001110
000100
000000
CHAR 9794
000000
000111
000011
001101
010010
010010
001100
000000
CHAR 9824
000000
000100
001110
011111
011111
000100
001110
000000
CHAR 9827
000100
001110
001110
000100
011111
011111
000100
000000
CHAR 9829
000000
001010
011111
011111
011111
001110
000100
000000
CHAR 9830
000000
000100
001110
011111
011111
001110
000100
000000
CHAR 9834
000100
000110
000101
000100
001100
011100
011000
000000
CHAR 9835
000011
001101
001011
001101
001011
011011
011000
000000
</script>

</head>


<!-- DOCUMENT BODY -->
<body onload='startExportedGame()'>
	<!-- GAME CANVAS -->
	<canvas id='game'></canvas>
</body>


</html>